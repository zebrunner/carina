{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Carina is a Java-based test automation framework that unites all testing layers: Mobile applications (web, native, hybrid), WEB applications, REST services, Databases. TRY DEMO PROJECT NOW Carina Framework is built on top of the most popular open-source solutions like Selenium, Appium, TestNG allowing to reduce dependence on the specific technology stack. Carina supports all popular browsers (Edge, Safari, Chrome, Firefox) and mobile devices (iOS/Android). A special feature for a mobile domain: it reuses test automation code between IOS/Android up to 70-80%. Carina is cross-platform. Tests may be easily executed both on Unix or Windows OS. All you need is JDK 11 installed. The framework supports different types of databases - both relational and non-relational (MySQL, SQL Server, Oracle, PostgreSQL), providing amazing experience of DAO layer implementation using MyBatis ORM framework. API testing is based on a Freemarker template engine. It enables great flexibility in generating REST requests, and responses are dynamically changed by incoming arguments. Carina is fully integrated into Zebrunner that helps to setup a production-ready environment for running Mobile, Web and API tests. Feel free to ask any questions if you are going to use it in your company.","title":"Overview"},{"location":"#overview","text":"Carina is a Java-based test automation framework that unites all testing layers: Mobile applications (web, native, hybrid), WEB applications, REST services, Databases. TRY DEMO PROJECT NOW Carina Framework is built on top of the most popular open-source solutions like Selenium, Appium, TestNG allowing to reduce dependence on the specific technology stack. Carina supports all popular browsers (Edge, Safari, Chrome, Firefox) and mobile devices (iOS/Android). A special feature for a mobile domain: it reuses test automation code between IOS/Android up to 70-80%. Carina is cross-platform. Tests may be easily executed both on Unix or Windows OS. All you need is JDK 11 installed. The framework supports different types of databases - both relational and non-relational (MySQL, SQL Server, Oracle, PostgreSQL), providing amazing experience of DAO layer implementation using MyBatis ORM framework. API testing is based on a Freemarker template engine. It enables great flexibility in generating REST requests, and responses are dynamically changed by incoming arguments. Carina is fully integrated into Zebrunner that helps to setup a production-ready environment for running Mobile, Web and API tests. Feel free to ask any questions if you are going to use it in your company.","title":"Overview"},{"location":"configuration/","text":"There are multiple properties files located in src/main/resources: _api.properties - API test endpoints reference _config.properties - global test configuration _database.properties - database connection properties _email.properties - emailable reports config _testdata.properties - test user credentials All the properties may be retrieved in a test using R class: R.API.get(\"GetUserMethods\") R.CONFIG.get(\"browser\") R.DATABASE.get(\"db.url\") R.EMAIL.get(\"title\") R.TESTDATA.get(\"user.email\") The default config properties can be obtained by Configuration.get(Parameter.BROWSER) All the project configuration properties are located in a _config.properties file. In the table below, please see the description of most of the parameters: Attribute Meaning Example env Environment specific configuration feature STAG, PROD, DEMO selenium_url Selenium/Appium server URL http://localhost:4444/wd/hub app_version Application version/build number for reporting 1.2.5 url Base application URL https://zebrunner.com browser Browser for testing chrome, firefox, MicrosoftEdge, safari headless Run tests in headless browser mode. Default: false Boolean browser_language Browser language. Default: NULL to use default browser language. es, fr locale Locale for using by L10N feature en_GB, de_DE, fr_FR localization_testing Enables auto verification for elements that are marked with @Localized annotations Boolean localization_encoding Encoding for generation of new/missed localization resources UTF-8 retry_count Number of test-retryings in case of failure. Default: 0 means that a test will be performed only once Integer thread_count Number of threads to use when running tests in parallel. Default: -1 to use value from TestNG suite xml. Integer data_provider_thread_count Number of threads to use for data providers when running tests in parallel. Default: -1 to use value from TestNG suite xml. Integer core_log_level Level for Carina logging. Default: INFO ALL, DEBUG, ERROR, WARN, FATAL, INFO, OFF, TRACE test_run_rules Executing rules logic: test_run_rules={RULE_NAME_ENUM}=>{RULE_VALUE1}&&{RULE_VALUE2};;... test_run_rules=PRIORITY=>P1&&P2&&P4;;OWNER=>owner;;TAGS=>tag1=temp||!!feature=reg test_naming_pattern The pattern by which the name of the test method will be formed. {tuid} {test_name} - {method_name} retry_interval Timeout interval in ms between calling HTML DOM for the element. Default: 100 . For mobile automation specify in between 500-1000 Integer auto_screenshot Global switch for taking screenshots. When disabled, screenshots will be captured only after failures. Default: true . Boolean allow_fullsize_screenshot Global switch for allowing full size screenshots on failures. Default: false Boolean max_screen_history Max number of reports artifacts saved in history. Default: 10 Integer driver_event_listeners Comma-separated list of extra driver listeners. Listeners provide extra custom actions for WebDriver and have to be the instances of WebDriverEventListener com.some_company.core.EventListener max_driver_count Max number of drivers per thread. Default: 3 Integer init_retry_count Number of extra attempts to create a driver. Default: 0 means that there will be no extra attempts. Integer init_retry_interval Interval in seconds between the attempts to create a driver. Default: 1 Integer forcibly_disable_driver_quit If enabled, turns off webdriver quit based on initizalization phase . Default: false Boolean custom_capabilities Path to the properties file with custom key-value capabilities browserstack/win/win_10_Edge.properties explicit_timeout Timeout is seconds to wait for a certain condition to occur before proceeding further in the code Integer read_timeout Timeout is seconds to read response from Selenium/Appium. Default: 600 Integer page_opening_strategy Determines how carina detects whether the expected page is opened BY_ELEMENT, BY_URL, BY_URL_AND_ELEMENT page_recursive_reflection Determines if pages should be searched in dependencies. Default: false Boolean element_loading_strategy Determines how carina detects appearing of web elements on page BY_PRESENCE, BY_VISIBILITY, BY_PRESENCE_OR_VISIBILITY auto_download The enabled parameter prevents downloading dialog and downloading a file automatically into the test artifact folder. The feature is supported for Chrome and Firefox. Default: false false, true custom_artifacts_folder Custom unified path for auto-downloaded artifacts for all tests. Default: NULL to download into the unique test artifacts location. String auto_download_apps MIME types / Internet Media Types. The parameter is needed only to configure auto-downloading for FireFox. List of values application/pdf log_all_json API response will be logged in JSON format. Default: true Boolean ignore_ssl API requests/responses to ignore SSL errors. Default: false Boolean project_report_directory Path to a folder where the testing report will be saved ./reports proxy_host Hostname of the proxy server host.example.com proxy_port Port number 80 proxy_protocols Comma-separated list of internet protocols used to carry the connection information from the source requesting the connection to the destination for which the connection was requested. http,https,ftp,socks browserup_proxy Boolean parameter which enables or disables the automatic BrowserUp proxy launch Boolean browserup_port Port number for BrowserUp proxy (if nothing or 0 specified, then any free port will be reused) Integer browserup_ports_range Range of ports that will be used for starting of browserup proxy. The first available port from the range will be used. If all ports are used, then a test will wait for the first freed port. 8001:8003 proxy_set_to_system Boolean parameter which enables or disables the setup of a proxy Boolean no_proxy Excluded hostname(s) for communication via proxy. Available only when proxy_host and proxy_port are declared! localhost.example.com date_format Date format for DateUtils.class HH:mm:ss dd/MM/yyyy, HH:mm MM/dd/yyyy time_format Date format for DateUtils.class HH:mm:ss.SSS, HH:mm a zzz crypto_key_value crypto key OIujpEmIVZ0C9kOkXniFRw== tls_keysecure_location Path to a directory with tls secure keys ./tls/keysecure db.url Database url jdbc:mysql://localhost/test db.username Database username username db.password Database password password Most of the properties may be read in the following way: Configuration.get(Parameter.URL) // returns string value Configuration.getBoolean(Parameter.AUTO_SCREENSHOT) // returns boolean value Configuration.getInt(Parameter.BIG_SCREEN_WIDTH) //return int value Configuration.getDouble(Parameter.MAX_DRIVER_COUNT) // returns double value Environment specific configuration In some cases, it is required to support multiple environments for testing. Let's assume we have STAG and PROD environments which have different application URLs. In this case, we need to specify the following properties in _config.properties : env=PROD STAG.url=http://stag-app-server.com PROD.url=http://prod-app-server.com And get an env-specific argument in the test in the following way: Configuration.getEnvArg(\"url\") Configuration.getEnvArg(Configuration.Parameter.URL) As a result, you switch between the environments just changing the env argument in the _config.properties file. In some cases, it is necessary to store multiple parameter sets for the same env (for example, if multiple databases are used). For this, the concept of an alias is added. The parameter with env and alias will be stored in the following way: STAG.mongo.db.url=mongodb://stag.example.com:27017 STAG.mysql.db.url=jdbc:mysql://localhost/stag_test PROD.mongo.db.url=mongodb://prod.example.com:27017 PROD.mysql.db.url=jdbc:mysql://localhost/prod_db Get an env-alias-specific argument in the test in the following way: Configuration.getEnvArg(Configuration.Parameter.DB_URL, \"mongo\") // mongodb://prod.example.com:27017 Configuration.getEnvArg(Configuration.Parameter.DB_URL, \"mysql\") // jdbc:mysql://localhost/prod_db Tests execution filter configuration The test_run_rules parameter is responsible for filtering tests. There are 3 filter types: 1) PRIORITY - enum field (from P0 to P6) 2) OWNER - the test owner 3) TAGS - custom label Example of how to attach labels in code: @Test @TestPriority(Priority.P3) @MethodOwner(owner = \"Josh\") @MethodOwner(owner = \"Jake\") @TestTag(name = \"feature\", value = \"web\") @TestTag(name = \"type\", value = \"regression\") public void t4(){ ... some code ... } test_run_rules parameter parse logic: 1) A simple filter: test_run_rules=OWNER=>Josh #Where OWNER is tag, and \"=>\" split's tag and rule part. #Because of the \"Josh\" rule, test will be executed if it has Josh as owner 2) With negative logic: test_run_rules=OWNER=>!!Josh #Test will be executed if it hasn't got Josh as owner 3) With boolean logic: #Use || or && to create more difficult rules #where || == OR; && == AND. test_run_rules=OWNER=>Josh||Jake #Test will be executed if it has at least Josh or Jake as owner. test_run_rules=OWNER=>Josh&&Jake #Test will be executed if it has at least Jish and Jake as owner test_run_rules=OWNER=>Josh&&Jake||Peter #Expression will be processed in sequential priority, like #test_run_rules=OWNER=>((Josh&&Jake)||Peter) #So test will be executed if it has at least (Josh and Jake) or (Peter) as owner 4) To add more tags to the rule, use \";;\", for example: #;; works as && (AND) but for tags test_run_rules=PRIORITY=>!!P1;;OWNER=>Josh&&!!Jake;;TAGS=>feature=web&&!!type=smoke||feature=android #Test will be executed if it has #1) no @TestPriority(Priority.P1) #AND #2) @MethodOwner(owner = \"Josh\") without @MethodOwner(owner = \"Jake\") #AND #3) (@TestTag(name = \"feature\", value = \"web\") without @TestTag(name = \"type\", value = \"smoke\")) or @TestTag(name = \"feature\", value = \"android\") #In other words, tests will be executed only with Priority that differs from P1, with Josh as owner if there is no Jake #and if they are not for smoke web or if they are for android. Changing the pattern of forming the name of the test method The name of the test method is formed based on the pattern provided in the test_naming_pattern parameter. The pattern can be formed from the following parts: 1) {test_name} - test name (content of name attribute of <test> tag in xml) 2) {tuid} - TUID, see doc . 3) {method_name} - test method name 4) {method_priority} - test method priority (number) 5) {method_thread_pool_size} - the number of threads to be used when invoking the method on parallel 6) {group_names} - the groups this method belongs to, possibly added to the groups declared on the class. 7) {method_description} - description of test method 8) {test_class} - simple name of test class this method belongs to Default pattern: test_naming_pattern={tuid} {test_name} - {method_name} FAQ Where is a recommended place to declare configuration parameters? Declare default parameters in _config.properties . For multi-maven projects, you can use extra underscore symbol to override default settings on new layer __config.properties , ___config.properties , etc. How to override params from the code? Put method might be used to override parameters globally or for a current test only R.CONFIG.put(\"selenium_url\", \"http://host1:4444/wd/hub\"); //override selenium_url globally for the rest of tests R.CONFIG.put(\"selenium_url\", \"http://host2:4444/wd/hub\", true); // override selenium_url for current test only R.DATABASE.put(\"db.driver\", \"org.postgresql.Driver\") //override db.driver in_database.properties globally Crypted values are returned in encrypted format. How can I decrypt them? Use R.CONFIG.getDecrypted(String key) method to read decrypted value. You should have valid crypto key to be able to decrypt values. For details, visit Security Can I override configuration parameters from CI? Provide updated values via System Properties to override a value, for example: mvn -Denv=PROD ...","title":"Configuration"},{"location":"configuration/#environment-specific-configuration","text":"In some cases, it is required to support multiple environments for testing. Let's assume we have STAG and PROD environments which have different application URLs. In this case, we need to specify the following properties in _config.properties : env=PROD STAG.url=http://stag-app-server.com PROD.url=http://prod-app-server.com And get an env-specific argument in the test in the following way: Configuration.getEnvArg(\"url\") Configuration.getEnvArg(Configuration.Parameter.URL) As a result, you switch between the environments just changing the env argument in the _config.properties file. In some cases, it is necessary to store multiple parameter sets for the same env (for example, if multiple databases are used). For this, the concept of an alias is added. The parameter with env and alias will be stored in the following way: STAG.mongo.db.url=mongodb://stag.example.com:27017 STAG.mysql.db.url=jdbc:mysql://localhost/stag_test PROD.mongo.db.url=mongodb://prod.example.com:27017 PROD.mysql.db.url=jdbc:mysql://localhost/prod_db Get an env-alias-specific argument in the test in the following way: Configuration.getEnvArg(Configuration.Parameter.DB_URL, \"mongo\") // mongodb://prod.example.com:27017 Configuration.getEnvArg(Configuration.Parameter.DB_URL, \"mysql\") // jdbc:mysql://localhost/prod_db","title":"Environment specific configuration"},{"location":"configuration/#tests-execution-filter-configuration","text":"The test_run_rules parameter is responsible for filtering tests. There are 3 filter types: 1) PRIORITY - enum field (from P0 to P6) 2) OWNER - the test owner 3) TAGS - custom label Example of how to attach labels in code: @Test @TestPriority(Priority.P3) @MethodOwner(owner = \"Josh\") @MethodOwner(owner = \"Jake\") @TestTag(name = \"feature\", value = \"web\") @TestTag(name = \"type\", value = \"regression\") public void t4(){ ... some code ... } test_run_rules parameter parse logic: 1) A simple filter: test_run_rules=OWNER=>Josh #Where OWNER is tag, and \"=>\" split's tag and rule part. #Because of the \"Josh\" rule, test will be executed if it has Josh as owner 2) With negative logic: test_run_rules=OWNER=>!!Josh #Test will be executed if it hasn't got Josh as owner 3) With boolean logic: #Use || or && to create more difficult rules #where || == OR; && == AND. test_run_rules=OWNER=>Josh||Jake #Test will be executed if it has at least Josh or Jake as owner. test_run_rules=OWNER=>Josh&&Jake #Test will be executed if it has at least Jish and Jake as owner test_run_rules=OWNER=>Josh&&Jake||Peter #Expression will be processed in sequential priority, like #test_run_rules=OWNER=>((Josh&&Jake)||Peter) #So test will be executed if it has at least (Josh and Jake) or (Peter) as owner 4) To add more tags to the rule, use \";;\", for example: #;; works as && (AND) but for tags test_run_rules=PRIORITY=>!!P1;;OWNER=>Josh&&!!Jake;;TAGS=>feature=web&&!!type=smoke||feature=android #Test will be executed if it has #1) no @TestPriority(Priority.P1) #AND #2) @MethodOwner(owner = \"Josh\") without @MethodOwner(owner = \"Jake\") #AND #3) (@TestTag(name = \"feature\", value = \"web\") without @TestTag(name = \"type\", value = \"smoke\")) or @TestTag(name = \"feature\", value = \"android\") #In other words, tests will be executed only with Priority that differs from P1, with Josh as owner if there is no Jake #and if they are not for smoke web or if they are for android.","title":"Tests execution filter configuration"},{"location":"configuration/#changing-the-pattern-of-forming-the-name-of-the-test-method","text":"The name of the test method is formed based on the pattern provided in the test_naming_pattern parameter. The pattern can be formed from the following parts: 1) {test_name} - test name (content of name attribute of <test> tag in xml) 2) {tuid} - TUID, see doc . 3) {method_name} - test method name 4) {method_priority} - test method priority (number) 5) {method_thread_pool_size} - the number of threads to be used when invoking the method on parallel 6) {group_names} - the groups this method belongs to, possibly added to the groups declared on the class. 7) {method_description} - description of test method 8) {test_class} - simple name of test class this method belongs to Default pattern: test_naming_pattern={tuid} {test_name} - {method_name}","title":"Changing the pattern of forming the name of the test method"},{"location":"configuration/#faq","text":"Where is a recommended place to declare configuration parameters? Declare default parameters in _config.properties . For multi-maven projects, you can use extra underscore symbol to override default settings on new layer __config.properties , ___config.properties , etc. How to override params from the code? Put method might be used to override parameters globally or for a current test only R.CONFIG.put(\"selenium_url\", \"http://host1:4444/wd/hub\"); //override selenium_url globally for the rest of tests R.CONFIG.put(\"selenium_url\", \"http://host2:4444/wd/hub\", true); // override selenium_url for current test only R.DATABASE.put(\"db.driver\", \"org.postgresql.Driver\") //override db.driver in_database.properties globally Crypted values are returned in encrypted format. How can I decrypt them? Use R.CONFIG.getDecrypted(String key) method to read decrypted value. You should have valid crypto key to be able to decrypt values. For details, visit Security Can I override configuration parameters from CI? Provide updated values via System Properties to override a value, for example: mvn -Denv=PROD ...","title":"FAQ"},{"location":"contribution/","text":"There are multiple ways to contribute to Carina. See below for everything you can do and the processes to follow for each contribution method. Your contribution is governed by our Code of Conduct . Make changes to the Carina code or docs Please use the unified code formatter Java code formatter for Eclipse ; in IntelliJ IDEA, install and configure Eclipse Code Formatter . Fork the project, make a change, and send a pull request. For every Pull Request, an automatic snapshot build is generated and Sonar quality checks are performed. The exact build number can be found among the check details: Update your project pom.xml , make sure to have a snapshot repository enabled and test your changes. Add test results/comments into the Pull Request if possible. After reviewing and merging, we generate a consolidated release candidate build increasing the build number, for example, after release 1.0.0 all the merges come into 1.0.0-SNAPSHOT . We strongly recommend that you do one more testing round using this build number. The release candidate build number can also be found in the latest SHA1 commit details: Help out on our community We can always use help on our forums at Carina Support ! Hop on over and see if there are any questions that you can answer. Submit bug reports or feature requests Just use the GitHub issue tracker to submit your bug reports and feature requests. Please follow the issue or feature templates.","title":"Contribution"},{"location":"contribution/#make-changes-to-the-carina-code-or-docs","text":"Please use the unified code formatter Java code formatter for Eclipse ; in IntelliJ IDEA, install and configure Eclipse Code Formatter . Fork the project, make a change, and send a pull request. For every Pull Request, an automatic snapshot build is generated and Sonar quality checks are performed. The exact build number can be found among the check details: Update your project pom.xml , make sure to have a snapshot repository enabled and test your changes. Add test results/comments into the Pull Request if possible. After reviewing and merging, we generate a consolidated release candidate build increasing the build number, for example, after release 1.0.0 all the merges come into 1.0.0-SNAPSHOT . We strongly recommend that you do one more testing round using this build number. The release candidate build number can also be found in the latest SHA1 commit details:","title":"Make changes to the Carina code or docs"},{"location":"contribution/#help-out-on-our-community","text":"We can always use help on our forums at Carina Support ! Hop on over and see if there are any questions that you can answer.","title":"Help out on our community"},{"location":"contribution/#submit-bug-reports-or-feature-requests","text":"Just use the GitHub issue tracker to submit your bug reports and feature requests. Please follow the issue or feature templates.","title":"Submit bug reports or feature requests"},{"location":"cucumber/","text":"Carina allows you to integrate BDD approach into your test project easily. Under the hood it uses popular BDD framework Cucumber extending its basic functionality and integrating cool test reports. To integrate carina-cucumber functionality you just need to add its library into your project. For instance with maven that can be done by adding next lines into your pom.xml: <dependency> <groupId>com.zebrunner</groupId> <artifactId>carina-cucumber</artifactId> <version>${carina-cucumber_version}</version> </dependency> Setting up cucumber test with carina In order to automate your test on cucumber you'll need to implement couple of things: Write down text of your scenario using cucumber syntax Declare each step of your scenario in Jave \u0441ode Map text representation of scenario with Java classes describing it Carina supports Gherkin syntax for describing of test scenarios. More details on syntax can be found here . Example of such scenario: Feature: GSM Arena News testing In order to use Cucumber in my project, I want to check how to test GSM Arena News page @demo Scenario: GSM Arena open page - original Given I am on main page When I open 'News' page Then page 'News' should be open And page 'News' should contains all items File should be stored in test/java/resources/features/ package and have .feature extension. To declare steps in Java you need to use cucumber annotations @Given, @When, @Then, etc. More details on all possible annotations could be found in official cucumber documentation . In case if some steps declaration is missing you'll get informative error in your console when you run the test. If you need to operate with WebDriver instance within the class where you're declaring Java methods for you steps you can use IDriverPool class of carina. Example: public class GSMArenaNewsSteps implements IDriverPool { @Given(\"^I am on main page\") public boolean iAmOnMainPage() { HomePage homePage = new HomePage(getDriver()); homePage.open(); return homePage.isPageOpened(); } } Finally, to map text steps with Java declaration you need to create test class and extend it from CucumberBaseTest carina class. Then use @CucumberOptions annotation in order to complete the mapping itself. Class body can be empty since all logic for buildind of scripts and running them is implemented inside CucumberBaseTest class. Here is the sample of such code: @CucumberOptions(features = \"src/test/resources/features/GSMArenaNews.feature\", glue = \"com.zebrunner.carina.demo.cucumber.steps\", plugin = {\"pretty\", \"html:target/cucumber-core-test-report\", \"pretty:target/cucumber-core-test-report.txt\", \"json:target/cucumber-core-test-report.json\", \"junit:target/cucumber-core-test-report.xml\"} ) public class CucumberWebSampleTest extends CucumberBaseTest {} Cucumber report In addition to default integration of your cucumber tests with Zebrunner reporting tool you can get extended cucumber report available by default. It's getting generated automatically once test is done (in case if you enabled json reporting for your test by \"json:target/some-report-name.json\" plugin) Then after report being generated the link to it will be added to your emailable HTML report generated by Carina: To get this link valid you'll need to secify proper path to your report folder using report_url carina config property. In case of local run it should refer to your local report folder. Here is the sample of the report: Parallel execution You can execute cucumber tests in parallel. You can control it by data-provider-thread-count property from carina properties list. The value of that parameter will define maximum amount of parallel threads for your cucumber tests.","title":"Cucumber"},{"location":"cucumber/#setting-up-cucumber-test-with-carina","text":"In order to automate your test on cucumber you'll need to implement couple of things: Write down text of your scenario using cucumber syntax Declare each step of your scenario in Jave \u0441ode Map text representation of scenario with Java classes describing it Carina supports Gherkin syntax for describing of test scenarios. More details on syntax can be found here . Example of such scenario: Feature: GSM Arena News testing In order to use Cucumber in my project, I want to check how to test GSM Arena News page @demo Scenario: GSM Arena open page - original Given I am on main page When I open 'News' page Then page 'News' should be open And page 'News' should contains all items File should be stored in test/java/resources/features/ package and have .feature extension. To declare steps in Java you need to use cucumber annotations @Given, @When, @Then, etc. More details on all possible annotations could be found in official cucumber documentation . In case if some steps declaration is missing you'll get informative error in your console when you run the test. If you need to operate with WebDriver instance within the class where you're declaring Java methods for you steps you can use IDriverPool class of carina. Example: public class GSMArenaNewsSteps implements IDriverPool { @Given(\"^I am on main page\") public boolean iAmOnMainPage() { HomePage homePage = new HomePage(getDriver()); homePage.open(); return homePage.isPageOpened(); } } Finally, to map text steps with Java declaration you need to create test class and extend it from CucumberBaseTest carina class. Then use @CucumberOptions annotation in order to complete the mapping itself. Class body can be empty since all logic for buildind of scripts and running them is implemented inside CucumberBaseTest class. Here is the sample of such code: @CucumberOptions(features = \"src/test/resources/features/GSMArenaNews.feature\", glue = \"com.zebrunner.carina.demo.cucumber.steps\", plugin = {\"pretty\", \"html:target/cucumber-core-test-report\", \"pretty:target/cucumber-core-test-report.txt\", \"json:target/cucumber-core-test-report.json\", \"junit:target/cucumber-core-test-report.xml\"} ) public class CucumberWebSampleTest extends CucumberBaseTest {}","title":"Setting up cucumber test with carina"},{"location":"cucumber/#cucumber-report","text":"In addition to default integration of your cucumber tests with Zebrunner reporting tool you can get extended cucumber report available by default. It's getting generated automatically once test is done (in case if you enabled json reporting for your test by \"json:target/some-report-name.json\" plugin) Then after report being generated the link to it will be added to your emailable HTML report generated by Carina: To get this link valid you'll need to secify proper path to your report folder using report_url carina config property. In case of local run it should refer to your local report folder. Here is the sample of the report:","title":"Cucumber report"},{"location":"cucumber/#parallel-execution","text":"You can execute cucumber tests in parallel. You can control it by data-provider-thread-count property from carina properties list. The value of that parameter will define maximum amount of parallel threads for your cucumber tests.","title":"Parallel execution"},{"location":"execution/","text":"Before running any web or mobile test you have to start Selenium/Appium locally or use a remote Selenium Grid. We recommend to use scalable Zebrunner Engine grid. Running tests There are several options to execute a test: you may run test suite from Eclipse IDE or initiate test execution from the console using Maven Surefire plugin built into Carina framework. To run test suite from Eclipse IDE, just select the required TestNG xml file: Right click > Run As > TestNG suite To run the same test suite from the console, navigate to the test project root (where pom.xml is located) and execute the following command: mvn clean -Dsuite=api test Overriden configuration parameters migth be provided as Java arguments: mvn clean -Denv=STAG -Dbrowser=firefox -Dsuite=web test","title":"Execution"},{"location":"execution/#running-tests","text":"There are several options to execute a test: you may run test suite from Eclipse IDE or initiate test execution from the console using Maven Surefire plugin built into Carina framework. To run test suite from Eclipse IDE, just select the required TestNG xml file: Right click > Run As > TestNG suite To run the same test suite from the console, navigate to the test project root (where pom.xml is located) and execute the following command: mvn clean -Dsuite=api test Overriden configuration parameters migth be provided as Java arguments: mvn clean -Denv=STAG -Dbrowser=firefox -Dsuite=web test","title":"Running tests"},{"location":"getting_started/","text":"Install and configure JDK 11+ Install and configure Apache Maven 3.6.0+ Download the latest version of Eclipse and install TestNG plugin , maven-dependency-plugin connector and optionally lombok Generating project The easiest way to initialize a new project is to use Carina archetype, you will get correct project structure along with test samples. Run below command from any empty folder : mvn archetype:generate -DarchetypeGroupId=com.zebrunner \\ -DarchetypeArtifactId=carina-archetype \\ -DarchetypeVersion=RELEASE \\ -DgroupId=<your_groupId> \\ -DartifactId=<your_artifactId> \\ -Dname=\"<you_project_name>\" \\ -Durl=<your_project_url> \\ -Dversion=<your_project_version> If any attribute contains spaces, it should be set in quotes (e.g.: -Dname=\"Hello World\"). In the above Maven command you need to specify 5 attributes, while the first 3 should be left unchanged: Attribute Meaning Example -DgroupId Company domain in reverse order com.mycompany -DartifactId Java project name project-qa -Dname Name with more details \"Test Automation Project\" -Durl Company URL http://mycompany.com -Dversion Project version 1.0 To generate Cucumber Demo project use -DarchetypeArtifactId=carina-cucumber-archetype in above maven command. Import to Eclipse If the generation is successfully complete, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean eclipse:eclipse By executing this command, Maven should resolve all dependencies, downloading the required libraries to your local repository and generating the Eclipse classpath. Before importing a new project to Eclipse, you should link your IDE to your Maven repository by executing the following task: mvn -Declipse.workspace=<path_to_workspace> eclipse:configure-workspace Here you need to specify the absolute path to the Eclipse workspace. After that, restart Eclipse IDE. Now you can import generated projects such as \"Existing Java Project\" into Eclipse IDE.","title":"Getting started"},{"location":"getting_started/#generating-project","text":"The easiest way to initialize a new project is to use Carina archetype, you will get correct project structure along with test samples. Run below command from any empty folder : mvn archetype:generate -DarchetypeGroupId=com.zebrunner \\ -DarchetypeArtifactId=carina-archetype \\ -DarchetypeVersion=RELEASE \\ -DgroupId=<your_groupId> \\ -DartifactId=<your_artifactId> \\ -Dname=\"<you_project_name>\" \\ -Durl=<your_project_url> \\ -Dversion=<your_project_version> If any attribute contains spaces, it should be set in quotes (e.g.: -Dname=\"Hello World\"). In the above Maven command you need to specify 5 attributes, while the first 3 should be left unchanged: Attribute Meaning Example -DgroupId Company domain in reverse order com.mycompany -DartifactId Java project name project-qa -Dname Name with more details \"Test Automation Project\" -Durl Company URL http://mycompany.com -Dversion Project version 1.0 To generate Cucumber Demo project use -DarchetypeArtifactId=carina-cucumber-archetype in above maven command.","title":"Generating project"},{"location":"getting_started/#import-to-eclipse","text":"If the generation is successfully complete, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean eclipse:eclipse By executing this command, Maven should resolve all dependencies, downloading the required libraries to your local repository and generating the Eclipse classpath. Before importing a new project to Eclipse, you should link your IDE to your Maven repository by executing the following task: mvn -Declipse.workspace=<path_to_workspace> eclipse:configure-workspace Here you need to specify the absolute path to the Eclipse workspace. After that, restart Eclipse IDE. Now you can import generated projects such as \"Existing Java Project\" into Eclipse IDE.","title":"Import to Eclipse"},{"location":"migration/","text":"Migration guide from 7.4.31 to 1.0.0 . Selenium/Appium versions updated The Selenium version has been updated from 3.141.59 to 4.4.0 . Check out the official migration guide . The Appium version has been updated from 7.6.0 to 8.2.0 . Check out the official migration guide . Renamed packages com.qaprosoft.carina.core.foundation.utils.ownership.* -> com.zebrunner.carina.core.registrar.ownership.* com.qaprosoft.carina.core.foundation.utils.tag.* -> com.zebrunner.carina.core.registrar.tag.* com.qaprosoft.carina.core.foundation.utils.Messager -> com.zebrunner.carina.utils.messager.Messager com.qaprosoft.carina.core.foundation.utils.ZebrunnerNameResolver -> com.zebrunner.carina.core.testng.ZebrunnerNameResolver com.qaprosoft.carina.core.foundation.utils.ParameterGenerator -> com.zebrunner.carina.utils.ParameterGenerator com.qaprosoft.carina.core.foundation.utils.* -> com.zebrunner.carina.utils.* com.qaprosoft.carina.core.foundation.report.* -> com.zebrunner.carina.utils.report.* com.qaprosoft.carina.core.foundation.retry.* -> com.zebrunner.carina.utils.retry.* com.qaprosoft.carina.core.foundation.commons.SpecialKeywords -> com.zebrunner.carina.utils.commons.SpecialKeywords com.qaprosoft.carina.core.foundation.listeners.TestnamingService -> com.zebrunner.carina.core.testng.TestNamingService com.qaprosoft.carina.core.foundation.exception.* -> com.zebrunner.carina.utils.exception.* com.qaprosoft.carina.core.foundation.performance.* -> com.zebrunner.carina.utils.performance.* com.qaprosoft.carina.browserupproxy.* -> com.zebrunner.carina.proxy.browserup.* com.qaprosoft.carina.proxy.SystemProxy -> com.zebrunner.carina.proxy.SystemProxy com.qaprosoft.amazon.* -> com.zebrunner.carina.amazon.* com.qaprosoft.azure.* -> com.zebrunner.carina.azure.* com.qaprosoft.appcenter.* -> com.zebrunner.carina.appcenter.* com.qaprosoft.apitools.* -> com.zebrunner.carina.api.apitools.* com.qaprosoft.carina.core.foundation.api.* -> com.zebrunner.carina.api.* com.qaprosoft.carina.core.foundation.webdriver.* -> com.zebrunner.carina.webdriver.* com.qaprosoft.carina.core.gui.* -> com.zebrunner.carina.webdriver.gui.* com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSCache -> com.zebrunner.carina.utils.parser.xls.XLSCache com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSChildTable -> com.zebrunner.carina.utils.parser.xls.XLSChildTable com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSParser -> com.zebrunner.carina.utils.parser.xls.XLSParser com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSTable -> com.zebrunner.carina.utils.parser.xls.XLSTable com.qaprosoft.carina.core.foundation.dataprovider.* -> com.zebrunner.carina.dataprovider.* com.qaprosoft.carina.core.foundation.* -> com.zebrunner.carina.core.* Separated optional dependencies These dependencies can be added in addition to the carina-core dependency. carina-dataprovider see (maven-central) - to use csv/xls data providers. Test classes that use/will use such dataproviders should implement com.zebrunner.carina.dataprovider.IAbstractDataProvider interface. For more info check documentation . Also when adding carina-dataprovider dependency exclude testng dependency as the only source of testng should be carina-core. carina-api see (maven-central) - for API testing. carina-appcenter see (maven-central) - if the application is stored using AppCenter. carina-azure see (maven-central) - if the application/files are stored using Azure. carina-aws-s3 see (maven-central) - if the application/files are stored using Amazon S3. Redesigned the encryption process The support of crypto key as a file, as well as the actual crypto_key_path parameter, have been removed. The crypto_key_value parameter is added to specify the crypto key (specified in configuration ). The presence of a crypto key is optional, as long as there is no encrypted data. Since a file was used as a key before, you can use the following code to get the key from it and writing it to the crypto_key_value parameter (for example, in beforeSuite): R.CONFIG.put(\"crypto_key_value\", Files.readString(Path.of(R.CONFIG.get(\"crypto_key_path\")), StandardCharsets.UTF_8)); However, this approach is not recommended. It is recommended to put crypto_key_value in environment variables. For more info check documentation . Changed the process of creating capabilities for a session In connection with the update of Selenium / Appium, the rules for specifying capabilities have changed. Check the documentation . Screenshots Screenshot rules redesigned, check the documentation . Driver event listeners In connection with the update of Selenium, the use of a org.openqa.selenium.support.events.WebDriverEventListener event listener has been removed and accordingly removed the wrapper based on the org.openqa.selenium.support.events.EventFiringWebDriver class. Instead, use an event listener based on the org.openqa.selenium.support.events.WebDriverListener interface (as an example, take a look at Carina Framework DriverListener event listener). Important: it is strongly not recommended to use methods of drivers by casting to the driver implementations, drivers implement interfaces with appropriate methods, up to which you need to cast the driver to gain access to the method. For example, if you want to call the method executeScript of the org.openqa.selenium.remote.RemoteWebDriver class, you can execute the following code: ((JavascriptExecutor)getDriver()).executeScript(...); However, there are methods that cannot be accessed using the interface. In such situation you can use the castDriver method of the com.zebrunner.carina.webdriver.listener.DriverListener class. However, if you are casting to AndroidDriver for example, you must be sure it's AndroidDriver. Project side dependency requirements The net.bytebuddy.byte-buddy version should be 1.12.10 . The com.zebrunner.agent-core version should be 1.9.3 . When specifying carina-... dependencies, it is desirable that carina-core be the first among them. The explicit com.google.guava.guava dependency must be removed from the project, and guava must be pulled from carina-webdriver (you can check it using mvn dependency:tree ) and should match version 31.1-jre . Proxy Changed BrowserMob proxy to BrowserUp proxy , added different proxy modes from Selenium. For more info check the documentation . Element search process Added support for annotations FindBys , FindAll , AndroidFindBy and so on. However, using features such as CaseInsensitiveXpath annotation, L10N in locator, format method and so on is currently not supported with FindBys, FindAny, FindAll and Appium ..Bys, ..All, ...AllSet, ..ChainSet annotations. The format method of the ExtendedWebElement class now works with localization and the CaseInsensitiveXpath annotation.","title":"Migration Guide"},{"location":"migration/#seleniumappium-versions-updated","text":"The Selenium version has been updated from 3.141.59 to 4.4.0 . Check out the official migration guide . The Appium version has been updated from 7.6.0 to 8.2.0 . Check out the official migration guide .","title":"Selenium/Appium versions updated"},{"location":"migration/#renamed-packages","text":"com.qaprosoft.carina.core.foundation.utils.ownership.* -> com.zebrunner.carina.core.registrar.ownership.* com.qaprosoft.carina.core.foundation.utils.tag.* -> com.zebrunner.carina.core.registrar.tag.* com.qaprosoft.carina.core.foundation.utils.Messager -> com.zebrunner.carina.utils.messager.Messager com.qaprosoft.carina.core.foundation.utils.ZebrunnerNameResolver -> com.zebrunner.carina.core.testng.ZebrunnerNameResolver com.qaprosoft.carina.core.foundation.utils.ParameterGenerator -> com.zebrunner.carina.utils.ParameterGenerator com.qaprosoft.carina.core.foundation.utils.* -> com.zebrunner.carina.utils.* com.qaprosoft.carina.core.foundation.report.* -> com.zebrunner.carina.utils.report.* com.qaprosoft.carina.core.foundation.retry.* -> com.zebrunner.carina.utils.retry.* com.qaprosoft.carina.core.foundation.commons.SpecialKeywords -> com.zebrunner.carina.utils.commons.SpecialKeywords com.qaprosoft.carina.core.foundation.listeners.TestnamingService -> com.zebrunner.carina.core.testng.TestNamingService com.qaprosoft.carina.core.foundation.exception.* -> com.zebrunner.carina.utils.exception.* com.qaprosoft.carina.core.foundation.performance.* -> com.zebrunner.carina.utils.performance.* com.qaprosoft.carina.browserupproxy.* -> com.zebrunner.carina.proxy.browserup.* com.qaprosoft.carina.proxy.SystemProxy -> com.zebrunner.carina.proxy.SystemProxy com.qaprosoft.amazon.* -> com.zebrunner.carina.amazon.* com.qaprosoft.azure.* -> com.zebrunner.carina.azure.* com.qaprosoft.appcenter.* -> com.zebrunner.carina.appcenter.* com.qaprosoft.apitools.* -> com.zebrunner.carina.api.apitools.* com.qaprosoft.carina.core.foundation.api.* -> com.zebrunner.carina.api.* com.qaprosoft.carina.core.foundation.webdriver.* -> com.zebrunner.carina.webdriver.* com.qaprosoft.carina.core.gui.* -> com.zebrunner.carina.webdriver.gui.* com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSCache -> com.zebrunner.carina.utils.parser.xls.XLSCache com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSChildTable -> com.zebrunner.carina.utils.parser.xls.XLSChildTable com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSParser -> com.zebrunner.carina.utils.parser.xls.XLSParser com.qaprosoft.carina.core.foundation.dataprovider.parser.XLSTable -> com.zebrunner.carina.utils.parser.xls.XLSTable com.qaprosoft.carina.core.foundation.dataprovider.* -> com.zebrunner.carina.dataprovider.* com.qaprosoft.carina.core.foundation.* -> com.zebrunner.carina.core.*","title":"Renamed packages"},{"location":"migration/#separated-optional-dependencies","text":"These dependencies can be added in addition to the carina-core dependency. carina-dataprovider see (maven-central) - to use csv/xls data providers. Test classes that use/will use such dataproviders should implement com.zebrunner.carina.dataprovider.IAbstractDataProvider interface. For more info check documentation . Also when adding carina-dataprovider dependency exclude testng dependency as the only source of testng should be carina-core. carina-api see (maven-central) - for API testing. carina-appcenter see (maven-central) - if the application is stored using AppCenter. carina-azure see (maven-central) - if the application/files are stored using Azure. carina-aws-s3 see (maven-central) - if the application/files are stored using Amazon S3.","title":"Separated optional dependencies"},{"location":"migration/#redesigned-the-encryption-process","text":"The support of crypto key as a file, as well as the actual crypto_key_path parameter, have been removed. The crypto_key_value parameter is added to specify the crypto key (specified in configuration ). The presence of a crypto key is optional, as long as there is no encrypted data. Since a file was used as a key before, you can use the following code to get the key from it and writing it to the crypto_key_value parameter (for example, in beforeSuite): R.CONFIG.put(\"crypto_key_value\", Files.readString(Path.of(R.CONFIG.get(\"crypto_key_path\")), StandardCharsets.UTF_8)); However, this approach is not recommended. It is recommended to put crypto_key_value in environment variables. For more info check documentation .","title":"Redesigned the encryption process"},{"location":"migration/#changed-the-process-of-creating-capabilities-for-a-session","text":"In connection with the update of Selenium / Appium, the rules for specifying capabilities have changed. Check the documentation .","title":"Changed the process of creating capabilities for a session"},{"location":"migration/#screenshots","text":"Screenshot rules redesigned, check the documentation .","title":"Screenshots"},{"location":"migration/#driver-event-listeners","text":"In connection with the update of Selenium, the use of a org.openqa.selenium.support.events.WebDriverEventListener event listener has been removed and accordingly removed the wrapper based on the org.openqa.selenium.support.events.EventFiringWebDriver class. Instead, use an event listener based on the org.openqa.selenium.support.events.WebDriverListener interface (as an example, take a look at Carina Framework DriverListener event listener). Important: it is strongly not recommended to use methods of drivers by casting to the driver implementations, drivers implement interfaces with appropriate methods, up to which you need to cast the driver to gain access to the method. For example, if you want to call the method executeScript of the org.openqa.selenium.remote.RemoteWebDriver class, you can execute the following code: ((JavascriptExecutor)getDriver()).executeScript(...); However, there are methods that cannot be accessed using the interface. In such situation you can use the castDriver method of the com.zebrunner.carina.webdriver.listener.DriverListener class. However, if you are casting to AndroidDriver for example, you must be sure it's AndroidDriver.","title":"Driver event listeners"},{"location":"migration/#project-side-dependency-requirements","text":"The net.bytebuddy.byte-buddy version should be 1.12.10 . The com.zebrunner.agent-core version should be 1.9.3 . When specifying carina-... dependencies, it is desirable that carina-core be the first among them. The explicit com.google.guava.guava dependency must be removed from the project, and guava must be pulled from carina-webdriver (you can check it using mvn dependency:tree ) and should match version 31.1-jre .","title":"Project side dependency requirements"},{"location":"migration/#proxy","text":"Changed BrowserMob proxy to BrowserUp proxy , added different proxy modes from Selenium. For more info check the documentation .","title":"Proxy"},{"location":"migration/#element-search-process","text":"Added support for annotations FindBys , FindAll , AndroidFindBy and so on. However, using features such as CaseInsensitiveXpath annotation, L10N in locator, format method and so on is currently not supported with FindBys, FindAny, FindAll and Appium ..Bys, ..All, ...AllSet, ..ChainSet annotations. The format method of the ExtendedWebElement class now works with localization and the CaseInsensitiveXpath annotation.","title":"Element search process"},{"location":"project_structure/","text":"Carina test project is structured as a standard Maven project: carina-demo |-- pom.xml |-- src/test/java |-- src/test/resources |-- api |-- testng_suites |-- xls |-- src/main/java |-- src/main/resources |-- L10N src/test/java - contains test classes organized using TestNG annotations src/test/resources - contains TestNG xml files, API templates and XLS/CSV data providers, etc. src/main/java - contains page object classes, API domains and additional utilities src/main/resources - contains L10N resources, configuration properties files and MyBatis profiles if needed","title":"Project structure"},{"location":"advanced/database/","text":"Here is a simple DB schema that will be used for this sample: We will implement mapping for Users and UserPreferences tables. Dependencies For integration with DB, we recommend to use MyBatis ORM framework. MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. To start with, let's add the required dependencies into Maven pom.xml: <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.2</version> </dependency> <!-- Postgres driver --> <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.6</version> </dependency> <!-- MySQL driver --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.17</version> </dependency> Mappers The next step is MyBatis mappers implementation, read the official documentation to understand all the details. Let's place all the mappers into src/main/resources/mappers . Here is a UserMapper.xml sample: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> <mapper namespace=\"com.zebrunner.carina.demo.db.mappers.UserMapper\"> <insert id=\"create\" useGeneratedKeys=\"true\" keyProperty=\"id\"> <![CDATA[ INSERT INTO carina.USERS (USERNAME, PASSWORD, FIRST_NAME, LAST_NAME, EMAIL, STATUS) VALUES ( #{username}, #{password}, #{firstName}, #{lastName}, #{email}, #{status} ) ]]> </insert> <sql id=\"getUser\"> <![CDATA[ SELECT U.ID AS USER_ID, U.USERNAME AS USER_USERNAME, U.PASSWORD AS USER_PASSWORD, U.FIRST_NAME AS USER_FIRST_NAME, U.LAST_NAME AS USER_LAST_NAME, U.EMAIL AS USER_EMAIL, U.STATUS AS USER_STATUS, UP.ID AS USER_PREFERENCE_ID, UP.NAME AS USER_PREFERENCE_NAME, UP.VALUE AS USER_PREFERENCE_VALUE, UP.USER_ID AS USER_PREFERENCE_USER_ID FROM carina.USERS U LEFT JOIN carina.USER_PREFERENCES UP ON UP.USER_ID = U.ID ]]> </sql> <select id=\"findById\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.ID = #{id}; ]]> </select> <select id=\"findByUserName\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.USERNAME = #{username}; ]]> </select> <update id=\"update\"> <![CDATA[ UPDATE carina.USERS ]]> <set> <if test=\"null != firstName\"> <![CDATA[ FIRST_NAME = #{firstName}, ]]> </if> <if test=\"null != lastName\"> <![CDATA[ LAST_NAME = #{lastName}, ]]> </if> <if test=\"null != email\"> <![CDATA[ EMAIL = #{email}, ]]> </if> <if test=\"null != username\"> <![CDATA[ USERNAME = #{username}, ]]> </if> <if test=\"null != password\"> <![CDATA[ PASSWORD = #{password}, ]]> </if> </set> <![CDATA[ WHERE ID = #{id} ]]> </update> <delete id=\"delete\"> <![CDATA[ DELETE FROM carina.USERS WHERE ID = #{id} ]]> </delete> <resultMap type=\"com.zebrunner.carina.demo.db.models.User\" id=\"UserResultMap\" autoMapping=\"false\"> <id column=\"USER_ID\" property=\"id\" /> <result column=\"USER_USERNAME\" property=\"username\" /> <result column=\"USER_PASSWORD\" property=\"password\" /> <result column=\"USER_FIRST_NAME\" property=\"firstName\" /> <result column=\"USER_LAST_NAME\" property=\"lastName\" /> <result column=\"USER_EMAIL\" property=\"email\" /> <result column=\"USER_STATUS\" property=\"status\" /> <collection property=\"preferences\" ofType=\"com.zebrunner.carina.demo.db.models.UserPreference\" resultMap=\"com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper.UserPreferenceResultMap\" /> </resultMap> </mapper> Now we have to implement a DB domain object User class which reflects the DB table structure: package com.zebrunner.carina.demo.db.models; import java.util.ArrayList; import java.util.List; public class User { private Long id; private String username; private String password; private String email; private String firstName; private String lastName; private Status status; private List<UserPreference> preferences = new ArrayList<>(); public User() { } public enum Status { ACTIVE, INACTIVE } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public List<UserPreference> getPreferences() { return preferences; } public void setPreferences(List<UserPreference> preferences) { this.preferences = preferences; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } Also, we have to describe the mapper interface, UserMapper interface : package com.zebrunner.carina.demo.db.mappers; import com.zebrunner.carina.demo.db.models.User; public interface UserMapper { void create(User user); User findById(long id); User findByUserName(String username); void update(User user); void delete(User user); } Configuration First of all, we need to place DB credentials into src/main/resources/_database.properties : #===============================================================# #================== Database configuration ====================# #===============================================================# db.url=jdbc:postgresql://localhost:5432/postgres db.driver=org.postgresql.Driver db.user=postgres db.pass=postgres #db.url=jdbc:mysql://localhost:3306/mysql #db.driver=com.mysql.jdbc.Driver #db.user=mysql #db.pass=mysql All the mappers and reference to _database.properties should be specified in src/main/resources/mybatis-config.xml : <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> <configuration> <properties resource=\"_database.properties\" /> <environments default=\"development\"> <environment id=\"development\"> <transactionManager type=\"JDBC\" /> <dataSource type=\"POOLED\"> <property name=\"driver\" value=\"${db.driver}\" /> <property name=\"url\" value=\"${db.url}\" /> <property name=\"username\" value=\"${db.user}\" /> <property name=\"password\" value=\"${db.pass}\" /> </dataSource> </environment> </environments> <mappers> <mapper resource=\"mappers/UserMapper.xml\" /> <mapper resource=\"mappers/UserPreferenceMapper.xml\" /> </mappers> </configuration> Connection factory Connection factory is responsible for MyBatis context initialization and creation of mapper instances, take a look at the sample implementation of ConnectionFactory : package com.zebrunner.carina.demo.utils; import java.io.IOException; import java.io.Reader; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.zebrunner.carina.demo.db.mappers.UserMapper; import com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper; public class ConnectionFactory { private static SqlSessionFactory factory; static { Reader reader = null; try { reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); } catch (IOException e) { throw new RuntimeException(e.getMessage()); } factory = new SqlSessionFactoryBuilder().build(reader); } public static SqlSessionFactory getSqlSessionFactory() { return factory; } public static UserMapper getUserMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserMapper.class); } public static UserPreferenceMapper getUserPreferenceMapperMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserPreferenceMapper.class); } } Usage sample Finally, DBSampleTest illustrates the usage of MyBatis in tests: package com.zebrunner.carina.demo; import static org.testng.Assert.assertEquals; import static org.testng.Assert.assertNull; import com.zebrunner.carina.core.IAbstractTest; import com.zebrunner.agent.core.annotation.TestLabel; import org.apache.ibatis.session.SqlSession; import org.testng.annotations.Test; import com.zebrunner.carina.demo.db.mappers.UserMapper; import com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper; import com.zebrunner.carina.demo.db.models.User; import com.zebrunner.carina.demo.db.models.User.Status; import com.zebrunner.carina.demo.utils.ConnectionFactory; import com.zebrunner.carina.demo.db.models.UserPreference; /** * This sample shows how create DB test. * * @author qpsdemo */ public class DBSampleTest implements IAbstractTest { ... @Test @TestLabel(name = \"feature\", value = \"database\") public void createUser() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } @Test(dependsOnMethods = \"createUser\") @TestLabel(name = \"feature\", value = \"database\") public void createUserPreference() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); UserPreferenceMapper userPreferenceMapper = session.getMapper(UserPreferenceMapper.class); USER_PREFERENCE.setUserId(USER.getId()); userPreferenceMapper.create(USER_PREFERENCE); checkUserPreference(userMapper.findById(USER.getId()).getPreferences().get(0)); } } ... }","title":"Database"},{"location":"advanced/database/#dependencies","text":"For integration with DB, we recommend to use MyBatis ORM framework. MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. To start with, let's add the required dependencies into Maven pom.xml: <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.2</version> </dependency> <!-- Postgres driver --> <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.6</version> </dependency> <!-- MySQL driver --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.17</version> </dependency>","title":"Dependencies"},{"location":"advanced/database/#mappers","text":"The next step is MyBatis mappers implementation, read the official documentation to understand all the details. Let's place all the mappers into src/main/resources/mappers . Here is a UserMapper.xml sample: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> <mapper namespace=\"com.zebrunner.carina.demo.db.mappers.UserMapper\"> <insert id=\"create\" useGeneratedKeys=\"true\" keyProperty=\"id\"> <![CDATA[ INSERT INTO carina.USERS (USERNAME, PASSWORD, FIRST_NAME, LAST_NAME, EMAIL, STATUS) VALUES ( #{username}, #{password}, #{firstName}, #{lastName}, #{email}, #{status} ) ]]> </insert> <sql id=\"getUser\"> <![CDATA[ SELECT U.ID AS USER_ID, U.USERNAME AS USER_USERNAME, U.PASSWORD AS USER_PASSWORD, U.FIRST_NAME AS USER_FIRST_NAME, U.LAST_NAME AS USER_LAST_NAME, U.EMAIL AS USER_EMAIL, U.STATUS AS USER_STATUS, UP.ID AS USER_PREFERENCE_ID, UP.NAME AS USER_PREFERENCE_NAME, UP.VALUE AS USER_PREFERENCE_VALUE, UP.USER_ID AS USER_PREFERENCE_USER_ID FROM carina.USERS U LEFT JOIN carina.USER_PREFERENCES UP ON UP.USER_ID = U.ID ]]> </sql> <select id=\"findById\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.ID = #{id}; ]]> </select> <select id=\"findByUserName\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.USERNAME = #{username}; ]]> </select> <update id=\"update\"> <![CDATA[ UPDATE carina.USERS ]]> <set> <if test=\"null != firstName\"> <![CDATA[ FIRST_NAME = #{firstName}, ]]> </if> <if test=\"null != lastName\"> <![CDATA[ LAST_NAME = #{lastName}, ]]> </if> <if test=\"null != email\"> <![CDATA[ EMAIL = #{email}, ]]> </if> <if test=\"null != username\"> <![CDATA[ USERNAME = #{username}, ]]> </if> <if test=\"null != password\"> <![CDATA[ PASSWORD = #{password}, ]]> </if> </set> <![CDATA[ WHERE ID = #{id} ]]> </update> <delete id=\"delete\"> <![CDATA[ DELETE FROM carina.USERS WHERE ID = #{id} ]]> </delete> <resultMap type=\"com.zebrunner.carina.demo.db.models.User\" id=\"UserResultMap\" autoMapping=\"false\"> <id column=\"USER_ID\" property=\"id\" /> <result column=\"USER_USERNAME\" property=\"username\" /> <result column=\"USER_PASSWORD\" property=\"password\" /> <result column=\"USER_FIRST_NAME\" property=\"firstName\" /> <result column=\"USER_LAST_NAME\" property=\"lastName\" /> <result column=\"USER_EMAIL\" property=\"email\" /> <result column=\"USER_STATUS\" property=\"status\" /> <collection property=\"preferences\" ofType=\"com.zebrunner.carina.demo.db.models.UserPreference\" resultMap=\"com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper.UserPreferenceResultMap\" /> </resultMap> </mapper> Now we have to implement a DB domain object User class which reflects the DB table structure: package com.zebrunner.carina.demo.db.models; import java.util.ArrayList; import java.util.List; public class User { private Long id; private String username; private String password; private String email; private String firstName; private String lastName; private Status status; private List<UserPreference> preferences = new ArrayList<>(); public User() { } public enum Status { ACTIVE, INACTIVE } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public List<UserPreference> getPreferences() { return preferences; } public void setPreferences(List<UserPreference> preferences) { this.preferences = preferences; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } Also, we have to describe the mapper interface, UserMapper interface : package com.zebrunner.carina.demo.db.mappers; import com.zebrunner.carina.demo.db.models.User; public interface UserMapper { void create(User user); User findById(long id); User findByUserName(String username); void update(User user); void delete(User user); }","title":"Mappers"},{"location":"advanced/database/#configuration","text":"First of all, we need to place DB credentials into src/main/resources/_database.properties : #===============================================================# #================== Database configuration ====================# #===============================================================# db.url=jdbc:postgresql://localhost:5432/postgres db.driver=org.postgresql.Driver db.user=postgres db.pass=postgres #db.url=jdbc:mysql://localhost:3306/mysql #db.driver=com.mysql.jdbc.Driver #db.user=mysql #db.pass=mysql All the mappers and reference to _database.properties should be specified in src/main/resources/mybatis-config.xml : <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> <configuration> <properties resource=\"_database.properties\" /> <environments default=\"development\"> <environment id=\"development\"> <transactionManager type=\"JDBC\" /> <dataSource type=\"POOLED\"> <property name=\"driver\" value=\"${db.driver}\" /> <property name=\"url\" value=\"${db.url}\" /> <property name=\"username\" value=\"${db.user}\" /> <property name=\"password\" value=\"${db.pass}\" /> </dataSource> </environment> </environments> <mappers> <mapper resource=\"mappers/UserMapper.xml\" /> <mapper resource=\"mappers/UserPreferenceMapper.xml\" /> </mappers> </configuration>","title":"Configuration"},{"location":"advanced/database/#connection-factory","text":"Connection factory is responsible for MyBatis context initialization and creation of mapper instances, take a look at the sample implementation of ConnectionFactory : package com.zebrunner.carina.demo.utils; import java.io.IOException; import java.io.Reader; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.zebrunner.carina.demo.db.mappers.UserMapper; import com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper; public class ConnectionFactory { private static SqlSessionFactory factory; static { Reader reader = null; try { reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); } catch (IOException e) { throw new RuntimeException(e.getMessage()); } factory = new SqlSessionFactoryBuilder().build(reader); } public static SqlSessionFactory getSqlSessionFactory() { return factory; } public static UserMapper getUserMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserMapper.class); } public static UserPreferenceMapper getUserPreferenceMapperMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserPreferenceMapper.class); } }","title":"Connection factory"},{"location":"advanced/database/#usage-sample","text":"Finally, DBSampleTest illustrates the usage of MyBatis in tests: package com.zebrunner.carina.demo; import static org.testng.Assert.assertEquals; import static org.testng.Assert.assertNull; import com.zebrunner.carina.core.IAbstractTest; import com.zebrunner.agent.core.annotation.TestLabel; import org.apache.ibatis.session.SqlSession; import org.testng.annotations.Test; import com.zebrunner.carina.demo.db.mappers.UserMapper; import com.zebrunner.carina.demo.db.mappers.UserPreferenceMapper; import com.zebrunner.carina.demo.db.models.User; import com.zebrunner.carina.demo.db.models.User.Status; import com.zebrunner.carina.demo.utils.ConnectionFactory; import com.zebrunner.carina.demo.db.models.UserPreference; /** * This sample shows how create DB test. * * @author qpsdemo */ public class DBSampleTest implements IAbstractTest { ... @Test @TestLabel(name = \"feature\", value = \"database\") public void createUser() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } @Test(dependsOnMethods = \"createUser\") @TestLabel(name = \"feature\", value = \"database\") public void createUserPreference() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); UserPreferenceMapper userPreferenceMapper = session.getMapper(UserPreferenceMapper.class); USER_PREFERENCE.setUserId(USER.getId()); userPreferenceMapper.create(USER_PREFERENCE); checkUserPreference(userMapper.findById(USER.getId()).getPreferences().get(0)); } } ... }","title":"Usage sample"},{"location":"advanced/dataprovider/","text":"Modern test automation frameworks should support data-driven testing, when you are able to verify a variety of edge cases providing test data sets into the tests using external data sources. Carina is not an exception, the framework supports multiple ways of test parametrization (see the TestNG approach samples , Carina's custom data provider samples ): Java data providers XML parametrization XLS data providers CSV data providers Java data provider As far as Carina is based on TestNG framework, you are able to use well known Java data providers which return a matrix of Objects and pass it to the appropriate test arguments. You have to use dataProvider attribute along with @Test annotation and implement the method annotated with @DataProvider that will return Object[][] as a test data set: @Test(dataProvider = \"DP1\") public void testMultiplyOperation(int a, int b, int c) { int actual = a * b; int expected = c; Assert.assertEquals(actual, expected, \"Invalid multiply result!\"); } @DataProvider(parallel = false, name = \"DP1\") public static Object[][] dataprovider() { return new Object[][] { { 2, 3, 6 }, { 6, 6, 36 }, { 5, 8, 40 } }; } XML parametrization TestNG supports parametrization from XML files when you organize test suites using XML files. The parameterized test method should be annotated with @Parameters({ \"a\", \"b\", \"c\" }) and appropriate method arguments should be listed. Also, you have to pass all required parameters from an XML suite file: @Test @Parameters({ \"a\", \"b\", \"c\" }) public void testSubtractOperation(int a, int b, int c) { int actual = Integer.valueOf(a) - Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid subtract result!\"); } ... <test name=\"Subtract operation test\"> <parameter name=\"a\" value=\"12\"/> <parameter name=\"b\" value=\"3\"/> <parameter name=\"c\" value=\"9\"/> <classes> <class name=\"com.zebrunner.carina.demo.DataprovidersSampleTest\"> <methods> <include name=\"testSubtractOperation\"/> </methods> </class> </classes> </test> ... Adding test unique identifier (TUID) to the test name using Java data provider TUID sets at the beginning of the test name in a test result report. Prerequisites For this functionality to work, update your maven-compiler-plugin (add --parameters compiler argument) <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> ... <configuration> <compilerArgs> <arg>-parameters</arg> </compilerArgs> </configuration> </plugin> Implementation If you want to add TUID information to the Java data provider, for example @DataProvider(name = \"dataProvider\") public static Object[][] dataprovider() { return new Object[][]{ ... } you should do the following: Add to the data provider field with test unique identifier (TUID), for example: @DataProvider(name = \"DP1\") public static Object[][] dataprovider() { return new Object[][]{ {\"Data1\", \"some data\", ... }, {\"Data2\", \"some data\", ... }, {\"Data3\", \"some data\", ... } }; } where \"Data1\" , \"Data2\" , \"Data3\" in this example is the tests unique identifiers. In the test, that use our provider, for example @Test(dataProvider = \"DP1\") public void testDataProvider(...) { ... } when you receive data from the data provider, you must name the method parameter that receives a TUID as TUID , for example: @Test(dataProvider = \"DP1\") public void testDataProvider(String TUID, String data, ...) { ... } Custom data providers Pre requirements To use custom provider feature, add certain dependency to your pom.xml <dependency> <groupId>com.zebrunner</groupId> <artifactId>carina-dataprovider</artifactId> <version>RELEASE</version> </dependency> Visit our github to check the latest version of carina-dataprovider. Implementation Carina test framework provides a possibility to write all tests with data providers in one place, including parameterization using external XLS/CSV spreadsheets. First of all, you need to declare a test class that implements com.zebrunner.carina.core.IAbstractTest.java and com.zebrunner.carina.dataprovider.IAbstractDataProvider.java . After that, you can specify data provider tests as follows. public class CustomDataProvidersSampleTest implements IAbstractTest, IAbstractDataProvider { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"data_source/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\", dsArgs = \"a,b,c\") public void testXlsSumOperation(String a, String b, String c) { int actual = Integer.valueOf(a) + Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } } This test uses XLS files as a data source. Every line in a spreadsheet is a set of arguments for a test. You should specify the dataProvider parameter for TestNG annotation @Test . IAbstractDataProvider interface defines several data provider methods to implement: use @Test(dataProvider = \"DataProvider\") for common use cases. use @Test(dataProvider = \"SingleDataProvider\") for a single-thread execution. To specify the xls / csv spreadsheets for a test, you should declare @XlsDataSourceParameters / @CsvDataSourceParameters annotation and define its parameters. Common data sources annotation parameters: Parameter Meaning Example path File path located in src/test/resources path = \"data_source/demo.xlsx\" dsUid Defines column name from spreadsheet with unique identifiers dsUid = \"TUID\" dsArgs Defines column names from spreadsheet that should be passed to test by splitting it with ','. dsArgs = \"a,b,c\" staticArgs Defines parameter name from testNG suite which value will be passed in test. This value will be present in every test in data source annoation: staticArgs = \"key\" in suite: <parameter name=\"key\" value=\"arg\"/> testMethodColumn Defines column name which contains values for test name overriding testMethodColumn = \"TestTitle\" executeColumn Defines column name that determines whether to add row to test run or not. Default - 'Execute' executeColumn = \"Records to run\" executeValue Defines value by which tests will be added to test run if it equals to value from executeColumn. Default - 'y' executeValue = \"+\" groupColumn Every row in table being grouped by value from selected groupColumn. Provide arguments to test as List<Map<String, String>> for 1 test groupColumn = \"country\" CsvDataSourceParameters can also contain: Parameter Meaning Example separator Defines column separator for parsing Default - ',' separator = \";\" quote defines the character to use for quoted elements when parsing. Default - '\"' quote = \"\u00a9\" XlsDataSourceParameters can also contain: Parameter Meaning Example sheet Defines sheet to parse sheet = \"calculator\" spreadsheetId Defines spreadsheet's id. Is mutually exclusive with path spreadsheetId = \"abc1234567\" Several parameters from annotation could be overridden in suite. Such parameters: Parameter Meaning Example {ds_file} File path located in src/test/resources <parameter name=\"{ds_args}\" value=\"data_source/demo.xlsx\"/> {excel_ds_sheet} Defines sheet to parse <parameter name=\"{excel_ds_sheet}\" value=\"calculator\"/> {ds_args} Defines column names from spreadsheet that should be passed to test by splitting it with ',' <parameter name=\"{ds_args}\" value=\"a,b,c\"/> {ds_uid} Defines column name from spreadsheet with unique identifiers <parameter name=\"{ds_uid}\" value=\"TUID\"/> {ds_execute_column} Defines column name that determines whether to add row to test run or not. Default - 'Execute' <parameter name=\"{ds_execute_column}\" value=\"Records to run\"/> {ds_execute_value} Defines value by which tests will be added to test run if it equals to value from executeColumn. Default - 'y' <parameter name=\"{ds_execute_value}\" value=\"+\"/> Here you can look at a spreadsheet as a data source example for test: DataProvider with huge number of columns In some cases, we have to provide 10+ columns into a test. In this case, there is one tricky point. Just removing dsArgs parameter will collect all the lines into a single Map object, so you can dynamically get any column in a test using the column name. public class CustomDataProvidersSampleTest implements IAbstractTest, IAbstractDataProvider { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"data_source/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\") public void testSumOperationFromMap(Map<String, String> args) { int actual = Integer.valueOf(args.get(\"a\")) + Integer.valueOf(args.get(\"b\")); int expected = Integer.valueOf(args.get(\"c\")); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } }","title":"DataProvider"},{"location":"advanced/dataprovider/#java-data-provider","text":"As far as Carina is based on TestNG framework, you are able to use well known Java data providers which return a matrix of Objects and pass it to the appropriate test arguments. You have to use dataProvider attribute along with @Test annotation and implement the method annotated with @DataProvider that will return Object[][] as a test data set: @Test(dataProvider = \"DP1\") public void testMultiplyOperation(int a, int b, int c) { int actual = a * b; int expected = c; Assert.assertEquals(actual, expected, \"Invalid multiply result!\"); } @DataProvider(parallel = false, name = \"DP1\") public static Object[][] dataprovider() { return new Object[][] { { 2, 3, 6 }, { 6, 6, 36 }, { 5, 8, 40 } }; }","title":"Java data provider"},{"location":"advanced/dataprovider/#xml-parametrization","text":"TestNG supports parametrization from XML files when you organize test suites using XML files. The parameterized test method should be annotated with @Parameters({ \"a\", \"b\", \"c\" }) and appropriate method arguments should be listed. Also, you have to pass all required parameters from an XML suite file: @Test @Parameters({ \"a\", \"b\", \"c\" }) public void testSubtractOperation(int a, int b, int c) { int actual = Integer.valueOf(a) - Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid subtract result!\"); } ... <test name=\"Subtract operation test\"> <parameter name=\"a\" value=\"12\"/> <parameter name=\"b\" value=\"3\"/> <parameter name=\"c\" value=\"9\"/> <classes> <class name=\"com.zebrunner.carina.demo.DataprovidersSampleTest\"> <methods> <include name=\"testSubtractOperation\"/> </methods> </class> </classes> </test> ...","title":"XML parametrization"},{"location":"advanced/dataprovider/#adding-test-unique-identifier-tuid-to-the-test-name-using-java-data-provider","text":"TUID sets at the beginning of the test name in a test result report.","title":"Adding test unique identifier (TUID) to the test name using Java data provider"},{"location":"advanced/dataprovider/#prerequisites","text":"For this functionality to work, update your maven-compiler-plugin (add --parameters compiler argument) <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> ... <configuration> <compilerArgs> <arg>-parameters</arg> </compilerArgs> </configuration> </plugin>","title":"Prerequisites"},{"location":"advanced/dataprovider/#implementation","text":"If you want to add TUID information to the Java data provider, for example @DataProvider(name = \"dataProvider\") public static Object[][] dataprovider() { return new Object[][]{ ... } you should do the following: Add to the data provider field with test unique identifier (TUID), for example: @DataProvider(name = \"DP1\") public static Object[][] dataprovider() { return new Object[][]{ {\"Data1\", \"some data\", ... }, {\"Data2\", \"some data\", ... }, {\"Data3\", \"some data\", ... } }; } where \"Data1\" , \"Data2\" , \"Data3\" in this example is the tests unique identifiers. In the test, that use our provider, for example @Test(dataProvider = \"DP1\") public void testDataProvider(...) { ... } when you receive data from the data provider, you must name the method parameter that receives a TUID as TUID , for example: @Test(dataProvider = \"DP1\") public void testDataProvider(String TUID, String data, ...) { ... }","title":"Implementation"},{"location":"advanced/dataprovider/#custom-data-providers","text":"","title":"Custom data providers"},{"location":"advanced/dataprovider/#pre-requirements","text":"To use custom provider feature, add certain dependency to your pom.xml <dependency> <groupId>com.zebrunner</groupId> <artifactId>carina-dataprovider</artifactId> <version>RELEASE</version> </dependency> Visit our github to check the latest version of carina-dataprovider.","title":"Pre requirements"},{"location":"advanced/dataprovider/#implementation_1","text":"Carina test framework provides a possibility to write all tests with data providers in one place, including parameterization using external XLS/CSV spreadsheets. First of all, you need to declare a test class that implements com.zebrunner.carina.core.IAbstractTest.java and com.zebrunner.carina.dataprovider.IAbstractDataProvider.java . After that, you can specify data provider tests as follows. public class CustomDataProvidersSampleTest implements IAbstractTest, IAbstractDataProvider { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"data_source/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\", dsArgs = \"a,b,c\") public void testXlsSumOperation(String a, String b, String c) { int actual = Integer.valueOf(a) + Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } } This test uses XLS files as a data source. Every line in a spreadsheet is a set of arguments for a test. You should specify the dataProvider parameter for TestNG annotation @Test . IAbstractDataProvider interface defines several data provider methods to implement: use @Test(dataProvider = \"DataProvider\") for common use cases. use @Test(dataProvider = \"SingleDataProvider\") for a single-thread execution. To specify the xls / csv spreadsheets for a test, you should declare @XlsDataSourceParameters / @CsvDataSourceParameters annotation and define its parameters. Common data sources annotation parameters: Parameter Meaning Example path File path located in src/test/resources path = \"data_source/demo.xlsx\" dsUid Defines column name from spreadsheet with unique identifiers dsUid = \"TUID\" dsArgs Defines column names from spreadsheet that should be passed to test by splitting it with ','. dsArgs = \"a,b,c\" staticArgs Defines parameter name from testNG suite which value will be passed in test. This value will be present in every test in data source annoation: staticArgs = \"key\" in suite: <parameter name=\"key\" value=\"arg\"/> testMethodColumn Defines column name which contains values for test name overriding testMethodColumn = \"TestTitle\" executeColumn Defines column name that determines whether to add row to test run or not. Default - 'Execute' executeColumn = \"Records to run\" executeValue Defines value by which tests will be added to test run if it equals to value from executeColumn. Default - 'y' executeValue = \"+\" groupColumn Every row in table being grouped by value from selected groupColumn. Provide arguments to test as List<Map<String, String>> for 1 test groupColumn = \"country\" CsvDataSourceParameters can also contain: Parameter Meaning Example separator Defines column separator for parsing Default - ',' separator = \";\" quote defines the character to use for quoted elements when parsing. Default - '\"' quote = \"\u00a9\" XlsDataSourceParameters can also contain: Parameter Meaning Example sheet Defines sheet to parse sheet = \"calculator\" spreadsheetId Defines spreadsheet's id. Is mutually exclusive with path spreadsheetId = \"abc1234567\" Several parameters from annotation could be overridden in suite. Such parameters: Parameter Meaning Example {ds_file} File path located in src/test/resources <parameter name=\"{ds_args}\" value=\"data_source/demo.xlsx\"/> {excel_ds_sheet} Defines sheet to parse <parameter name=\"{excel_ds_sheet}\" value=\"calculator\"/> {ds_args} Defines column names from spreadsheet that should be passed to test by splitting it with ',' <parameter name=\"{ds_args}\" value=\"a,b,c\"/> {ds_uid} Defines column name from spreadsheet with unique identifiers <parameter name=\"{ds_uid}\" value=\"TUID\"/> {ds_execute_column} Defines column name that determines whether to add row to test run or not. Default - 'Execute' <parameter name=\"{ds_execute_column}\" value=\"Records to run\"/> {ds_execute_value} Defines value by which tests will be added to test run if it equals to value from executeColumn. Default - 'y' <parameter name=\"{ds_execute_value}\" value=\"+\"/> Here you can look at a spreadsheet as a data source example for test:","title":"Implementation"},{"location":"advanced/dataprovider/#dataprovider-with-huge-number-of-columns","text":"In some cases, we have to provide 10+ columns into a test. In this case, there is one tricky point. Just removing dsArgs parameter will collect all the lines into a single Map object, so you can dynamically get any column in a test using the column name. public class CustomDataProvidersSampleTest implements IAbstractTest, IAbstractDataProvider { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"data_source/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\") public void testSumOperationFromMap(Map<String, String> args) { int actual = Integer.valueOf(args.get(\"a\")) + Integer.valueOf(args.get(\"b\")); int expected = Integer.valueOf(args.get(\"c\")); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } }","title":"DataProvider with huge number of columns"},{"location":"advanced/driver/","text":"All the described methods are implemented inside IDriverPool interface and accessible by default from any test class. To access this functionality from another places like your services, just implement this interface. Each thread has their own named driver pool Supported Browsers: Chrome, Firefox, Microsoft Edge, Opera, Safari, etc. Initialization getDriver() is the core method to start any Selenium/Appium session. It will create a RemoteWebDriver named \"default\" based on the default capabilities from configuration. 1st call of the method in the current thread should starta new driver. Next calls will return existing object. getDriver(String name) start named driver session using default capabilities from configuration. This allows to start several drivers (up to 3 according to max_driver_count property). getDriver(String name, MutableCapabilities capabilities) start named driver session using custom capabilities. getDriver(String name, MutableCapabilities capabilities, String seleniumHost) start named driver session using custom capabilities vs custom selenium URL. Example: @Test public void carinaCapsTest() { // Chrome default capabilities builder usage: WebDriver chromeDriver = getDriver(\"chrome\", new ChromeCapabilities().getCapability(\"Chrome Browser\")); HomePage homePageChrome = new HomePage(chromeDriver); homePageChrome.open(); // Firefox default capabilities builder usage: getDriver(\"firefox\", new FirefoxCapabilities().getCapability(\"Firefox Browser\")); HomePage homePageFirefox = new HomePage(getDriver(\"firefox\")); // return named \"firefox\" driver from the pool to init HomePage. homePageFirefox.open(); // Safari, Edge and Opera default capabilities builder usage: HomePage homePageSafari = new HomePage(getDriver(\"safari\", new SafariCapabilities().getCapability(\"Safari Browser\"))); homePageSafari.open(); getDriver(\"edge\", new EdgeCapabilities().getCapability(\"Edge Browser\")); getDriver(\"opera\", new OperaCapabilities().getCapability(\"Opera Browser\")); } @Test public void mutableCapsTest() { // Manage MutableCapabilities on your own to build complicated caps structure: MutableCapabilities capabilities = new MutableCapabilities(); capabilities.setCapability(CapabilityType.BROWSER_NAME, Browser.SAFARI.browserName()); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); HomePage safariHomePage = new HomePage(getDriver(\"safari\", capabilities)); safariHomePage.open(); Assert.assertTrue(safariHomePage.isPageOpened()); } Capabilities Capabilities can be specified in several ways. 1) Specifying capabilities via _config.properties . Capabilities in the properties will be those parameters that have capabilities. added to the name first, for example capabilities.platformName=Android . 1.1) Standard capabilities (listed here ) should be specified as follows: # The delimiter can be both the = symbol and the : symbol, but the first style is preferable. capabilities.browserName=chrome capabilities.browserVersion=100.0 capabilities.platformName=mac 1.2) Capabilities that are not included in the standard ones. Such capabilities can be specified in two ways - with a prefix and nested. 1.2.1) Capabilities with prefix. Example: # Appium capabilities capabilities.appium\\:automationName=uiautomator2 capabilities.appium\\:noReset=true capabilities.appium\\:fullReset=true capabilities.appium\\:app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk However, it is not recommended to add an appium: prefix for Appium capabilities in the configuration file, as Appium drivers able to add it themselves. 1.2.2) Nested capabilities. Example: capabilities.zebrunner\\:options.enableVideo=true capabilities.zebrunner\\:options.enableLog=true The final form of these capabilities as a result of processing: { ... zebrunner:options { enableVideo=true, enableLog=true } ... } 2) Specifying via the auxiliary properties file 2.1) The most popular capabilities sets can be declared in properties files and reused via custom_capabilities configuration parameter. It can be convenient for external hub providers like Zebrunner Device Farm, BrowserStack, Sauce Labs, etc. Collect device/browser specific capabilities and put into src/main/resources/browserstack-iphone_12.properties : capabilities.platformName=ios capabilities.deviceName=iPhone 14 Pro Max capabilities.platformVersion=16 capabilities.app=bs://444bd0308813ae0dc236f8cd461c02d3afa7901d capabilities.bstack\\:options.local[string]=false capabilities.bstack\\:options.appiumVersion[string]=2.0.0 capabilities.bstack\\:options.deviceOrientation=landscape Put custom_capabilities=browserstack-iphone_12.properties into the _config.properties to start all tests on this device. 2.2) Also you can create the same properties file as described in paragraph 2.1, but add its capabilities using the loadCapabilities method of the com.zebrunner.carina.webdriver.core.capability.CapabilitiesLoader class. 3) Using the put method of the R.CONFIG class. You can specify not only capabilities, but also parameters, for example: ... R.CONFIG.put(\"capabilities.browserName\", \"chrome\"); R.CONFIG.put(\"capabilities.browserName\", \"firefox\", true); ... 4) Static Capabilities (Only when testing desktop browsers). You can specify capabilities that will apply to all sessions, using the addStaticCapability method of the com.zebrunner.carina.webdriver.core.factory.impl.DesktopFactory class. For paragraphs 1, 2, 3: Sometimes you need to explicitly specify the type of the capability value. When processing capabilities, their final type is determined based on the value (if we can parse as a number then it will be number, if as boolean then boolean, if not then string). However, there are situations when it is necessary to explicitly specify the type of the value, for example, the value is a number, but we want the resulting value to be a string. For example: # We want to explicitly specify the String type for the idleTimeout value capabilities.zebrunner\\:options.idleTimeout[String]=100 capabilities.browserVersion[string]=100.0 Available explicit casting options - [string] , [boolean] , [integer] . Visit these resources to see all capabilities: Selenium Appium - XCUITest Appium - UiAutomator2 Appium - Espresso Appium - Gecko Appium - Safari Appium - Windows You can also look at outdated list of capabilities: Selenium Appium Options Options and arguments can be provided through _config.properties using comma-separated values for multiple options/args, for example: firefox_args=--no-first-run,--disable-notifications firefox_preferences= chrome_args= chrome_experimental_opts= chrome_mobile_emulation_opts= To provide complicated structures, use the advanced approach to build capabilities/options/arguments: public void someTest() { FirefoxOptions options = new FirefoxOptions(); options.addArguments(\"--no-first-run\"); options.addArguments(\"--disable-notifications\"); options.setPlatformName(SpecialKeywords.MAC); HomePage homePage = new HomePage(getDriver(\"firefox\", options)); homePage.open(); Assert.assertTrue(homePage.isPageOpened()); } Quit Quit driver operation is executed automatically based on the driver init phase, i.e. no need to do it inside your test code . @BeforeSuite drivers belong to all tests/classes and will be closed at @AfterSuite only @BeforeTest drivers belong to all <test> classes and will be closed at @AfterTest . @BeforeClass drivers belong to all tests inside current class and will be closed at @AfterClass @BeforeMethod or inside Test Method drivers belong to current test method and will be closed at @AfterMethod For dependent test methods Carina preserve started driver(s) by default. To quit driver forcibly, use quitDriver() or quitDriver(name) To disable driver quit strategy completely and cotrol drivers init/quit on your own, provide forcibly_disable_driver_quit=true or execute from any place of your test code CarinaListener.disableDriversCleanup(); Restart restartDriver() quit the current driver and start a new one with the same capabilities restartDriver(boolean isSameDevice) quit the current driver and start a new one on the same device using uuid capability. It is fully compatible with MCloud farm. FAQ Where is a valid place to init drivers and pages? Init pages and drivers inside test methods where they are actually used. Escape declaring pages and drivers on the class level as it produces extra complexity in execution, maintenance and support! public class TestSample implements IAbstractTest { @Test(){ public void someTest(){ //Page declared and initialized right before using it HomePage homePage = new HomePage(getDriver()); homePage.open(); FooterMenu footerMenu = homePage.getFooterMenu(); CompareModelsPage comparePage = footerMenu.openComparePage(); List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } } Anti-pattern: public class TestSample implements IAbstractTest { HomePage homePage = new HomePage(driver); WebDriver driver; FooterMenu footerMenu; @BeforeSuite public void driverInit(){ driver = getDriver(); } @Test(){ public void someTest(){ homePage.open(); footerMenu = homePage.getFooterMenu(); CompareModelsPage comparePage = footerMenu.openComparePage(); List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } } May I init page/driver on static layer? Initialization of drivers and pages on the static layer is prohibited. CarinaListener cannot be even integrated at the compilation stage. For details, please visit #1550 . The earliest stage you can start driver is @BeforeSuite() . How to start different tests on different devices? Start driver with custom MutableCapabilities to launch on different devices. Also, you can use CapabilitiesLoader to manage capabilities at run-time: // Update default capabilities globally to start future drivers **for all tests** on iPhone_12 new CapabilitiesLoader().loadCapabilities(\"browserstack-iphone_12.properties\"); // Update default capabilities to start future drivers **for this test only** on iPhone_12 new CapabilitiesLoader().loadCapabilities(\"browserstack-iphone_12.properties\", true); // start new driver with generated capabilities from properties file: WebDriver drv = getDriver(\"iPhone12\", new CapabilitiesLoader().getCapabilities(\"browserstack-iphone_12.properties\"))","title":"Driver"},{"location":"advanced/driver/#initialization","text":"getDriver() is the core method to start any Selenium/Appium session. It will create a RemoteWebDriver named \"default\" based on the default capabilities from configuration. 1st call of the method in the current thread should starta new driver. Next calls will return existing object. getDriver(String name) start named driver session using default capabilities from configuration. This allows to start several drivers (up to 3 according to max_driver_count property). getDriver(String name, MutableCapabilities capabilities) start named driver session using custom capabilities. getDriver(String name, MutableCapabilities capabilities, String seleniumHost) start named driver session using custom capabilities vs custom selenium URL. Example: @Test public void carinaCapsTest() { // Chrome default capabilities builder usage: WebDriver chromeDriver = getDriver(\"chrome\", new ChromeCapabilities().getCapability(\"Chrome Browser\")); HomePage homePageChrome = new HomePage(chromeDriver); homePageChrome.open(); // Firefox default capabilities builder usage: getDriver(\"firefox\", new FirefoxCapabilities().getCapability(\"Firefox Browser\")); HomePage homePageFirefox = new HomePage(getDriver(\"firefox\")); // return named \"firefox\" driver from the pool to init HomePage. homePageFirefox.open(); // Safari, Edge and Opera default capabilities builder usage: HomePage homePageSafari = new HomePage(getDriver(\"safari\", new SafariCapabilities().getCapability(\"Safari Browser\"))); homePageSafari.open(); getDriver(\"edge\", new EdgeCapabilities().getCapability(\"Edge Browser\")); getDriver(\"opera\", new OperaCapabilities().getCapability(\"Opera Browser\")); } @Test public void mutableCapsTest() { // Manage MutableCapabilities on your own to build complicated caps structure: MutableCapabilities capabilities = new MutableCapabilities(); capabilities.setCapability(CapabilityType.BROWSER_NAME, Browser.SAFARI.browserName()); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); HomePage safariHomePage = new HomePage(getDriver(\"safari\", capabilities)); safariHomePage.open(); Assert.assertTrue(safariHomePage.isPageOpened()); }","title":"Initialization"},{"location":"advanced/driver/#capabilities","text":"Capabilities can be specified in several ways. 1) Specifying capabilities via _config.properties . Capabilities in the properties will be those parameters that have capabilities. added to the name first, for example capabilities.platformName=Android . 1.1) Standard capabilities (listed here ) should be specified as follows: # The delimiter can be both the = symbol and the : symbol, but the first style is preferable. capabilities.browserName=chrome capabilities.browserVersion=100.0 capabilities.platformName=mac 1.2) Capabilities that are not included in the standard ones. Such capabilities can be specified in two ways - with a prefix and nested. 1.2.1) Capabilities with prefix. Example: # Appium capabilities capabilities.appium\\:automationName=uiautomator2 capabilities.appium\\:noReset=true capabilities.appium\\:fullReset=true capabilities.appium\\:app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk However, it is not recommended to add an appium: prefix for Appium capabilities in the configuration file, as Appium drivers able to add it themselves. 1.2.2) Nested capabilities. Example: capabilities.zebrunner\\:options.enableVideo=true capabilities.zebrunner\\:options.enableLog=true The final form of these capabilities as a result of processing: { ... zebrunner:options { enableVideo=true, enableLog=true } ... } 2) Specifying via the auxiliary properties file 2.1) The most popular capabilities sets can be declared in properties files and reused via custom_capabilities configuration parameter. It can be convenient for external hub providers like Zebrunner Device Farm, BrowserStack, Sauce Labs, etc. Collect device/browser specific capabilities and put into src/main/resources/browserstack-iphone_12.properties : capabilities.platformName=ios capabilities.deviceName=iPhone 14 Pro Max capabilities.platformVersion=16 capabilities.app=bs://444bd0308813ae0dc236f8cd461c02d3afa7901d capabilities.bstack\\:options.local[string]=false capabilities.bstack\\:options.appiumVersion[string]=2.0.0 capabilities.bstack\\:options.deviceOrientation=landscape Put custom_capabilities=browserstack-iphone_12.properties into the _config.properties to start all tests on this device. 2.2) Also you can create the same properties file as described in paragraph 2.1, but add its capabilities using the loadCapabilities method of the com.zebrunner.carina.webdriver.core.capability.CapabilitiesLoader class. 3) Using the put method of the R.CONFIG class. You can specify not only capabilities, but also parameters, for example: ... R.CONFIG.put(\"capabilities.browserName\", \"chrome\"); R.CONFIG.put(\"capabilities.browserName\", \"firefox\", true); ... 4) Static Capabilities (Only when testing desktop browsers). You can specify capabilities that will apply to all sessions, using the addStaticCapability method of the com.zebrunner.carina.webdriver.core.factory.impl.DesktopFactory class. For paragraphs 1, 2, 3: Sometimes you need to explicitly specify the type of the capability value. When processing capabilities, their final type is determined based on the value (if we can parse as a number then it will be number, if as boolean then boolean, if not then string). However, there are situations when it is necessary to explicitly specify the type of the value, for example, the value is a number, but we want the resulting value to be a string. For example: # We want to explicitly specify the String type for the idleTimeout value capabilities.zebrunner\\:options.idleTimeout[String]=100 capabilities.browserVersion[string]=100.0 Available explicit casting options - [string] , [boolean] , [integer] . Visit these resources to see all capabilities: Selenium Appium - XCUITest Appium - UiAutomator2 Appium - Espresso Appium - Gecko Appium - Safari Appium - Windows You can also look at outdated list of capabilities: Selenium Appium","title":"Capabilities"},{"location":"advanced/driver/#options","text":"Options and arguments can be provided through _config.properties using comma-separated values for multiple options/args, for example: firefox_args=--no-first-run,--disable-notifications firefox_preferences= chrome_args= chrome_experimental_opts= chrome_mobile_emulation_opts= To provide complicated structures, use the advanced approach to build capabilities/options/arguments: public void someTest() { FirefoxOptions options = new FirefoxOptions(); options.addArguments(\"--no-first-run\"); options.addArguments(\"--disable-notifications\"); options.setPlatformName(SpecialKeywords.MAC); HomePage homePage = new HomePage(getDriver(\"firefox\", options)); homePage.open(); Assert.assertTrue(homePage.isPageOpened()); }","title":"Options"},{"location":"advanced/driver/#quit","text":"Quit driver operation is executed automatically based on the driver init phase, i.e. no need to do it inside your test code . @BeforeSuite drivers belong to all tests/classes and will be closed at @AfterSuite only @BeforeTest drivers belong to all <test> classes and will be closed at @AfterTest . @BeforeClass drivers belong to all tests inside current class and will be closed at @AfterClass @BeforeMethod or inside Test Method drivers belong to current test method and will be closed at @AfterMethod For dependent test methods Carina preserve started driver(s) by default. To quit driver forcibly, use quitDriver() or quitDriver(name) To disable driver quit strategy completely and cotrol drivers init/quit on your own, provide forcibly_disable_driver_quit=true or execute from any place of your test code CarinaListener.disableDriversCleanup();","title":"Quit"},{"location":"advanced/driver/#restart","text":"restartDriver() quit the current driver and start a new one with the same capabilities restartDriver(boolean isSameDevice) quit the current driver and start a new one on the same device using uuid capability. It is fully compatible with MCloud farm.","title":"Restart"},{"location":"advanced/driver/#faq","text":"Where is a valid place to init drivers and pages? Init pages and drivers inside test methods where they are actually used. Escape declaring pages and drivers on the class level as it produces extra complexity in execution, maintenance and support! public class TestSample implements IAbstractTest { @Test(){ public void someTest(){ //Page declared and initialized right before using it HomePage homePage = new HomePage(getDriver()); homePage.open(); FooterMenu footerMenu = homePage.getFooterMenu(); CompareModelsPage comparePage = footerMenu.openComparePage(); List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } } Anti-pattern: public class TestSample implements IAbstractTest { HomePage homePage = new HomePage(driver); WebDriver driver; FooterMenu footerMenu; @BeforeSuite public void driverInit(){ driver = getDriver(); } @Test(){ public void someTest(){ homePage.open(); footerMenu = homePage.getFooterMenu(); CompareModelsPage comparePage = footerMenu.openComparePage(); List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } } May I init page/driver on static layer? Initialization of drivers and pages on the static layer is prohibited. CarinaListener cannot be even integrated at the compilation stage. For details, please visit #1550 . The earliest stage you can start driver is @BeforeSuite() . How to start different tests on different devices? Start driver with custom MutableCapabilities to launch on different devices. Also, you can use CapabilitiesLoader to manage capabilities at run-time: // Update default capabilities globally to start future drivers **for all tests** on iPhone_12 new CapabilitiesLoader().loadCapabilities(\"browserstack-iphone_12.properties\"); // Update default capabilities to start future drivers **for this test only** on iPhone_12 new CapabilitiesLoader().loadCapabilities(\"browserstack-iphone_12.properties\", true); // start new driver with generated capabilities from properties file: WebDriver drv = getDriver(\"iPhone12\", new CapabilitiesLoader().getCapabilities(\"browserstack-iphone_12.properties\"))","title":"FAQ"},{"location":"advanced/localization/","text":"There is an enhanced L10N utility to support localized (L10N) test automation testing. It can load localized resources on the fly and verify texts if needed. We recommend to use existing localized resources and don't generate them by automation team! Prerequisites Localized resources should be located in src/main/resources/L10N folder. Each localized resource file has unique keys with translated values. Verify that there is a must have file without any postfix like locale.properties . This file will be considered as a default localization. Implementation Define parameters in _config.properties . #Localization language locale=de_DE #Optionally you could operate browser locale as well by using browser_language=en_US #Enables auto verification for elements, that are marked with @Localized (by default it's false) localization_testing=true #Encoding for a new localization (by default UTF-8) localization_encoding=UTF-8 Then declare page elements with @Localized annotation. For example: @Localized @FindBy(id = \"pt-createaccount\") private ExtendedWebElement createAccountElem; @Localized @FindBy(id = \"pt-anoncontribs\") private ExtendedWebElement contribElem; @Localized @FindBy(xpath = \"//nav[@id='p-navigation']/descendant::ul[@class='vector-menu-content-list']/*\") private List<ExtendedWebElement> pageLinks; Add to the project resources that corresponds to @Localized elements: #!The key from locale file should have Page name + name of variable that needs to be compared. WikipediaLocalePage.createAccountElem=fi\u00f3k l\u00e9trehoz\u00e1sa WikipediaLocalePage.contribElem=k\u00f6zrem\u0171k\u00f6d\u00e9sek #!Elements from List should have the same name of a variable + current element's number WikipediaLocalePage.pageLinks0=Kezd\u0151lap WikipediaLocalePage.pageLinks1=Tartalom WikipediaLocalePage.pageLinks2=Kiemelt sz\u00f3cikkek WikipediaLocalePage.pageLinks3=Friss v\u00e1ltoztat\u00e1sok WikipediaLocalePage.pageLinks4=Lap tal\u00e1lomra WikipediaLocalePage.pageLinks5=Tudakoz\u00f3 For elements that are operated in test and marked with @Localized annotation Carina will automatically compare text from the page with text from your locale_xx_XX.properties file. Every mismatch will be collected in L10N class. To assert collected assertions use L10N.assertAll() method. If you want to do it manually use L10N.getText(key) to get expected translations from resources: String welcomeText = wikipediaLocalePage.getWelcomeText(); String expectedWelcomeText = L10N.getText(\"welcomeText\"); Assert.assertEquals(welcomeText, expectedWelcomeText.trim(), \"Wikipedia welcome text was not the expected.\"); Resources generation To generate resources with Carina, you need to enable localization_testing parameter.For elements that are need localization, you need to mark them with @Localized and operate with them. In test call L10N.flush() to create new locale file in your project directory. Example: public void testAddNewLanguages() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); wikipediaLocalePage.hoverWelcomeText(); wikipediaLocalePage.hoverContribElem(); wikipediaLocalePage.hoverCreateAccountElem(); wikipediaLocalePage.hoverHeaders(); wikipediaLocalePage.clickDiscussionBtn(); L10N.flush(); L10N.assertAll(); // not necessary for resources generation } Finding elements with a help of locales Declare elements with L10N prefix where needed. Use key after the \":\" sign in @FindBy annotations which will be replaced by actual localized translations. @FindBy(xpath = \"//*[text()='{L10N:welcomeText}'\") private ExtendedWebElement welcomeText; @FindBy(linkText = \"{L10N:discussionElem}\") private ExtendedWebElement discussionBtn; At runtime actual translations will be used to locate elements xpath = \"//*[text()='{L10N:HomePage.welcomeText}'\" # actual value at run-time: xpath = \"//*[text()='Willkommen bei Wikipedia'\" Creation of multi-language tests If one or a group of tests checks several language versions of the site, then you need to do the following: 1. [Optional] if you need to change the language version of the site, you can overwrite the locale parameter: # overwrites locale value with de_DE for this test only R.CONFIG.put(\"locale\", \"de_DE\", true); Call the setLocale function and pass the locale to it: # overwrites the default locale in the file to 'de_DE' L10N.setLocale(\"de_DE\") Call the load function to download the localized resource of the current locale: L10N.load(); When you need to get a list of locale errors, call assertAll: L10N.assertAll();","title":"Localization"},{"location":"advanced/localization/#prerequisites","text":"Localized resources should be located in src/main/resources/L10N folder. Each localized resource file has unique keys with translated values. Verify that there is a must have file without any postfix like locale.properties . This file will be considered as a default localization.","title":"Prerequisites"},{"location":"advanced/localization/#implementation","text":"Define parameters in _config.properties . #Localization language locale=de_DE #Optionally you could operate browser locale as well by using browser_language=en_US #Enables auto verification for elements, that are marked with @Localized (by default it's false) localization_testing=true #Encoding for a new localization (by default UTF-8) localization_encoding=UTF-8 Then declare page elements with @Localized annotation. For example: @Localized @FindBy(id = \"pt-createaccount\") private ExtendedWebElement createAccountElem; @Localized @FindBy(id = \"pt-anoncontribs\") private ExtendedWebElement contribElem; @Localized @FindBy(xpath = \"//nav[@id='p-navigation']/descendant::ul[@class='vector-menu-content-list']/*\") private List<ExtendedWebElement> pageLinks; Add to the project resources that corresponds to @Localized elements: #!The key from locale file should have Page name + name of variable that needs to be compared. WikipediaLocalePage.createAccountElem=fi\u00f3k l\u00e9trehoz\u00e1sa WikipediaLocalePage.contribElem=k\u00f6zrem\u0171k\u00f6d\u00e9sek #!Elements from List should have the same name of a variable + current element's number WikipediaLocalePage.pageLinks0=Kezd\u0151lap WikipediaLocalePage.pageLinks1=Tartalom WikipediaLocalePage.pageLinks2=Kiemelt sz\u00f3cikkek WikipediaLocalePage.pageLinks3=Friss v\u00e1ltoztat\u00e1sok WikipediaLocalePage.pageLinks4=Lap tal\u00e1lomra WikipediaLocalePage.pageLinks5=Tudakoz\u00f3 For elements that are operated in test and marked with @Localized annotation Carina will automatically compare text from the page with text from your locale_xx_XX.properties file. Every mismatch will be collected in L10N class. To assert collected assertions use L10N.assertAll() method. If you want to do it manually use L10N.getText(key) to get expected translations from resources: String welcomeText = wikipediaLocalePage.getWelcomeText(); String expectedWelcomeText = L10N.getText(\"welcomeText\"); Assert.assertEquals(welcomeText, expectedWelcomeText.trim(), \"Wikipedia welcome text was not the expected.\");","title":"Implementation"},{"location":"advanced/localization/#resources-generation","text":"To generate resources with Carina, you need to enable localization_testing parameter.For elements that are need localization, you need to mark them with @Localized and operate with them. In test call L10N.flush() to create new locale file in your project directory. Example: public void testAddNewLanguages() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); wikipediaLocalePage.hoverWelcomeText(); wikipediaLocalePage.hoverContribElem(); wikipediaLocalePage.hoverCreateAccountElem(); wikipediaLocalePage.hoverHeaders(); wikipediaLocalePage.clickDiscussionBtn(); L10N.flush(); L10N.assertAll(); // not necessary for resources generation }","title":"Resources generation"},{"location":"advanced/localization/#finding-elements-with-a-help-of-locales","text":"Declare elements with L10N prefix where needed. Use key after the \":\" sign in @FindBy annotations which will be replaced by actual localized translations. @FindBy(xpath = \"//*[text()='{L10N:welcomeText}'\") private ExtendedWebElement welcomeText; @FindBy(linkText = \"{L10N:discussionElem}\") private ExtendedWebElement discussionBtn; At runtime actual translations will be used to locate elements xpath = \"//*[text()='{L10N:HomePage.welcomeText}'\" # actual value at run-time: xpath = \"//*[text()='Willkommen bei Wikipedia'\"","title":"Finding elements with a help of locales"},{"location":"advanced/localization/#creation-of-multi-language-tests","text":"If one or a group of tests checks several language versions of the site, then you need to do the following: 1. [Optional] if you need to change the language version of the site, you can overwrite the locale parameter: # overwrites locale value with de_DE for this test only R.CONFIG.put(\"locale\", \"de_DE\", true); Call the setLocale function and pass the locale to it: # overwrites the default locale in the file to 'de_DE' L10N.setLocale(\"de_DE\") Call the load function to download the localized resource of the current locale: L10N.load(); When you need to get a list of locale errors, call assertAll: L10N.assertAll();","title":"Creation of multi-language tests"},{"location":"advanced/mobile/","text":"Run one test on android and ios in parallel To run tests on multiple devices, including different platforms, you can use a data provider. For example, you can create a data provider like: @DataProvider(parallel = true, name = \"capabilitiesDataProvider\") public static Object[][] capabilitiesDataProvider() { return new Object[][] { { \"Samsung Galaxy M52 5G\", \"Android\", \"https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk\" }, { \"iPhone 8 Plus\", \"iOS\", \"https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip\" } }; } and the test that this data provider uses: @Test(dataProvider = \"capabilitiesDataProvider\") public void testLoginUser(String deviceName, String platformName, String app) { R.CONFIG.put(\"capabilities.deviceName\", deviceName, true); R.CONFIG.put(\"capabilities.platformName\", platformName, true); R.CONFIG.put(\"capabilities.app\", app, true); WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); Assert.assertTrue(welcomePage.isPageOpened(), \"Welcome page isn't opened\"); ... } Thus, you can throw up any capability, capabilities will also be taken from the config file. In the TestNG xml suite file, do not forget to specify the number of parallel streams for the data provider data-provider-thread-count , for example: <suite name=\"Carina Demo Tests - Mobile Sample (Android)\" verbose=\"1\" parallel=\"methods\" data-provider-thread-count=\"5\"> Recommended capability to minimize INSTALL_FAILED_INSUFFICIENT_STORAGE exception This exception may appear due to multiple app reinstalls on the Android device. You need to add remoteAppsCacheLimit capability with value 0 for all Android testing to disable caching mechanism. This capability was delivered as part of original CE codeline . Explanation and original google feedback about INSTALL_FAILED_INSUFFICIENT_STORAGE exception might be found here . Run tests on tvOS, AndroidTV Run tests on tvOS To run tests for tvOS , set the capability value of platformName to tvOS in _config.properties , for example: capabilities.platformName=tvOS #here capabilities.platformVersion=12.2 capabilities.deviceName=Apple TV capabilities.deviceType=tv # carina custom capability .. } TvOS provides remote controller based actions. Appium provides Buttons actions via mobile: pressButton. These are menu, up/down/left/right, home, playpause and select. You can emulate these actions like this: JavascriptExecutor driver = (JavascriptExecutor)getDriver(); Map<String, String> commandHomeAttributes = ImmutableMap.of(\"name\", \"Home\")); driver.executeScript(\"mobile: pressButton\", commandHomeAttributes); Map<String, String> commandUpAttributes = ImmutableMap.of(\"name\", \"Home\")); driver.executeScript(\"mobile: pressButton\", commandUpAttributes); Also, to emulate transitions between elements, you can use a simple click on the element you are looking for. For more info visit tvOS appium support . In the implementation of tests, the idea is the same as in mobile-testing . Run tests on AndroidTV To get started, enable developer options . To connect to a device, you need to know at least the Device Name, Platform Name, and Platform Version. You specify this data as a capabilities in _config.properties , for example: capabilities.platformName=Android capabilities.platformVersion=11 capabilities.deviceName=Redmi TV capabilities.deviceType=tv # carina custom capability ... When testing, you will simulate pressing buttons from the remote control. To do this, you can use the pressKeyboardKey method from IAndroidUtils with key event parameters AndroidKey.DPAD_UP , AndroidKey.DPAD_DOWN , AndroidKey.DPAD_LEFT , AndroidKey.DPAD_RIGHT , AndroidKey.DPAD_CENTER and other. For more info see TV UI events . In the implementation of tests, the idea is the same as in mobile-testing .","title":"Mobile"},{"location":"advanced/mobile/#run-one-test-on-android-and-ios-in-parallel","text":"To run tests on multiple devices, including different platforms, you can use a data provider. For example, you can create a data provider like: @DataProvider(parallel = true, name = \"capabilitiesDataProvider\") public static Object[][] capabilitiesDataProvider() { return new Object[][] { { \"Samsung Galaxy M52 5G\", \"Android\", \"https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk\" }, { \"iPhone 8 Plus\", \"iOS\", \"https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip\" } }; } and the test that this data provider uses: @Test(dataProvider = \"capabilitiesDataProvider\") public void testLoginUser(String deviceName, String platformName, String app) { R.CONFIG.put(\"capabilities.deviceName\", deviceName, true); R.CONFIG.put(\"capabilities.platformName\", platformName, true); R.CONFIG.put(\"capabilities.app\", app, true); WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); Assert.assertTrue(welcomePage.isPageOpened(), \"Welcome page isn't opened\"); ... } Thus, you can throw up any capability, capabilities will also be taken from the config file. In the TestNG xml suite file, do not forget to specify the number of parallel streams for the data provider data-provider-thread-count , for example: <suite name=\"Carina Demo Tests - Mobile Sample (Android)\" verbose=\"1\" parallel=\"methods\" data-provider-thread-count=\"5\">","title":"Run one test on android and ios in parallel"},{"location":"advanced/mobile/#recommended-capability-to-minimize-install_failed_insufficient_storage-exception","text":"This exception may appear due to multiple app reinstalls on the Android device. You need to add remoteAppsCacheLimit capability with value 0 for all Android testing to disable caching mechanism. This capability was delivered as part of original CE codeline . Explanation and original google feedback about INSTALL_FAILED_INSUFFICIENT_STORAGE exception might be found here .","title":"Recommended capability to minimize INSTALL_FAILED_INSUFFICIENT_STORAGE exception"},{"location":"advanced/mobile/#run-tests-on-tvos-androidtv","text":"","title":"Run tests on tvOS, AndroidTV"},{"location":"advanced/mobile/#run-tests-on-tvos","text":"To run tests for tvOS , set the capability value of platformName to tvOS in _config.properties , for example: capabilities.platformName=tvOS #here capabilities.platformVersion=12.2 capabilities.deviceName=Apple TV capabilities.deviceType=tv # carina custom capability .. } TvOS provides remote controller based actions. Appium provides Buttons actions via mobile: pressButton. These are menu, up/down/left/right, home, playpause and select. You can emulate these actions like this: JavascriptExecutor driver = (JavascriptExecutor)getDriver(); Map<String, String> commandHomeAttributes = ImmutableMap.of(\"name\", \"Home\")); driver.executeScript(\"mobile: pressButton\", commandHomeAttributes); Map<String, String> commandUpAttributes = ImmutableMap.of(\"name\", \"Home\")); driver.executeScript(\"mobile: pressButton\", commandUpAttributes); Also, to emulate transitions between elements, you can use a simple click on the element you are looking for. For more info visit tvOS appium support . In the implementation of tests, the idea is the same as in mobile-testing .","title":"Run tests on tvOS"},{"location":"advanced/mobile/#run-tests-on-androidtv","text":"To get started, enable developer options . To connect to a device, you need to know at least the Device Name, Platform Name, and Platform Version. You specify this data as a capabilities in _config.properties , for example: capabilities.platformName=Android capabilities.platformVersion=11 capabilities.deviceName=Redmi TV capabilities.deviceType=tv # carina custom capability ... When testing, you will simulate pressing buttons from the remote control. To do this, you can use the pressKeyboardKey method from IAndroidUtils with key event parameters AndroidKey.DPAD_UP , AndroidKey.DPAD_DOWN , AndroidKey.DPAD_LEFT , AndroidKey.DPAD_RIGHT , AndroidKey.DPAD_CENTER and other. For more info see TV UI events . In the implementation of tests, the idea is the same as in mobile-testing .","title":"Run tests on AndroidTV"},{"location":"advanced/program_flow/","text":"Under the hood, Carina uses TestNG framework, so the first class to initialize is RemoteTestNGStarter class. Program lifecycle logic can be observed at TestNG run() method. The initializing turn comes to Carina when CarinaListenerChain object is created. It extends ListenerChain which will create, sort and attach IAbstractTest listeners CarinaListener.class, TestRunListener.class, FilterTestsListener.class . This whole sequence is described in TestRunner init() method. These listeners are being attached and created when transform(IListenersAnnotation annotation, Class testClass) method is called. FilterTestsListener which is resposible for tests execution rules TestRunListener which is implemented in the Zebrunner agent. CarinaListener which is the main Carina TestNG listener. Because CarinaListener object is created, the class static field is initialized in it. There are several important steps inside: R.reinit(). This method loads default values for all parameters from carina-core , then overrides them with user's configurations (_api.properties, _config.properties, _testdata.properties, _email.properties, _report.properties, _database.properties). Configure log4j2x properties Initialize L10N feature. Then standard listeners according to their implementations in TestNG: Then overridden TestNG methods FilterTestsListener->onStart(ISuite suite) TestRunListener->onStart(ISuite suite) CarinaListener->onStart(ISuite suite) Now your test class is considered initialized and onStart(ITestContext testContext) method is called. onBeforeClass(ITestClass testClass) . Complete the steps described in @BeforeClass annotation from your test. onTestStart(ITestResult result) provides described data to test. Next, TestRunner.class runs code described in your test class. The following route depends on what you are doing in your test: UI (web, mobile) @Test @MethodOwner() public void webTest() { HomePage chromeHomePage = new HomePage(getDriver()); chromeHomePage.open(); Assert.assertTrue(chromeHomePage.isPageOpened(), \"Chrome home page is not opened!\"); } Debug entry point at : AbstractPage constructor and IDriverPool getDriver() method. API @Test() public void testCreateUser() throws Exception { PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } Debug entry point at : AbstractApiMethodV2 constructor. Database @Test public void createUser() { User USER = new User() {{ setUsername(\"bmarley\"); setFirstName(\"Bob\"); setLastName(\"Marley\"); setStatus(Status.ACTIVE); }}; try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } These are user's classes, samples at carina-demo: UserMapper , ConnectionFactory , User . FAQ Dependent vs. independent tests. Which approach is better? Try to develop fully independent tests to reuse all the benefits of the multi-threading execution. For example, Zebrunner Selenium Grid provides 1000 threads as default limitation and allows to execute your full regression scenarios in minutes! Use dependent methods via dependsOnMethods Test Annotation only if it is really required by Test logic. Carina will preserve all drivers for dependent methods so you can start a driver in one method and proceed with the page in another. public class WebSampleSingleDriver implements IAbstractTest { HomePage homePage = null; CompareModelsPage comparePage = null; List<ModelSpecs> specs = new ArrayList<>(); @BeforeSuite public void startDriver() { // Open GSM Arena home page and verify page is opened homePage = new HomePage(getDriver()); } @Test public void testOpenPage() { homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); } @Test(dependsOnMethods=\"testOpenPage\") //for dependent tests Carina keeps driver sessions by default public void testOpenCompare() { // Open GSM Arena home page and verify page is opened // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); comparePage = footerMenu.openComparePage(); } @Test(dependsOnMethods=\"testOpenCompare\") //for dependent tests Carina keeps driver sessions by default public void testReadSpecs() { // Compare 3 models specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } @Test(dependsOnMethods=\"testReadSpecs\") //for dependent tests Carina keeps driver sessions by default public void testCompareModels() { // Verify model announced dates SoftAssert() softAssert = new SoftAssert(); softAssert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2016, March 31\"); softAssert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2015, June 19\"); softAssert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); softAssert.assertAll(); } }","title":"Program flow"},{"location":"advanced/program_flow/#faq","text":"Dependent vs. independent tests. Which approach is better? Try to develop fully independent tests to reuse all the benefits of the multi-threading execution. For example, Zebrunner Selenium Grid provides 1000 threads as default limitation and allows to execute your full regression scenarios in minutes! Use dependent methods via dependsOnMethods Test Annotation only if it is really required by Test logic. Carina will preserve all drivers for dependent methods so you can start a driver in one method and proceed with the page in another. public class WebSampleSingleDriver implements IAbstractTest { HomePage homePage = null; CompareModelsPage comparePage = null; List<ModelSpecs> specs = new ArrayList<>(); @BeforeSuite public void startDriver() { // Open GSM Arena home page and verify page is opened homePage = new HomePage(getDriver()); } @Test public void testOpenPage() { homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); } @Test(dependsOnMethods=\"testOpenPage\") //for dependent tests Carina keeps driver sessions by default public void testOpenCompare() { // Open GSM Arena home page and verify page is opened // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); comparePage = footerMenu.openComparePage(); } @Test(dependsOnMethods=\"testOpenCompare\") //for dependent tests Carina keeps driver sessions by default public void testReadSpecs() { // Compare 3 models specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); } @Test(dependsOnMethods=\"testReadSpecs\") //for dependent tests Carina keeps driver sessions by default public void testCompareModels() { // Verify model announced dates SoftAssert() softAssert = new SoftAssert(); softAssert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2016, March 31\"); softAssert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2015, June 19\"); softAssert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); softAssert.assertAll(); } }","title":"FAQ"},{"location":"advanced/proxy/","text":"Selenium provides the ability to set various proxy settings for the browser session. This possibility is implemented and supplemented in Carina Framework through the usage of various configurations. First, the type of proxying is controlled by the configuration parameter proxy_type . The value of this parameter can be DIRECT , MANUAL , DYNAMIC , PAC , AUTODETECT , SYSTEM , UNSPECIFIED , UNUSED , LEGACY . Let's consider them in more detail. DIRECT proxy mode Specifies that the session will not use a proxy. Set by changing the value of the proxy_type parameter in the configuration to DIRECT . An example of using a proxy can be viewed here . PAC proxy mode A Proxy Auto-Configuration (PAC) file is a JavaScript function that determines whether web browser requests (HTTP, HTTPS, and FTP) go directly to the destination or are forwarded to a web proxy server. More information about the structure of the pac file can be found here . Set by changing the value of the proxy_type parameter in the configuration to PAC . This mode depends on the following configuration parameters: proxy_autoconfig_url - specifies the URL to be used for proxy auto-configuration. Expected format is http://hostname.com:1234/pacfile . However, the value of this parameter may be local path with pac file. proxy_pac_local - specifies, how the value provided in the proxy_autoconfig_url parameter. If the parameter value is true then it is assumed that proxy_autoconfig_url contains the path to the file on the local machine. It will be sent browser to set up a proxy. If the value of the parameter is false , then it is assumed that that proxy_autoconfig_url contains the URL to the pac file. An example of using a proxy can be viewed here . AUTODETECT proxy mode Specifies whether to autodetect proxy settings. Presumably with WPAD . Set by changing the value of the proxy_type parameter in the configuration to AUTODETECT . An example of using a proxy can be viewed here . SYSTEM proxy mode Use system proxy settings. Default Mode on Linux. Set by changing the value of the proxy_type parameter in the configuration to SYSTEM . An example of using a proxy can be viewed here . UNSPECIFIED proxy mode [NOT RECOMMENDED TO USE] The mode set in the Selenium proxy by default and indicates that they should use the following settings (for Windows - DIRECT mode, for linux - SYSTEM). Set by changing the value of the proxy_type parameter in the configuration to UNSPECIFIED . It is not recommended to use, if you want to specify that the proxy object is not added to session, then use UNUSED mode. Only added because Selenium provides the ability to explicitly specify the UNSPECIFIED proxy type. UNUSED proxy mode Specifies that the proxy object should not be added to the capability to start the driver. However, as practice shows, the proxy object will still be present in the session with the UNSPECIFIED type. Set by changing the value of the proxy_type parameter in the configuration to UNUSED . MANUAL proxy mode Proxy mode, in which the host and port of the proxy are explicitly specified. Set by changing the value of the proxy_type parameter in the configuration to MANUAL . Depends on the following configuration parameters: proxy_host - contains a proxy host, for example 127.0.0.1 proxy_port - contains a proxy port, for example 8080 proxy_protocols - contains a list of protocol types to which should be applied the above options. May contain a set of the following values: http , https , ftp , socks . Values are separated by a comma, such as http,https,ftp . no_proxy - contains comma-separated addresses to which the proxy should not be applied. If this mode applies to the entire application, you can use the following setting: proxy_set_to_system - if true , then sets proxy values to system properties, i.e. the proxy will be applied to all http/https/ftp requests from the application as well (depends on the values listed in proxy_protocols ). However, this approach is not thread-safe and is therefore not recommended for use in all other modes. Disabled by default. An example of using a proxy can be viewed here . DYNAMIC proxy mode Advanced proxy mode. Starts with rules. The rule defines which 'dynamic' proxy should be started when forming capabilities before starting the driver. The rule must implement the interface IProxyRule . The default rule is DefaultProxyRule , which depends on the value of the browserup_proxy parameter (if true, then the proxy should be started, if false, then not), and uses the dynamic proxy implementation, which in turn uses BrowserUpProxy . The rule can be either global or set for a separate test. Setting the rules globally/for the test is done using the methods of the class ProxyPool . Also all dynamic proxies are controlled by this class. This class manages the state of the proxy (starting, stopping, getting information about running proxy, controlling the use of the specified ports). All dynamic proxies depend on the following configuration parameters: proxy_port - priority parameter when obtaining the port for the proxy to be started. The default value is 0 (dynamic port), but this value is relevant for the default dynamic proxy implementation, may not be relevant for other implementations. proxy_ports - defines the range of ports that can be used for running proxies. Example: 4000:5000 - ports 4000 to 5000 will be used. Only used if the value of proxy_ports is NULL . There are also parameters on which the default dynamic proxy implementation depends: browserup_disabled_mitm - when true, MITM capture will be disabled, false otherwise The default dynamic proxy implementation is represented by the CarinaBrowserUpProxy class. An example of using a default dynamic proxy can be viewed here . If you want to use a proxy that is not use BrowserUp or use BrowserUp with custom configuration, then you can create your own implementation. For this you have to create a class, implementing the IProxy interface. In your implementation, you manage the state of the proxy yourself, however, you must follow the rules described by the interface, so that the proxy pool correctly manages your implementation. You also need to implement your rule. To do this, you need to create a class that implements the IProxyRule interface, and then register it using the ProxyPool class methods. This rule will be used instead of the default rule (can be set globally or per test). LEGACY proxy mode [DEFAULT, WILL BE DEPRECATED IN FUTURE RELEASES] Set by changing the value of the proxy_type parameter in the configuration to LEGACY . There is a possibility to send all test traffic via proxy including the embedded light-weight BrowserUp proxy server. There are several properties available to manage all kinds of proxy usage: proxy_host=NULL proxy_port=NULL proxy_protocols=http,https,ftp proxy_set_to_system=true browserup_proxy=false browserup_disabled_mitm=false browserup_port=0 With the enabled browserup_proxy , Carina will start the dedicated proxy instance on every test method. Carina automatically detects an IP address for your local browserup proxy and puts it into the capabilities in case if proxy_host=NULL . If you want to map some publicly available IP address for your browserup proxy instance then you'll need to override it via proxy_host property. E.g. proxy_host=myhostname is useful in case of running maven process inside a docker container. Override the hostname, and it will be available from Selenium instance. browserup_port=0 means that Carina dynamically identifies a free port for a proxy session. browserup_ports_range=8001:8003 means that Carina will use only ports from given range for starting of browserup sessions. That's reasonable for cases when only several ports are shared at environment and can be accessed from other machines within the network. If all ports are used then test will wait for the first freed port. browserup_disabled_mitm is disabled by default. Important! If you have troubles with SSL traffic sniffing, the first thing you should do is to change browserup_disabled_mitm property value! Declare proxy_host, proxy_port and proxy_protocols to send all Web and API test traffic via your static network proxy. Also, to enable proxy for TestNG Java process, proxy_set_to_system must be specified to true , otherwise only WebDrivers and API clients will be proxied. Note: The above settings are mostly required to get public internet access through corporate proxies. Using the default dynamic proxy implementation (CarinaBrowserUpProxy) in DYNAMIC mode in Java code IMPORTANT : All of the following examples of using ProxyPool in the current section use the class ProxyPool . 1) Make sure the driver instance is already started: getDriver(); Note: During the driver startup, Carina automatically starts proxy (depends on rule) and adjusts browser capabilities to track the desired protocols. To get proxy instance for the current test/thread, you can call: Optional<IProxy> proxy = ProxyPool.getProxy(); You can get a specific implementation of a dynamic proxy as follows (but you need to be sure which implementation will be in the pool): Optional<CarinaBrowserUpProxy> proxy = ProxyPool.getOriginal(CarinaBrowserUpProxy.class); 2) Enable the required Har capture type using: CarinaBrowserUpProxy proxy = ProxyPool.getOriginal(CarinaBrowserUpProxy.class) .orElseThrow(); BrowserUpProxy browserUpProxy = proxy.getProxy(); browserUpProxy.enableHarCaptureTypes(CaptureType.REQUEST_CONTENT, CaptureType.RESPONSE_CONTENT); There are a lot of possible content types: CaptureType.RESPONSE_COOKIES CaptureType.RESPONSE_HEADERS CaptureType.REQUEST_HEADERS CaptureType.RESPONSE_CONTENT CaptureType.REQUEST_CONTENT ... They all can be set as comma-separated parameters. 3) You may want to save the captured content into a .har file: proxy.newHar(HAR_NAME); //Some testing activity... //Saving har to a file... File file = new File(HAR_NAME + \".har\"); Assert.assertNotNull(proxy.getHar(), \"Har is NULL!\"); try { proxy.getHar().writeTo(file); } catch (IOException e) { e.printStackTrace(); } Your .har file will be created in the project root folder. 4) There are four methods to support request and response interception: addRequestFilter addResponseFilter addFirstHttpFilterFactory addLastHttpFilterFactory To add and configure content filters, look here . An example of using response filtering can be viewed here . Dealing with MITM and installing SSL certificate into your system: For Mac users: Go here and save it as ca-certificate-rsa.cer . A double click creates a file. The next window should appear: After authorization, the certificate will be added into your system certificates, but it's still untrusted: To make it trusted, double click on it. The following window should appear: First, click the drop-down menu and select Always Trust option. Then close the window (a second authorization will be required): Make sure the red cross on your certificate turned into a blue one: Adding SSL certificate into Java keystore: If you are still receiving the following exception: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target you may need to set up ca-certificate-rsa.cer into your Java keystore. For Mac and Linux users: sudo keytool -importcert -alias browserup -file pathToYourCertificateLocation/BrowserUpCertificate.crt -keystore /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/security/cacerts You will be asked to enter your Mac profile password and a Java keystore password (by default: changeit).","title":"Proxy"},{"location":"advanced/proxy/#direct-proxy-mode","text":"Specifies that the session will not use a proxy. Set by changing the value of the proxy_type parameter in the configuration to DIRECT . An example of using a proxy can be viewed here .","title":"DIRECT proxy mode"},{"location":"advanced/proxy/#pac-proxy-mode","text":"A Proxy Auto-Configuration (PAC) file is a JavaScript function that determines whether web browser requests (HTTP, HTTPS, and FTP) go directly to the destination or are forwarded to a web proxy server. More information about the structure of the pac file can be found here . Set by changing the value of the proxy_type parameter in the configuration to PAC . This mode depends on the following configuration parameters: proxy_autoconfig_url - specifies the URL to be used for proxy auto-configuration. Expected format is http://hostname.com:1234/pacfile . However, the value of this parameter may be local path with pac file. proxy_pac_local - specifies, how the value provided in the proxy_autoconfig_url parameter. If the parameter value is true then it is assumed that proxy_autoconfig_url contains the path to the file on the local machine. It will be sent browser to set up a proxy. If the value of the parameter is false , then it is assumed that that proxy_autoconfig_url contains the URL to the pac file. An example of using a proxy can be viewed here .","title":"PAC proxy mode"},{"location":"advanced/proxy/#autodetect-proxy-mode","text":"Specifies whether to autodetect proxy settings. Presumably with WPAD . Set by changing the value of the proxy_type parameter in the configuration to AUTODETECT . An example of using a proxy can be viewed here .","title":"AUTODETECT proxy mode"},{"location":"advanced/proxy/#system-proxy-mode","text":"Use system proxy settings. Default Mode on Linux. Set by changing the value of the proxy_type parameter in the configuration to SYSTEM . An example of using a proxy can be viewed here .","title":"SYSTEM proxy mode"},{"location":"advanced/proxy/#unspecified-proxy-mode-not-recommended-to-use","text":"The mode set in the Selenium proxy by default and indicates that they should use the following settings (for Windows - DIRECT mode, for linux - SYSTEM). Set by changing the value of the proxy_type parameter in the configuration to UNSPECIFIED . It is not recommended to use, if you want to specify that the proxy object is not added to session, then use UNUSED mode. Only added because Selenium provides the ability to explicitly specify the UNSPECIFIED proxy type.","title":"UNSPECIFIED proxy mode [NOT RECOMMENDED TO USE]"},{"location":"advanced/proxy/#unused-proxy-mode","text":"Specifies that the proxy object should not be added to the capability to start the driver. However, as practice shows, the proxy object will still be present in the session with the UNSPECIFIED type. Set by changing the value of the proxy_type parameter in the configuration to UNUSED .","title":"UNUSED proxy mode"},{"location":"advanced/proxy/#manual-proxy-mode","text":"Proxy mode, in which the host and port of the proxy are explicitly specified. Set by changing the value of the proxy_type parameter in the configuration to MANUAL . Depends on the following configuration parameters: proxy_host - contains a proxy host, for example 127.0.0.1 proxy_port - contains a proxy port, for example 8080 proxy_protocols - contains a list of protocol types to which should be applied the above options. May contain a set of the following values: http , https , ftp , socks . Values are separated by a comma, such as http,https,ftp . no_proxy - contains comma-separated addresses to which the proxy should not be applied. If this mode applies to the entire application, you can use the following setting: proxy_set_to_system - if true , then sets proxy values to system properties, i.e. the proxy will be applied to all http/https/ftp requests from the application as well (depends on the values listed in proxy_protocols ). However, this approach is not thread-safe and is therefore not recommended for use in all other modes. Disabled by default. An example of using a proxy can be viewed here .","title":"MANUAL proxy mode"},{"location":"advanced/proxy/#dynamic-proxy-mode","text":"Advanced proxy mode. Starts with rules. The rule defines which 'dynamic' proxy should be started when forming capabilities before starting the driver. The rule must implement the interface IProxyRule . The default rule is DefaultProxyRule , which depends on the value of the browserup_proxy parameter (if true, then the proxy should be started, if false, then not), and uses the dynamic proxy implementation, which in turn uses BrowserUpProxy . The rule can be either global or set for a separate test. Setting the rules globally/for the test is done using the methods of the class ProxyPool . Also all dynamic proxies are controlled by this class. This class manages the state of the proxy (starting, stopping, getting information about running proxy, controlling the use of the specified ports). All dynamic proxies depend on the following configuration parameters: proxy_port - priority parameter when obtaining the port for the proxy to be started. The default value is 0 (dynamic port), but this value is relevant for the default dynamic proxy implementation, may not be relevant for other implementations. proxy_ports - defines the range of ports that can be used for running proxies. Example: 4000:5000 - ports 4000 to 5000 will be used. Only used if the value of proxy_ports is NULL . There are also parameters on which the default dynamic proxy implementation depends: browserup_disabled_mitm - when true, MITM capture will be disabled, false otherwise The default dynamic proxy implementation is represented by the CarinaBrowserUpProxy class. An example of using a default dynamic proxy can be viewed here . If you want to use a proxy that is not use BrowserUp or use BrowserUp with custom configuration, then you can create your own implementation. For this you have to create a class, implementing the IProxy interface. In your implementation, you manage the state of the proxy yourself, however, you must follow the rules described by the interface, so that the proxy pool correctly manages your implementation. You also need to implement your rule. To do this, you need to create a class that implements the IProxyRule interface, and then register it using the ProxyPool class methods. This rule will be used instead of the default rule (can be set globally or per test).","title":"DYNAMIC proxy mode"},{"location":"advanced/proxy/#legacy-proxy-mode-default-will-be-deprecated-in-future-releases","text":"Set by changing the value of the proxy_type parameter in the configuration to LEGACY . There is a possibility to send all test traffic via proxy including the embedded light-weight BrowserUp proxy server. There are several properties available to manage all kinds of proxy usage: proxy_host=NULL proxy_port=NULL proxy_protocols=http,https,ftp proxy_set_to_system=true browserup_proxy=false browserup_disabled_mitm=false browserup_port=0 With the enabled browserup_proxy , Carina will start the dedicated proxy instance on every test method. Carina automatically detects an IP address for your local browserup proxy and puts it into the capabilities in case if proxy_host=NULL . If you want to map some publicly available IP address for your browserup proxy instance then you'll need to override it via proxy_host property. E.g. proxy_host=myhostname is useful in case of running maven process inside a docker container. Override the hostname, and it will be available from Selenium instance. browserup_port=0 means that Carina dynamically identifies a free port for a proxy session. browserup_ports_range=8001:8003 means that Carina will use only ports from given range for starting of browserup sessions. That's reasonable for cases when only several ports are shared at environment and can be accessed from other machines within the network. If all ports are used then test will wait for the first freed port. browserup_disabled_mitm is disabled by default. Important! If you have troubles with SSL traffic sniffing, the first thing you should do is to change browserup_disabled_mitm property value! Declare proxy_host, proxy_port and proxy_protocols to send all Web and API test traffic via your static network proxy. Also, to enable proxy for TestNG Java process, proxy_set_to_system must be specified to true , otherwise only WebDrivers and API clients will be proxied. Note: The above settings are mostly required to get public internet access through corporate proxies.","title":"LEGACY proxy mode [DEFAULT, WILL BE DEPRECATED IN FUTURE RELEASES]"},{"location":"advanced/proxy/#using-the-default-dynamic-proxy-implementation-carinabrowserupproxy-in-dynamic-mode-in-java-code","text":"IMPORTANT : All of the following examples of using ProxyPool in the current section use the class ProxyPool . 1) Make sure the driver instance is already started: getDriver(); Note: During the driver startup, Carina automatically starts proxy (depends on rule) and adjusts browser capabilities to track the desired protocols. To get proxy instance for the current test/thread, you can call: Optional<IProxy> proxy = ProxyPool.getProxy(); You can get a specific implementation of a dynamic proxy as follows (but you need to be sure which implementation will be in the pool): Optional<CarinaBrowserUpProxy> proxy = ProxyPool.getOriginal(CarinaBrowserUpProxy.class); 2) Enable the required Har capture type using: CarinaBrowserUpProxy proxy = ProxyPool.getOriginal(CarinaBrowserUpProxy.class) .orElseThrow(); BrowserUpProxy browserUpProxy = proxy.getProxy(); browserUpProxy.enableHarCaptureTypes(CaptureType.REQUEST_CONTENT, CaptureType.RESPONSE_CONTENT); There are a lot of possible content types: CaptureType.RESPONSE_COOKIES CaptureType.RESPONSE_HEADERS CaptureType.REQUEST_HEADERS CaptureType.RESPONSE_CONTENT CaptureType.REQUEST_CONTENT ... They all can be set as comma-separated parameters. 3) You may want to save the captured content into a .har file: proxy.newHar(HAR_NAME); //Some testing activity... //Saving har to a file... File file = new File(HAR_NAME + \".har\"); Assert.assertNotNull(proxy.getHar(), \"Har is NULL!\"); try { proxy.getHar().writeTo(file); } catch (IOException e) { e.printStackTrace(); } Your .har file will be created in the project root folder. 4) There are four methods to support request and response interception: addRequestFilter addResponseFilter addFirstHttpFilterFactory addLastHttpFilterFactory To add and configure content filters, look here . An example of using response filtering can be viewed here .","title":"Using the default dynamic proxy implementation (CarinaBrowserUpProxy) in DYNAMIC mode in Java code"},{"location":"advanced/proxy/#dealing-with-mitm-and-installing-ssl-certificate-into-your-system","text":"","title":"Dealing with MITM and installing SSL certificate into your system:"},{"location":"advanced/proxy/#for-mac-users","text":"Go here and save it as ca-certificate-rsa.cer . A double click creates a file. The next window should appear: After authorization, the certificate will be added into your system certificates, but it's still untrusted: To make it trusted, double click on it. The following window should appear: First, click the drop-down menu and select Always Trust option. Then close the window (a second authorization will be required): Make sure the red cross on your certificate turned into a blue one:","title":"For Mac users:"},{"location":"advanced/proxy/#adding-ssl-certificate-into-java-keystore","text":"If you are still receiving the following exception: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target you may need to set up ca-certificate-rsa.cer into your Java keystore.","title":"Adding SSL certificate into Java keystore:"},{"location":"advanced/proxy/#for-mac-and-linux-users","text":"sudo keytool -importcert -alias browserup -file pathToYourCertificateLocation/BrowserUpCertificate.crt -keystore /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/security/cacerts You will be asked to enter your Mac profile password and a Java keystore password (by default: changeit).","title":"For Mac and Linux users:"},{"location":"advanced/screenshot/","text":"The screenshot creation logic is provided in the Screenshot class. Taking screenshots is controlled by rules. Rules are divided into four types - successful driver action, unsuccessful driver action, explicit full-size and explicit visible (page or element, depends on the method used). Successful driver action Produced after a successful click, entering text in a field, etc. Used in the event listener of the driver used by the Carina Framework. It is also logical to use it in custom event listeners of the driver. The default rule implementation is provided in the DefaultSuccessfulDriverActionScreenshotRule class and has the following logic: A screenshot is taken of only the visible part of the site/application. Whether to create screenshots or not depends on the configuration parameter auto_screenshot . A rule of this type must use SUCCESSFUL_DRIVER_ACTION as the return value in the getScreenshotType method. Usage example: // taking a screenshot of the visible part of the page Screenshot.capture(getDriver(), ScreenshotType.SUCCESSFUL_DRIVER_ACTION); If you need to take a screenshot of just the element: ... @Override public void afterClick(WebElement element) { // taking a screenshot of an element Screenshot.capture(element, ScreenshotType.SUCCESSFUL_DRIVER_ACTION, \"Element clicked\"); } ... Error while executing driver action Produced after an unsuccessful click, text input, etc. Used in the event listener of the driver used by the Carina Framework. It is also logical to use it in custom event listeners of the driver. The default rule implementation is provided in the DefaultUnSuccessfulDriverActionScreenshotRule class and has the following logic: Screenshot required. Creating a full page/only visible part of a screenshot depends on the allow_fullsize_screenshot configuration value. Important : Taking a screenshot of the entire page might significantly slow down your tests execution. A rule of this type must use UNSUCCESSFUL_DRIVER_ACTION as the return value in the getScreenshotType method. Usage example: // taking a screenshot of the visible part of the page Screenshot.capture(getDriver(), ScreenshotType.UNSUCCESSFUL_DRIVER_ACTION); Explicitly creating a full-page screenshot Designed for those cases when you need to take a screenshot in the test. The default rule implementation is provided in the ExplicitFullSizeScreenshotRule class and has the following logic: Screenshot required. t's always full page. A rule of this type must use EXPLICIT_FULL_SIZE as the return value in the getScreenshotType method. Usage example: Screenshot.capture(getDriver(), ScreenshotType.EXPLICIT_FULL_SIZE); Important : Taking a screenshot of the entire page might significantly slow down your tests execution. Explicit creation of a screenshot of the visible part of the page/application Designed for those cases when you need to take a screenshot in the test. The default rule implementation is provided in the ExplicitVisibleScreenshotRule class and has the following logic: Screenshot required. It is always only the visible part of the page/application. A rule of this type must use EXPLICIT_VISIBLE as the return value in the getScreenshotType method. Create your own rule You can implement and register any custom rules based on your requirements. The rule must implement the IScreenshotRule interface. The rule is registered using addRule method of the Screenshot class. The rule is registered globally, and if already registered rule of the same type, it will be overwritten. All default rules have the following properties (which can be changed): The timeout is calculated by dividing the explicit_timeout configuration value by a divisor. If the screenshot is full-page, then the divisor is 2 , otherwise 3 . DEBUG logging mode performs strict rule compliance checks. The name of the screenshot file is generated by the System.currentTimeMillis() method. The folder where screenshots are saved is determined by the value of the ReportContext.getTestDir().getAbsolutePath() method. Screenshot resizing is determined by the configuration parameters big_screen_width and big_screen_height . To turn off all kinds of screenshots, remove all rules: Screenshot.clearRules() FAQ How can I find all places where automatic screenshot capturing is performed? You can take a look into the DriverListener and CarinaListener to find call hierarchy.","title":"Screenshot"},{"location":"advanced/screenshot/#successful-driver-action","text":"Produced after a successful click, entering text in a field, etc. Used in the event listener of the driver used by the Carina Framework. It is also logical to use it in custom event listeners of the driver. The default rule implementation is provided in the DefaultSuccessfulDriverActionScreenshotRule class and has the following logic: A screenshot is taken of only the visible part of the site/application. Whether to create screenshots or not depends on the configuration parameter auto_screenshot . A rule of this type must use SUCCESSFUL_DRIVER_ACTION as the return value in the getScreenshotType method. Usage example: // taking a screenshot of the visible part of the page Screenshot.capture(getDriver(), ScreenshotType.SUCCESSFUL_DRIVER_ACTION); If you need to take a screenshot of just the element: ... @Override public void afterClick(WebElement element) { // taking a screenshot of an element Screenshot.capture(element, ScreenshotType.SUCCESSFUL_DRIVER_ACTION, \"Element clicked\"); } ...","title":"Successful driver action"},{"location":"advanced/screenshot/#error-while-executing-driver-action","text":"Produced after an unsuccessful click, text input, etc. Used in the event listener of the driver used by the Carina Framework. It is also logical to use it in custom event listeners of the driver. The default rule implementation is provided in the DefaultUnSuccessfulDriverActionScreenshotRule class and has the following logic: Screenshot required. Creating a full page/only visible part of a screenshot depends on the allow_fullsize_screenshot configuration value. Important : Taking a screenshot of the entire page might significantly slow down your tests execution. A rule of this type must use UNSUCCESSFUL_DRIVER_ACTION as the return value in the getScreenshotType method. Usage example: // taking a screenshot of the visible part of the page Screenshot.capture(getDriver(), ScreenshotType.UNSUCCESSFUL_DRIVER_ACTION);","title":"Error while executing driver action"},{"location":"advanced/screenshot/#explicitly-creating-a-full-page-screenshot","text":"Designed for those cases when you need to take a screenshot in the test. The default rule implementation is provided in the ExplicitFullSizeScreenshotRule class and has the following logic: Screenshot required. t's always full page. A rule of this type must use EXPLICIT_FULL_SIZE as the return value in the getScreenshotType method. Usage example: Screenshot.capture(getDriver(), ScreenshotType.EXPLICIT_FULL_SIZE); Important : Taking a screenshot of the entire page might significantly slow down your tests execution.","title":"Explicitly creating a full-page screenshot"},{"location":"advanced/screenshot/#explicit-creation-of-a-screenshot-of-the-visible-part-of-the-pageapplication","text":"Designed for those cases when you need to take a screenshot in the test. The default rule implementation is provided in the ExplicitVisibleScreenshotRule class and has the following logic: Screenshot required. It is always only the visible part of the page/application. A rule of this type must use EXPLICIT_VISIBLE as the return value in the getScreenshotType method.","title":"Explicit creation of a screenshot of the visible part of the page/application"},{"location":"advanced/screenshot/#create-your-own-rule","text":"You can implement and register any custom rules based on your requirements. The rule must implement the IScreenshotRule interface. The rule is registered using addRule method of the Screenshot class. The rule is registered globally, and if already registered rule of the same type, it will be overwritten. All default rules have the following properties (which can be changed): The timeout is calculated by dividing the explicit_timeout configuration value by a divisor. If the screenshot is full-page, then the divisor is 2 , otherwise 3 . DEBUG logging mode performs strict rule compliance checks. The name of the screenshot file is generated by the System.currentTimeMillis() method. The folder where screenshots are saved is determined by the value of the ReportContext.getTestDir().getAbsolutePath() method. Screenshot resizing is determined by the configuration parameters big_screen_width and big_screen_height . To turn off all kinds of screenshots, remove all rules: Screenshot.clearRules()","title":"Create your own rule"},{"location":"advanced/screenshot/#faq","text":"How can I find all places where automatic screenshot capturing is performed? You can take a look into the DriverListener and CarinaListener to find call hierarchy.","title":"FAQ"},{"location":"advanced/security/","text":"Security functionality in Carina framework is required for sensitive data that should be hidden in test configurations and logging. It uses a symmetric key encryption algorithm for security implementation, which means that anyone may encrypt/decrypt the data in the same way, using the same key. In Carina framework, AES encryption is used by default with a 128-bit security key. Anyone may generate their own security key and encrypt the data using this key, so that the decrypted valid data may be used in the test only if the valid key is specified in the test configuration. Also, one may use the default common key located in test resources, giving access to all other users for secured data decryption. Secured data preparation For secured data preparation, we implemented a special tool that helps to generate crypto keys and encrypt/decrypt test data files. Here is a usage tip: com.zebrunner.carina.crypto.CryptoConsole -help com.zebrunner.carina.crypto.CryptoConsole -generate -algorithm \"algorithm\" -keysize=\"key size\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -file=\"path_to_file_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -file=\"path_to_file_to_encrypt\" To generate an individual crypto key: Go to \"Run configuration\" in Eclipse Create a new Java application configuration selecting the project and the main class com.zebrunner.carina.crypto.CryptoConsole : Set arguments Press Apply and then Run A crypto key will be generated: To prepare a test data file with secured data: Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values. Go to \u201cRun configuration\u201d, navigate to the arguments tab and execute the encryption command specifying the key and input file: A file with encrypted data will be generated: To encrypt a single string, use the following config: The encrypted string will be shown in the console: To decrypt the encrypted file, execute: The decrypted file will be generated: Secured data usage You may use encrypted values, both in test configuration and test data files; pay attention to the fact that there is no explicit BeforeTest listener for data decryption, so there is no way to find out later in the test if the data is sensitive or not. All the decryption logic is located in WebDriverHelper that wraps Selenium WebDriver methods for interaction with UI and encapsulates action logging logic. Every method that receives a text tests if the text contains {crypt:...} pattern, and if it does, decrypts it and passes it to UI- logging, and screenshots are populated with hidden characters: \u0421arina also supports advanced decryption. This means that you can decrypt only the part of the string that you need. This the decryptByPattern method of the CryptoTool class. To decrypt your string use it like this: String value = \"test@gmail.com/{crypt:8O9iA4+f3nMzz85szmvKmQ==}\" CryptoTool cryptoTool = CryptoToolBuilder.builder() .chooseAlgorithm(Algorithm.find(Configuration.get(Parameter.CRYPTO_ALGORITHM))) .setKey(Configuration.get(Parameter.CRYPTO_KEY_VALUE)) .build(); String CRYPTO_PATTERN = Configuration.get(Parameter.CRYPTO_PATTERN); String decryptedValue = cryptoTool.decrypt(value, CRYPTO_PATTERN); As a result decryptedValue will be test@gmail.com/EncryptMe .","title":"Security"},{"location":"advanced/security/#secured-data-preparation","text":"For secured data preparation, we implemented a special tool that helps to generate crypto keys and encrypt/decrypt test data files. Here is a usage tip: com.zebrunner.carina.crypto.CryptoConsole -help com.zebrunner.carina.crypto.CryptoConsole -generate -algorithm \"algorithm\" -keysize=\"key size\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -pattern=\"pattern\" -wrapper=\"wrapper\" -string=\"string_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -encrypt -algorithm \"algorithm\" -key=\"key\" -file=\"path_to_file_to_encrypt\" com.zebrunner.carina.crypto.CryptoConsole -decrypt -algorithm \"algorithm\" -key=\"key\" -file=\"path_to_file_to_encrypt\" To generate an individual crypto key: Go to \"Run configuration\" in Eclipse Create a new Java application configuration selecting the project and the main class com.zebrunner.carina.crypto.CryptoConsole : Set arguments Press Apply and then Run A crypto key will be generated: To prepare a test data file with secured data: Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values. Go to \u201cRun configuration\u201d, navigate to the arguments tab and execute the encryption command specifying the key and input file: A file with encrypted data will be generated: To encrypt a single string, use the following config: The encrypted string will be shown in the console: To decrypt the encrypted file, execute: The decrypted file will be generated:","title":"Secured data preparation"},{"location":"advanced/security/#secured-data-usage","text":"You may use encrypted values, both in test configuration and test data files; pay attention to the fact that there is no explicit BeforeTest listener for data decryption, so there is no way to find out later in the test if the data is sensitive or not. All the decryption logic is located in WebDriverHelper that wraps Selenium WebDriver methods for interaction with UI and encapsulates action logging logic. Every method that receives a text tests if the text contains {crypt:...} pattern, and if it does, decrypts it and passes it to UI- logging, and screenshots are populated with hidden characters: \u0421arina also supports advanced decryption. This means that you can decrypt only the part of the string that you need. This the decryptByPattern method of the CryptoTool class. To decrypt your string use it like this: String value = \"test@gmail.com/{crypt:8O9iA4+f3nMzz85szmvKmQ==}\" CryptoTool cryptoTool = CryptoToolBuilder.builder() .chooseAlgorithm(Algorithm.find(Configuration.get(Parameter.CRYPTO_ALGORITHM))) .setKey(Configuration.get(Parameter.CRYPTO_KEY_VALUE)) .build(); String CRYPTO_PATTERN = Configuration.get(Parameter.CRYPTO_PATTERN); String decryptedValue = cryptoTool.decrypt(value, CRYPTO_PATTERN); As a result decryptedValue will be test@gmail.com/EncryptMe .","title":"Secured data usage"},{"location":"automation/api/","text":"Rest API testing is a vital part of integration testing process, it may be used separately or together with web, mobile or DB testing. The general process may be described by the following steps: Compile an HTTP request with the required meta data Send the prepared data to the required server endpoint Validate the HTTP status and response data Extract some response data for the next requests Build a call to the next (or the same) endpoint using (or not using) the data from the previous response The schema below demonstrates the sequence: From this perspective, we decided to use the following instruments: Rest-assured - \"Testing and validation of REST services in Java are harder than in dynamic languages such as Ruby and Groovy. REST Assured brings the simplicity of using these languages into the Java domain.\" Freemarker - \"Apache FreeMarker is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data.\" JsonPath - a library for extracting data from JSON body JsonAssert - a library for comparing the actual JSON body with an expected one Json-schema-validator - a library for validating of JSON body for matching to JSON schema Pre requirements To use api feature, add certain dependency to your pom.xml <dependency> <groupId>com.zebrunner</groupId> <artifactId>carina-api</artifactId> <version>RELEASE</version> </dependency> Visit our github to check the latest version of carina-api. Example of test implementation Let's create an automated test for the next call: POST https://jsonplaceholder.typicode.com/users request with a request body [ { \"id\": 1, \"name\": \"SOME_NAME\", \"username\": \"SOME_USERNAME\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"SOME_COMPANY_NAME\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } ] and the response body the same as the request body Definition of request and response templates If we are going to send POST request, we need to create a request template with some placeholders that may be replaced by different arguments for different test flows. The best place to store these resources is src/test/resources/api package, try to keep REST hierarchy in a package structure for better maintenance and visibility: Request (rq.json) and response (rs.json) templates have some placeholders that will be populated from the tests later on: While user.properties contains some default value which may be replaced later: REST service call domain object [DEPRECATED] Now we are ready to create REST service domain object which will be used to interact with web service and perform additional response validations. Our domain object is located in /carina-demo/src/main/java/com/zebrunner/carina/demo/api, make sure that it extends AbstractApiMethodV2 and triggers the base class constructor for initialization. In general cases, you will specify the path to request and response templates along with default properties files (all of them have been created in the previous step). Also, we replace the URL placeholder to set an appropriate environment. package com.zebrunner.carina.demo.api; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.utils.Configuration; public class PostUserMethod extends AbstractApiMethodV2 { public PostUserMethod() { super(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } } HTTP method and path [DEPRECATED] The last step before the test implementation itself is the association of the domain object class and the required HTTP method and path. It should be defined in /carina-demo/src/main/resources/_api.properties file, the key should be equal to domain class name, the value has the following pattern {http_method}:{http_path}. The HTTP path may contain placeholders, the HTTP method should be one of the following variants: GET, POST, PUT, UPDATE, DELETE. #=====================================================# #=================== API methods ====================# #=====================================================# GetUserMethods=GET:${base_url}/users PostUserMethod=POST:${base_url}/users DeleteUserMethod=DELETE:${base_url}/users/1 PutPostsMethod=PUT:${base_url}/posts/1 PatchPostsMethod=PATCH:${base_url}/posts/1 REST service call domain object (Annotation based approach) Approach based on initialisation of super class constructor is deprecated and more convenient way is to use annotations. They can be used over class declarations. For api testing we can use such annotations: @ContentType - is used to define the value of Content-type header in response @Cookie - is used to specify cookies in the request @Endpoint - combination of http method + url which defines any single API endpoint @Header - is used to specify headers in the request @HideRequestBodyPartsInLogs - is used to hide sensitive parts of the request body in the logs @HideRequestHeadersInLogs - is used to hide sensitive parts of the request headers in the logs @HideResponseBodyPartsInLogs - is used to hide secret parts of the response body in the logs @PropertiesPath - contains a path to default properties file for endpoint templates (relative path from root of code sources) @QueryParam - is used to specify query parameters in the request @RequestTemplatePath - contains a path to default request template for mentioned endpoint (relative path from root of code sources) @ResponseTemplatePath - contains a path to default response template for mentioned endpoint (relative path from root of code sources) @SuccessfulHttpStatus - specifies the expected HTTP status for happy-path scenarios In this case we don\u2019t need to define _api.properties file and call the constructor of a super class, but if we have some properties file used in this request we should explicitly set it in test method. Insead of callAPI() and expectResponseStatus() methods we can use callAPIExpectSuccess() that will call API expecting http status in response taken from @SuccessfulHttpStatus value. @Endpoint(url = \"${base_url}/users/1\", methodType = HttpMethodType.DELETE) @RequestTemplatePath(path = \"api/users/_delete/rq.json\") @ResponseTemplatePath(path = \"api/users/_delete/rs.json\") @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) public class DeleteUserMethod extends AbstractApiMethodV2 { public DeleteUserMethod() { replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } } Also placeholders in URL can be automatically replaced by carina if they're specified in carina configuration properties (config.properties). To make auto-replacement happen just use next syntax in your URL: - when param starts with config.\\* then R.CONFIG.get(\"\\*\") will be used as a replacement - when param starts with config.env.\\* then Configuration.getEnvArg(\"\\*\") will be used as a replacement So you may use next implementation: @Endpoint(url = \"${config.env.base_url}/users/1\", methodType = HttpMethodType.DELETE) public class DeleteUserMethod extends AbstractApiMethodV2 { } And before sending of request base part of URL will be set by carina depending on used environment automatically. API test API test is a general TestNG test, a class should extend APITest, in our case, the test implements IAbstractTest that encapsulates some test data and login method. The test is located in /carina-demo/src/test/java/com/zebrunner/carina/demo. package com.zebrunner.carina.demo; import java.lang.invoke.MethodHandles; import org.skyscreamer.jsonassert.JSONCompareMode; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.testng.annotations.Test; import com.zebrunner.carina.api.apitools.validation.JsonCompareKeywords; import com.zebrunner.carina.core.IAbstractTest; import com.zebrunner.carina.core.registrar.ownership.MethodOwner; import com.zebrunner.carina.core.registrar.tag.TestPriority; import com.zebrunner.carina.core.foundation.utils.tag.TestPriority; import com.zebrunner.carina.demo.api.DeleteUserMethod; import com.zebrunner.carina.demo.api.GetUserMethods; import com.zebrunner.carina.demo.api.PostUserMethod; /** * This sample shows how create REST API tests. * * @author qpsdemo */ public class APISampleTest implements IAbstractTest { private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() { LOGGER.info(\"test\"); setCases(\"4555,54545\"); PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUserMissingSomeFields() { PostUserMethod api = new PostUserMethod(); api.setProperties(\"api/users/user.properties\"); api.getProperties().remove(\"name\"); api.getProperties().remove(\"username\"); api.callAPIExpectSuccess(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testGetUsers() { GetUserMethods getUsersMethods = new GetUserMethods(); getUsersMethods.callAPIExpectSuccess(); getUsersMethods.validateResponse(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey()); getUsersMethods.validateResponseAgainstSchema(\"api/users/_get/rs.schema\"); } @Test() @MethodOwner(owner = \"qpsdemo\") @TestPriority(Priority.P1) public void testDeleteUsers() { DeleteUserMethod deleteUserMethod = new DeleteUserMethod(); deleteUserMethod.setProperties(\"api/users/user.properties\"); deleteUserMethod.callAPIExpectSuccess(); deleteUserMethod.validateResponse(); } } Test steps once again Create REST call object Specify the properties for a request/response placeholder Add headers if required Specify the expected HTTP status Call API Validate the response by a template or parse some data by JSON path Make further calls using the data from the previous call if needed REST service call domain object (Declarative approach) Approach based on implicit instantiation of the AbstractApiMethod . It allows to: - more convenient and efficiently organize description of endpoints; - have all carina api methods for the same URL pattern be defined within single class; - reduce time for the implementation of the desired AbstractApiMethod ; - flexibly configure all api methods with Java annotations. Here is example of multiple api methods definition for one url pattern. Base url template can be easily overwritten with use of @EndpointTemplateMethod annotation: package com.zebrunner.carina.demo.api; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.annotation.EndpointTemplate; import com.zebrunner.carina.api.annotation.EndpointTemplateMethod; import com.zebrunner.carina.api.annotation.PathParam; import com.zebrunner.carina.api.annotation.PropertiesPath; import com.zebrunner.carina.api.annotation.RequestTemplatePath; import com.zebrunner.carina.api.annotation.ResponseTemplatePath; import com.zebrunner.carina.api.annotation.SuccessfulHttpStatus; import com.zebrunner.carina.api.annotation.method.DeleteMethod; import com.zebrunner.carina.api.http.HttpMethodType; import com.zebrunner.carina.api.http.HttpResponseStatusType; @EndpointTemplate(url = \"${config.env.base_url}/users\") public interface UserTemplate { @EndpointTemplateMethod(url = \"/\", methodType = HttpMethodType.POST) AbstractApiMethodV2 create(@RequestTemplatePath.Value String rqPath, @ResponseTemplatePath.Value String rsPath, @PropertiesPath.Value String propsPath); @EndpointTemplateMethod(url = \"/\", methodType = HttpMethodType.GET) @ResponseTemplatePath(path = \"api/users/_get/rs.json\") @PropertiesPath(path = \"api/users/user.properties\") AbstractApiMethodV2 getAll(); @DeleteMethod(url = \"/${id}\") @RequestTemplatePath(path = \"api/users/_delete/rq.json\") @ResponseTemplatePath(path = \"api/users/_delete/rs.json\") @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) AbstractApiMethodV2 deleteById(@PathParam(key = \"id\") Long id); } All the annotations of the Annotation based approach work here as well ( Important: except the @Endpoint annotation). In this approach it is possible to use these annotations not only on the class but also on the method level. In addition, you can apply the following annotations: @Cookie.Value - is used to specify cookies in the request (for use with method's parameters) @EndpointTemplate - defines the basic part of the request URL. This part will be a basic one for every inner method. @EndpointTemplateMethod - defines relative part of the request URL. This part will be concatenated with the EndpointTemplate path (if defined) @Header.Value - is used to specify headers in the request (for use with method's parameters) @PathParam - is used to specify named URL placeholder value. Placeholder will be replaced automatically (for use with method's parameters) @PropertiesPath.Value - contains a path to default properties file for endpoint templates (for use with method's parameters) @Property - is used to specify additional properties. These properties will be automatically added to the future method instance (for use with method's parameters) @QueryParam.Value - is used to specify URL query parameters. These query parameters will be automatically added to the URL (for use with method's parameters) @RequestTemplatePath.Value - contains a path to default request template for mentioned endpoint (for use with method's parameters) @ResponseTemplatePath.Value - contains a path to default response template for mentioned endpoint (for use with method's parameters) @SuccessfulHttpStatus.Value - specifies the expected HTTP status for happy-path scenarios (for use with method's parameters) There is also \"syntactic sugar\" available for making the EndpointTemplateMethod annotation more readable: 1. @GetMethod - endpoint template with GET method 2. @PostMethod - endpoint template with POST method 3. @PutMethod - endpoint template with PUT method 4. @PatchMethod - endpoint template with PATCH method 5. @DeleteMethod - endpoint template with DELETE method 6. @HeadMethod - endpoint template with HEAD method 7. @OptionsMethod - endpoint template with OPTIONS method Now you can invoke a prepareTemplate method from TemplateFactory to use proxy implementation in the test: @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() { UserTemplate userTemplate = TemplateFactory.prepareTemplate(UserTemplate.class); PostUserMethod api = userTemplate.create(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } For more customization on api method definition level you can implement the interface and use the proxy class inside: package com.zebrunner.carina.demo.api.impl; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.binding.TemplateFactory; import com.zebrunner.carina.demo.api.UserTemplate; public class UserTemplateImpl implements UserTemplate { private final UserTemplate userTemplate; public UserTemplateImpl(UserTemplate userTemplate) { this.userTemplate = TemplateFactory.prepareTemplate(UserTemplate.class); } @Override public AbstractApiMethodV2 create(String rqPath, String rsPath, String propsPath) { AbstractApiMethodV2 apiMethod = userTemplate.create(rqPath, rsPath, propsPath); apiMethod.addProperty(\"prop\", \"val\"); return apiMethod; } @Override public AbstractApiMethodV2 getAll() { AbstractApiMethodV2 apiMethod = userTemplate.getAll(); apiMethod.addCookie(\"cookie\", \"val\"); return apiMethod; } @Override public AbstractApiMethodV2 deleteById(Long id) { AbstractApiMethodV2 apiMethod = userTemplate.deleteById(id); apiMethod.setHeader(\"header\", \"val\"); return apiMethod; } } To perform the general logic under multiple API templates you can create interceptors . Useful features The framework contains a list of useful features for building requests and validation of responses. It makes the support of such tests easier and at the same time minimizes the amount of test data. Repeating API calling with the condition Sometimes we should do a lot of API calls waiting for particular artifact in response. In this case, you can use callAPIWithRetry method in AbstractApiMethodV2 class. This method provides us an object of APIMethodPoller class. Methods of this object give us an ability to set an interval for api calling, timeout, logging strategy, actions that should be executed immediately after the api calling, condition under which the response is considered successful, action that will be executed after all api callings. Example of using: @Test public void testCreateUserWaitingResponseContainsAddress() { PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); Optional<Response> response = api.callAPIWithRetry() .withLogStrategy(APIMethodPoller.LogStrategy.LAST_ONLY) .until(rs -> rs.getBody().asString().contains(\"address\")) .execute(); api.validateResponse(); Assert.assertFalse(response.isEmpty(), \"Response should exists\"); } Handling and changing AbstractApiMethod on-the-fly This option provides the ability for handling and changing of your AbstractApiMethod instances on-the-fly. For that it's needed to create an implementation of ApiMethodInterceptor interface: package com.zebrunner.carina.demo.api.interceptor; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.interceptor.ApiMethodInterceptor; public class CustomInterceptor implements ApiMethodInterceptor<AbstractApiMethodV2> { @Override public void onInstantiation(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been instantiated } @Override public void onBeforeCall(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been created } @Override public void onAfterCall(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been called } } and add this class into @LinkedInterceptors annotation for your api method: Annotation based approach @Endpoint(url = \"${config.env.base_url}/users/1\", methodType = HttpMethodType.DELETE) @LinkedInterceptors(classes = { CustomInterceptor.class }) public class DeleteUserMethod extends AbstractApiMethodV2 { } Declarative based approach @EndpointTemplate(url = \"${config.env.base_url}/users\") @LinkedInterceptors(classes = { CustomInterceptor.class }) public interface UserTemplate { @Endpoint(url = \"/\", methodType = HttpMethodType.GET) @LinkedInterceptors(classes = { OtherCustomInterceptor.class }) AbstractApiMethodV2 getAll(); } Then all logic defined in interceptor methods will be called on particular events (once api method is instantiated; once request is ready for sending to endpoint; once endpoint was called). Also it's possible to create global interceptors which will be applied for all api methods by default. Just create a file named com.zebrunner.carina.api.interceptor.ApiMethodInterceptor in /resources/META-INF/services folder and set the path(s) of your implementation(s) into it: com.zebrunner.carina.demo.CustomInterceptor com.zebrunner.carina.demo.OtherCustomInterceptor Wildcards In some cases, you may need to generate data in the request to make the request data unique. The best way to do this is to use wildcards for data generation: { \"username\": \"generate_word(10)\", // Will generate random alphanumeric string with 10 characters \"zip\": \"generate_number(6)\", // Will generate random number with 6 digits \"birthday\": \"generate_date(yyyy-MM-dd;0)\" // Will generate current date (first arg is date format, second is delta in days from now) } Another option is to specify the placeholder in the request template and then pass some generated value directly from the test method. Wildcards are also useful for response validation. In several cases, you may need to skip some values or validate by regex, type, ognl expression or predicate: { \"id\": \"skip\", // Will skip actual value validation and just verify id key presence \"signup_date\": \"regex:\\\\d{4}-\\\\d{2}-\\\\d{2}\", // Will validate date value by specified regex \"age\": \"type:Integer\", // Will validate age value by specified Java type simple name \"annual_income\": \"ognl:#val != null && #val > 10\", // Will validate annual_income value using provided OGNL expression \"created_date\": \"predicate:isDateValid\", // Will validate created_date value by specified name of Predicate which is stored in JsonComparatorContext } OGNL To learn about Apache Object Graph Navigation Library follow this article . Using this option you have the ability to validate a response value with expression approach. Actual value is represented as #val . Also you have an access to full json tree using #root keyword. Predicate This approach provides the ability to validate a response value programmatically. Just create a java.util.function.Predicate and provide it into JsonComparatorContext: JsonComparatorContext comparatorContext = JsonComparatorContext.context() .<String>withPredicate(\"firstNamePredicate\", firstName -> firstName.startsWith(\"Carina\")) .<Integer>withPredicate(\"agePredicate\", age -> age > 18) .<Boolean>withPredicate(\"enabledPredicate\", enabled -> enabled != null && enabled); myApiMethod.validateResponse(comparatorContext); In your json file { \"first_name\": \"predicate:firstNamePredicate\", \"age\": \"predicate:agePredicate\", \"enabled\": \"predicate:enabledPredicate\" } Custom wildcards You have a possibility to implement custom wildcard for response validation as well. All you need is JsonKeywordComparator interface implementation: package com.zebrunner.carina.demo; import com.zebrunner.carina.api.apitools.validation.JsonCompareResultWrapper; import com.zebrunner.carina.api.apitools.validation.JsonKeywordComparator; public class CustomComparator implements JsonKeywordComparator { private static final String MY_KEYWORD = \"my-wildcard:\"; @Override public void compare(String prefix, Object expectedValue, Object actualValue, JsonCompareResultWrapper result) { String expectedWildcardValue = expectedValue.toString().replace(MY_KEYWORD, \"\"); switch (expectedWildcardValue) { case \"isGreaterThanZero\": int number = Integer.parseInt(actualValue.toString()); if (!isGreaterThanZero(number)) { String message = String.format(\"%s\\nActual value '%d' less than or equals to zero\\n\", prefix, number); result.fail(message); } break; case \"hasSemicolon\": String str = actualValue.toString(); if (!hasSemicolon(str)) { String message = String.format(\"%s\\nActual value '%s' doesn't contain semicolon a symbol\\n\", prefix, str); result.fail(message); } break; default: result.compareByDefault(prefix, expectedValue, actualValue); break; } } private boolean isGreaterThanZero(int value) { return value > 0; } private boolean hasSemicolon(String value) { return value.contains(\";\"); } @Override public boolean isMatch(Object expectedValue) { return expectedValue.toString().startsWith(MY_KEYWORD); } } In your json file { \"id\": \"my-wildcard:isGreaterThanZero\", \"email\": \"my-wildcard:hasSemicolon\" } After that you need to register your custom comparator. There are two ways: Using JsonComparatorContext Using this one you will be able to specify your comparators for each validation. JsonComparatorContext comparatorContext = JsonComparatorContext.context() .withComparator(new CustomComparator()) .withComparator(new OtherCustomComparator()); myApiMethod.validateResponse(comparatorContext); Using Service Provider This option provides the ability to register your comparators, which will be always available for response validation, to the whole project. Just create a file named com.zebrunner.carina.api.apitools.validation.JsonKeywordComparator in /resources/META-INF/services folder and set the path(s) of your implementation(s) into it: com.zebrunner.carina.demo.CustomComparator com.zebrunner.carina.demo.OtherCustomComparator Validation against JSON schema When you need to validate response structure regardless of the actual values, you may use validation by JSON schema. In this case, you need an actual response from the service, let's say we have the following: { \"email\": \"test@domain.com\", \"firstName\": \"SOME FIRST NAME\", \"id\": 11111 } Now we need to generate a schema (you may use any generator you like, for example, https://jsonschema.net/). IMPORTANT: For now, the schemas of version draft03 and draft04 are supported only. Please, use the appropriate generator (e.g. https://www.liquid-technologies.com/online-json-to-schema-converter) In the tool like this you need to provide the original JSON from the response, then choose some schema options (allow the additional properties in objects, mark the current object properties as required, hard-code some expected values, etc.) and then generate the schema. Copy-paste the generated schema into test resources, and you're ready to use it in the test. Make sure that you change all the required flags to true. After that, create a new file in the resources and place it into an appropriate endpoint package: { \"type\": \"object\", \"$schema\": \"http://json-schema.org/draft-03/schema\", \"id\": \"http://jsonschema.net\", \"required\": true, \"properties\": { \"email\": { \"type\": \"string\", \"id\": \"http://jsonschema.net/email\", \"required\": true }, \"firstName\": { \"type\": \"string\", \"id\": \"http://jsonschema.net/firstName\", \"required\": true }, \"id\": { \"type\": \"number\", \"id\": \"http://jsonschema.net/id\", \"required\": true } } } And finally, we call JSON validation from Java test as the following: @Test public void testCheckJSONSchema() { PostUserLoginMethod api = new PostUserLoginMethod(); api.expectResponseStatus(HttpResponseStatusType.OK_200); api.callAPI(); api.validateResponseAgainstJSONSchema(\"api/testdata/users/login/_post/rs.schema\"); } Building requests with an array There are a couple of options for building a request with an array of items provided by the framework: 1. The first one uses hardcoded placeholders for changeable variables. { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ { \"name\": \"${task_name_1}\", \"description\": \"${task_description_1}\" } <#if task_name_2?exists || task_description_2?exists>, { \"name\": \"${task_name_2}\", \"description\": \"${task_description_2}\" } </#if> <#if task_name_3?exists || task_description_3?exists>, { \"name\": \"${task_name_3}\", \"description\": \"${task_description_3}\" } </#if> ] } As you see, this structure is quite flexible. If you need 2 taskTypes items, you need to declare at least task_name_2 or task_description_2 property. If you need 3 items in addition to that, you need to declare a task_name_3 or task_description_3 property. Otherwise, the array will contain only 1 item. For instance, you need to build JSON which contains a taskTypes array. Then the template with placeholders will be the following: It's easy to extend such a structure. You just need to add items with similar placeholders increasing their index. Another approach is based on using Freemarker loop. Here is the template example for the same JSON: <#if task_name_1?exists> <#assign task_names = [task_name_1]> <#assign task_descriptions = [task_description_1]> </#if> <#if task_name_2?exists> <#assign task_names = [task_name_1, task_name_2]> <#assign task_descriptions = [task_description_1, task_description_2]> </#if> <#if task_name_3?exists> <#assign task_names = [task_name_1, task_name_2, task_name_3]> <#assign task_descriptions = [task_description_1, task_description_2, task_description_3]> </#if> { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ <#list 0..task_names?size-1 as i> { \"name\": \"${task_names[i]}\", \"description\": \"${task_descriptions[i]}\" } <#sep>, </#sep> </#list> ] } This approach is useful when the structure of an array item is quite complex. So, it makes sense to specify the item attributes only once, doing it inside #list operation. This approach also allows to choose the amount of array items dynamically. But note that you should specify all properties for every item, so this view cannot be used for negative tests when you need to miss some properties. Validation of responses with an array Sometimes you can face a situation when you need to validate the presence of only one item (or a couple of them) in a JSON array ignoring the rest of the items. In such case, you can use a validation option ARRAY_CONTAINS. Here is a code sample: JSONAssert.assertEquals(expectedRs, actualRs, new JsonKeywordsComparator(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey() + \"content\")); The expected array: { \"totalElements\": \"skip\", \"pageNumber\": \"skip\", \"pageSize\": \"skip\", \"content\": [ { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 1\" }, { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 2\" } ] } And the actual response: { \"totalElements\": 1017, \"pageNumber\": 0, \"pageSize\": 100, \"content\": [ { \"id\": 11111, \"brand\": \"test\", \"clientName\": \"CLIENT 1\" }, { \"id\": 22222, \"brand\": \"test\", \"clientName\": \"CLIENT 2\" }, { \"id\": 3333, \"brand\": \"test\", \"clientName\": \"CLIENT 3\" }, { \"id\": 4444, \"brand\": \"test\", \"clientName\": \"CLIENT 4\" } ] } Deserialization of JSON Sometimes you may need to transform your JSON response to POJO. It may be useful if you need to validate your response using the data from a database as the expected data. For this purpose, it's better to use Jackson libraries that are already included in Carina framework. For this, you need to prepare the domain class based on your JSON structure. Some online resources provide such opportunities, like https://timboudreau.com/blog/json/read. Let's say we need to deserialize an array of Clients from JSON. An example of the required domain object will be: import org.codehaus.jackson.annotate.JsonCreator; import org.codehaus.jackson.annotate.JsonProperty; public final class Clients { public final Client[] clients; @JsonCreator public Clients(@JsonProperty(\"clients\") Client[] clients) { this.clients = clients; } public static final class Client { public final long id; public final String brand; public final String clientName; @JsonCreator public Client(@JsonProperty(\"id\") long id, @JsonProperty(\"brand\") String brand, @JsonProperty(\"clientName\") String clientName) { this.id = id; this.brand = brand; this.clientName = clientName; } } public Client[] getClients() { return clients; } } Pay attention that POJO field names can differ from JSON properties. In this case, @JsonProperty annotation can be used for mapping. An example of a deserialization code: GetClientsMethod getClientsMethod = new GetClientsMethod(\"11111\"); getClientsMethod.expectResponseStatus(HttpResponseStatusType.OK_200); String rs = getClientsMethod.callAPI().asString(); ObjectMapper mapper = new ObjectMapper(); Clients clients = mapper.readValue(rs, Clients.class); Then you can use POJO object for any kind of validation or for easy retrieving of the required properties. Security Carina provides some security features that could be used to hide/protect sensitive data in your API calls. Encryption of API method properties It's possible to use default carina crypto logic for automatic decription of sensitive data. In order to encrypt the data you can use carina's CryptoConsole Then you can save your encrypted properties using default pattern: \"{crypt:ENCRYPTED_TXT}\" During properties parsing process carina-api module will automatically decrypt the text and put decrypted value into request body. Hiding of API request headers In order to hide the value of API request header you need to annotate your API method with @HideRequestHeadersInLogs annotation. Usage sample: @HideRequestHeadersInLogs(headers = \"Content-Type\") public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Then in your test logs for mentioned headers you'll get \"[ BLACKLISTED ]\" mask Hiding of API call body parts If you want not to show some sensitive data in body of your api calls in test logs then you'll need to annotate your API method with @HideRequestBodyPartsInLogs/@HideResponseBodyPartsInLogs annotations. These annotations support both json and xml content type. As the value of annotation you need to pass array of JSON or XML paths you want to hide. Once done in test logs you'll get \"********\" mask instead of actual values. Example for json: @HideRequestBodyPartsInLogs(paths = { \"$.[*].username\", \"$.[*].id\" }) @HideResponseBodyPartsInLogs(paths = { \"$.[*].address.zipcode\", \"$.[*].address.geo.lat\", \"$.[*].id\" }) public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Example for xml: @HideRequestBodyPartsInLogs(paths = { \"//root/city/text()\" }) @HideResponseBodyPartsInLogs(paths = { \"//root/state/text()\" }) @ContentType(type = \"application/xml\") public class XmlPostMethod extends AbstractApiMethodV2 { public XmlPostMethod() { } } Important: for XML content type it's obligatory to pass @ContentType annotation to your API method indicating actual header value. If @ContentType is not specified then data will be automatically considered as JSON. SOAP documentation SOAP (Simple Object Access Protocol) is a standards-based web services access protocol. It mostly relies on XML documents. Let\u2019s create some automated SOAP tests on demonstrative Web Service: https://www.crcind.com/csp/samples/SOAP.Demo.cls . AddInteger method adds two integers and returns the result. LookupCity method returns the city and state for the given U.S. ZIP Code packaged within a Sample.Address object First of all, we need to create a request template and response template. It is located in /carina-demo/src/test/resources/api/soap/addinteger. rq.xml <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:tem=\"http://tempuri.org\"> <soapenv:Header/> <soapenv:Body> <tem:AddInteger> <tem:Arg1>${firstNumber}</tem:Arg1> <tem:Arg2>${secondNumber}</tem:Arg2> </tem:AddInteger> </soapenv:Body> </soapenv:Envelope> rs.xml <SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"> <SOAP-ENV:Body> <AddIntegerResponse xmlns=\"http://tempuri.org\"> <#if firstNumber?? and secondNumber??> <AddIntegerResult>${firstNumber+secondNumber}</AddIntegerResult> </#if> </AddIntegerResponse> </SOAP-ENV:Body> </SOAP-ENV:Envelope> This templates contain some placeholders that can be later replaced from properties file. soap.properties #=============== AddInteger properties ===========# firstNumber=4 secondNumber=6 result=10 Now we are ready to create SOAP service domain object which will be used to interact with web service and perform additional response validations. This domain object is located in /carina-demo/src/main/java/com/zebrunner/carina/demo/soap/ , make sure that it extends AbstractApiMethodV2. We can specify the endpoint-url, expected HttpStatus, paths to request and response templates and content type using annotations. LookupCity.java @Endpoint(url = \"${base_url}\", methodType = HttpMethodType.POST) @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) @RequestTemplatePath(path = \"api/soap/lookupcity/rq.xml\") @ResponseTemplatePath(path = \"src/test/resources/api/soap/lookupcity/rs.xml\") @ContentType(type = \"text/xml\") public class LookupCityMethod extends AbstractApiMethodV2 { public LookupCityMethod() { replaceUrlPlaceholder(\"base_url\",Configuration.getEnvArg(\"soap_url\")); } } Then we can create test class with soap test methods. This class is located in /carina-demo/src/test/java/com/zebrunner/carina/demo/ . Test class must implement IAbstractTest. Test methods should start with @Test annotation. To send SOAP request we have to set some request headers. SOAPAction header indicates the intent of the SOAP HTTP request. We can validate the response by Response Status. Also we can use response data and compare it to expected results. SoapSampleTest.java public class SoapSampleTest implements IAbstractTest { @Test public void testAddInteger() { AddIntegerMethod soap = new AddIntegerMethod(); soap.setProperties(\"api/soap/soap.properties\"); soap.setHeaders(String.format(\"SOAPAction=%s\", \"http://tempuri.org/SOAP.Demo.AddInteger\")); Response response = soap.callAPIExpectSuccess(); XmlPath rsBody = XmlPath.given(response.asString()); Integer actualResult = rsBody.getInt(\"AddIntegerResult\"); Integer expectedResult = Integer.valueOf(soap.getProperties().getProperty(\"result\")); Assert.assertEquals(actualResult, expectedResult); } } Method ValidateResponse can be used only with JSON files. To validate the whole xml responses we can use ValidateXMLRespone method. @Test public void testLookupCity() throws Exception{ LookupCityMethod soap = new LookupCityMethod(); soap.setProperties(\"api/soap/soap.properties\"); soap.setHeaders(String.format(\"SOAPAction=%s\", \"http://tempuri.org/SOAP.Demo.LookupCity\")); soap.callAPIExpectSuccess(); soap.validateXmlResponse(XmlCompareMode.STRICT); }","title":"API"},{"location":"automation/api/#pre-requirements","text":"To use api feature, add certain dependency to your pom.xml <dependency> <groupId>com.zebrunner</groupId> <artifactId>carina-api</artifactId> <version>RELEASE</version> </dependency> Visit our github to check the latest version of carina-api.","title":"Pre requirements"},{"location":"automation/api/#example-of-test-implementation","text":"Let's create an automated test for the next call: POST https://jsonplaceholder.typicode.com/users request with a request body [ { \"id\": 1, \"name\": \"SOME_NAME\", \"username\": \"SOME_USERNAME\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"SOME_COMPANY_NAME\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } ] and the response body the same as the request body","title":"Example of test implementation"},{"location":"automation/api/#definition-of-request-and-response-templates","text":"If we are going to send POST request, we need to create a request template with some placeholders that may be replaced by different arguments for different test flows. The best place to store these resources is src/test/resources/api package, try to keep REST hierarchy in a package structure for better maintenance and visibility: Request (rq.json) and response (rs.json) templates have some placeholders that will be populated from the tests later on: While user.properties contains some default value which may be replaced later:","title":"Definition of request and response templates"},{"location":"automation/api/#rest-service-call-domain-object-deprecated","text":"Now we are ready to create REST service domain object which will be used to interact with web service and perform additional response validations. Our domain object is located in /carina-demo/src/main/java/com/zebrunner/carina/demo/api, make sure that it extends AbstractApiMethodV2 and triggers the base class constructor for initialization. In general cases, you will specify the path to request and response templates along with default properties files (all of them have been created in the previous step). Also, we replace the URL placeholder to set an appropriate environment. package com.zebrunner.carina.demo.api; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.utils.Configuration; public class PostUserMethod extends AbstractApiMethodV2 { public PostUserMethod() { super(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } }","title":"REST service call domain object [DEPRECATED]"},{"location":"automation/api/#http-method-and-path-deprecated","text":"The last step before the test implementation itself is the association of the domain object class and the required HTTP method and path. It should be defined in /carina-demo/src/main/resources/_api.properties file, the key should be equal to domain class name, the value has the following pattern {http_method}:{http_path}. The HTTP path may contain placeholders, the HTTP method should be one of the following variants: GET, POST, PUT, UPDATE, DELETE. #=====================================================# #=================== API methods ====================# #=====================================================# GetUserMethods=GET:${base_url}/users PostUserMethod=POST:${base_url}/users DeleteUserMethod=DELETE:${base_url}/users/1 PutPostsMethod=PUT:${base_url}/posts/1 PatchPostsMethod=PATCH:${base_url}/posts/1","title":"HTTP method and path [DEPRECATED]"},{"location":"automation/api/#rest-service-call-domain-object-annotation-based-approach","text":"Approach based on initialisation of super class constructor is deprecated and more convenient way is to use annotations. They can be used over class declarations. For api testing we can use such annotations: @ContentType - is used to define the value of Content-type header in response @Cookie - is used to specify cookies in the request @Endpoint - combination of http method + url which defines any single API endpoint @Header - is used to specify headers in the request @HideRequestBodyPartsInLogs - is used to hide sensitive parts of the request body in the logs @HideRequestHeadersInLogs - is used to hide sensitive parts of the request headers in the logs @HideResponseBodyPartsInLogs - is used to hide secret parts of the response body in the logs @PropertiesPath - contains a path to default properties file for endpoint templates (relative path from root of code sources) @QueryParam - is used to specify query parameters in the request @RequestTemplatePath - contains a path to default request template for mentioned endpoint (relative path from root of code sources) @ResponseTemplatePath - contains a path to default response template for mentioned endpoint (relative path from root of code sources) @SuccessfulHttpStatus - specifies the expected HTTP status for happy-path scenarios In this case we don\u2019t need to define _api.properties file and call the constructor of a super class, but if we have some properties file used in this request we should explicitly set it in test method. Insead of callAPI() and expectResponseStatus() methods we can use callAPIExpectSuccess() that will call API expecting http status in response taken from @SuccessfulHttpStatus value. @Endpoint(url = \"${base_url}/users/1\", methodType = HttpMethodType.DELETE) @RequestTemplatePath(path = \"api/users/_delete/rq.json\") @ResponseTemplatePath(path = \"api/users/_delete/rs.json\") @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) public class DeleteUserMethod extends AbstractApiMethodV2 { public DeleteUserMethod() { replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } } Also placeholders in URL can be automatically replaced by carina if they're specified in carina configuration properties (config.properties). To make auto-replacement happen just use next syntax in your URL: - when param starts with config.\\* then R.CONFIG.get(\"\\*\") will be used as a replacement - when param starts with config.env.\\* then Configuration.getEnvArg(\"\\*\") will be used as a replacement So you may use next implementation: @Endpoint(url = \"${config.env.base_url}/users/1\", methodType = HttpMethodType.DELETE) public class DeleteUserMethod extends AbstractApiMethodV2 { } And before sending of request base part of URL will be set by carina depending on used environment automatically.","title":"REST service call domain object (Annotation based approach)"},{"location":"automation/api/#api-test","text":"API test is a general TestNG test, a class should extend APITest, in our case, the test implements IAbstractTest that encapsulates some test data and login method. The test is located in /carina-demo/src/test/java/com/zebrunner/carina/demo. package com.zebrunner.carina.demo; import java.lang.invoke.MethodHandles; import org.skyscreamer.jsonassert.JSONCompareMode; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.testng.annotations.Test; import com.zebrunner.carina.api.apitools.validation.JsonCompareKeywords; import com.zebrunner.carina.core.IAbstractTest; import com.zebrunner.carina.core.registrar.ownership.MethodOwner; import com.zebrunner.carina.core.registrar.tag.TestPriority; import com.zebrunner.carina.core.foundation.utils.tag.TestPriority; import com.zebrunner.carina.demo.api.DeleteUserMethod; import com.zebrunner.carina.demo.api.GetUserMethods; import com.zebrunner.carina.demo.api.PostUserMethod; /** * This sample shows how create REST API tests. * * @author qpsdemo */ public class APISampleTest implements IAbstractTest { private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() { LOGGER.info(\"test\"); setCases(\"4555,54545\"); PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUserMissingSomeFields() { PostUserMethod api = new PostUserMethod(); api.setProperties(\"api/users/user.properties\"); api.getProperties().remove(\"name\"); api.getProperties().remove(\"username\"); api.callAPIExpectSuccess(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testGetUsers() { GetUserMethods getUsersMethods = new GetUserMethods(); getUsersMethods.callAPIExpectSuccess(); getUsersMethods.validateResponse(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey()); getUsersMethods.validateResponseAgainstSchema(\"api/users/_get/rs.schema\"); } @Test() @MethodOwner(owner = \"qpsdemo\") @TestPriority(Priority.P1) public void testDeleteUsers() { DeleteUserMethod deleteUserMethod = new DeleteUserMethod(); deleteUserMethod.setProperties(\"api/users/user.properties\"); deleteUserMethod.callAPIExpectSuccess(); deleteUserMethod.validateResponse(); } }","title":"API test"},{"location":"automation/api/#test-steps-once-again","text":"Create REST call object Specify the properties for a request/response placeholder Add headers if required Specify the expected HTTP status Call API Validate the response by a template or parse some data by JSON path Make further calls using the data from the previous call if needed","title":"Test steps once again"},{"location":"automation/api/#rest-service-call-domain-object-declarative-approach","text":"Approach based on implicit instantiation of the AbstractApiMethod . It allows to: - more convenient and efficiently organize description of endpoints; - have all carina api methods for the same URL pattern be defined within single class; - reduce time for the implementation of the desired AbstractApiMethod ; - flexibly configure all api methods with Java annotations. Here is example of multiple api methods definition for one url pattern. Base url template can be easily overwritten with use of @EndpointTemplateMethod annotation: package com.zebrunner.carina.demo.api; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.annotation.EndpointTemplate; import com.zebrunner.carina.api.annotation.EndpointTemplateMethod; import com.zebrunner.carina.api.annotation.PathParam; import com.zebrunner.carina.api.annotation.PropertiesPath; import com.zebrunner.carina.api.annotation.RequestTemplatePath; import com.zebrunner.carina.api.annotation.ResponseTemplatePath; import com.zebrunner.carina.api.annotation.SuccessfulHttpStatus; import com.zebrunner.carina.api.annotation.method.DeleteMethod; import com.zebrunner.carina.api.http.HttpMethodType; import com.zebrunner.carina.api.http.HttpResponseStatusType; @EndpointTemplate(url = \"${config.env.base_url}/users\") public interface UserTemplate { @EndpointTemplateMethod(url = \"/\", methodType = HttpMethodType.POST) AbstractApiMethodV2 create(@RequestTemplatePath.Value String rqPath, @ResponseTemplatePath.Value String rsPath, @PropertiesPath.Value String propsPath); @EndpointTemplateMethod(url = \"/\", methodType = HttpMethodType.GET) @ResponseTemplatePath(path = \"api/users/_get/rs.json\") @PropertiesPath(path = \"api/users/user.properties\") AbstractApiMethodV2 getAll(); @DeleteMethod(url = \"/${id}\") @RequestTemplatePath(path = \"api/users/_delete/rq.json\") @ResponseTemplatePath(path = \"api/users/_delete/rs.json\") @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) AbstractApiMethodV2 deleteById(@PathParam(key = \"id\") Long id); } All the annotations of the Annotation based approach work here as well ( Important: except the @Endpoint annotation). In this approach it is possible to use these annotations not only on the class but also on the method level. In addition, you can apply the following annotations: @Cookie.Value - is used to specify cookies in the request (for use with method's parameters) @EndpointTemplate - defines the basic part of the request URL. This part will be a basic one for every inner method. @EndpointTemplateMethod - defines relative part of the request URL. This part will be concatenated with the EndpointTemplate path (if defined) @Header.Value - is used to specify headers in the request (for use with method's parameters) @PathParam - is used to specify named URL placeholder value. Placeholder will be replaced automatically (for use with method's parameters) @PropertiesPath.Value - contains a path to default properties file for endpoint templates (for use with method's parameters) @Property - is used to specify additional properties. These properties will be automatically added to the future method instance (for use with method's parameters) @QueryParam.Value - is used to specify URL query parameters. These query parameters will be automatically added to the URL (for use with method's parameters) @RequestTemplatePath.Value - contains a path to default request template for mentioned endpoint (for use with method's parameters) @ResponseTemplatePath.Value - contains a path to default response template for mentioned endpoint (for use with method's parameters) @SuccessfulHttpStatus.Value - specifies the expected HTTP status for happy-path scenarios (for use with method's parameters) There is also \"syntactic sugar\" available for making the EndpointTemplateMethod annotation more readable: 1. @GetMethod - endpoint template with GET method 2. @PostMethod - endpoint template with POST method 3. @PutMethod - endpoint template with PUT method 4. @PatchMethod - endpoint template with PATCH method 5. @DeleteMethod - endpoint template with DELETE method 6. @HeadMethod - endpoint template with HEAD method 7. @OptionsMethod - endpoint template with OPTIONS method Now you can invoke a prepareTemplate method from TemplateFactory to use proxy implementation in the test: @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() { UserTemplate userTemplate = TemplateFactory.prepareTemplate(UserTemplate.class); PostUserMethod api = userTemplate.create(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } For more customization on api method definition level you can implement the interface and use the proxy class inside: package com.zebrunner.carina.demo.api.impl; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.binding.TemplateFactory; import com.zebrunner.carina.demo.api.UserTemplate; public class UserTemplateImpl implements UserTemplate { private final UserTemplate userTemplate; public UserTemplateImpl(UserTemplate userTemplate) { this.userTemplate = TemplateFactory.prepareTemplate(UserTemplate.class); } @Override public AbstractApiMethodV2 create(String rqPath, String rsPath, String propsPath) { AbstractApiMethodV2 apiMethod = userTemplate.create(rqPath, rsPath, propsPath); apiMethod.addProperty(\"prop\", \"val\"); return apiMethod; } @Override public AbstractApiMethodV2 getAll() { AbstractApiMethodV2 apiMethod = userTemplate.getAll(); apiMethod.addCookie(\"cookie\", \"val\"); return apiMethod; } @Override public AbstractApiMethodV2 deleteById(Long id) { AbstractApiMethodV2 apiMethod = userTemplate.deleteById(id); apiMethod.setHeader(\"header\", \"val\"); return apiMethod; } } To perform the general logic under multiple API templates you can create interceptors .","title":"REST service call domain object (Declarative approach)"},{"location":"automation/api/#useful-features","text":"The framework contains a list of useful features for building requests and validation of responses. It makes the support of such tests easier and at the same time minimizes the amount of test data.","title":"Useful features"},{"location":"automation/api/#repeating-api-calling-with-the-condition","text":"Sometimes we should do a lot of API calls waiting for particular artifact in response. In this case, you can use callAPIWithRetry method in AbstractApiMethodV2 class. This method provides us an object of APIMethodPoller class. Methods of this object give us an ability to set an interval for api calling, timeout, logging strategy, actions that should be executed immediately after the api calling, condition under which the response is considered successful, action that will be executed after all api callings. Example of using: @Test public void testCreateUserWaitingResponseContainsAddress() { PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); Optional<Response> response = api.callAPIWithRetry() .withLogStrategy(APIMethodPoller.LogStrategy.LAST_ONLY) .until(rs -> rs.getBody().asString().contains(\"address\")) .execute(); api.validateResponse(); Assert.assertFalse(response.isEmpty(), \"Response should exists\"); }","title":"Repeating API calling with the condition"},{"location":"automation/api/#handling-and-changing-abstractapimethod-on-the-fly","text":"This option provides the ability for handling and changing of your AbstractApiMethod instances on-the-fly. For that it's needed to create an implementation of ApiMethodInterceptor interface: package com.zebrunner.carina.demo.api.interceptor; import com.zebrunner.carina.api.AbstractApiMethodV2; import com.zebrunner.carina.api.interceptor.ApiMethodInterceptor; public class CustomInterceptor implements ApiMethodInterceptor<AbstractApiMethodV2> { @Override public void onInstantiation(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been instantiated } @Override public void onBeforeCall(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been created } @Override public void onAfterCall(AbstractApiMethodV2 apiMethod) { // do something with an API method after it has been called } } and add this class into @LinkedInterceptors annotation for your api method: Annotation based approach @Endpoint(url = \"${config.env.base_url}/users/1\", methodType = HttpMethodType.DELETE) @LinkedInterceptors(classes = { CustomInterceptor.class }) public class DeleteUserMethod extends AbstractApiMethodV2 { } Declarative based approach @EndpointTemplate(url = \"${config.env.base_url}/users\") @LinkedInterceptors(classes = { CustomInterceptor.class }) public interface UserTemplate { @Endpoint(url = \"/\", methodType = HttpMethodType.GET) @LinkedInterceptors(classes = { OtherCustomInterceptor.class }) AbstractApiMethodV2 getAll(); } Then all logic defined in interceptor methods will be called on particular events (once api method is instantiated; once request is ready for sending to endpoint; once endpoint was called). Also it's possible to create global interceptors which will be applied for all api methods by default. Just create a file named com.zebrunner.carina.api.interceptor.ApiMethodInterceptor in /resources/META-INF/services folder and set the path(s) of your implementation(s) into it: com.zebrunner.carina.demo.CustomInterceptor com.zebrunner.carina.demo.OtherCustomInterceptor","title":"Handling and changing AbstractApiMethod on-the-fly"},{"location":"automation/api/#wildcards","text":"In some cases, you may need to generate data in the request to make the request data unique. The best way to do this is to use wildcards for data generation: { \"username\": \"generate_word(10)\", // Will generate random alphanumeric string with 10 characters \"zip\": \"generate_number(6)\", // Will generate random number with 6 digits \"birthday\": \"generate_date(yyyy-MM-dd;0)\" // Will generate current date (first arg is date format, second is delta in days from now) } Another option is to specify the placeholder in the request template and then pass some generated value directly from the test method. Wildcards are also useful for response validation. In several cases, you may need to skip some values or validate by regex, type, ognl expression or predicate: { \"id\": \"skip\", // Will skip actual value validation and just verify id key presence \"signup_date\": \"regex:\\\\d{4}-\\\\d{2}-\\\\d{2}\", // Will validate date value by specified regex \"age\": \"type:Integer\", // Will validate age value by specified Java type simple name \"annual_income\": \"ognl:#val != null && #val > 10\", // Will validate annual_income value using provided OGNL expression \"created_date\": \"predicate:isDateValid\", // Will validate created_date value by specified name of Predicate which is stored in JsonComparatorContext } OGNL To learn about Apache Object Graph Navigation Library follow this article . Using this option you have the ability to validate a response value with expression approach. Actual value is represented as #val . Also you have an access to full json tree using #root keyword. Predicate This approach provides the ability to validate a response value programmatically. Just create a java.util.function.Predicate and provide it into JsonComparatorContext: JsonComparatorContext comparatorContext = JsonComparatorContext.context() .<String>withPredicate(\"firstNamePredicate\", firstName -> firstName.startsWith(\"Carina\")) .<Integer>withPredicate(\"agePredicate\", age -> age > 18) .<Boolean>withPredicate(\"enabledPredicate\", enabled -> enabled != null && enabled); myApiMethod.validateResponse(comparatorContext); In your json file { \"first_name\": \"predicate:firstNamePredicate\", \"age\": \"predicate:agePredicate\", \"enabled\": \"predicate:enabledPredicate\" }","title":"Wildcards"},{"location":"automation/api/#custom-wildcards","text":"You have a possibility to implement custom wildcard for response validation as well. All you need is JsonKeywordComparator interface implementation: package com.zebrunner.carina.demo; import com.zebrunner.carina.api.apitools.validation.JsonCompareResultWrapper; import com.zebrunner.carina.api.apitools.validation.JsonKeywordComparator; public class CustomComparator implements JsonKeywordComparator { private static final String MY_KEYWORD = \"my-wildcard:\"; @Override public void compare(String prefix, Object expectedValue, Object actualValue, JsonCompareResultWrapper result) { String expectedWildcardValue = expectedValue.toString().replace(MY_KEYWORD, \"\"); switch (expectedWildcardValue) { case \"isGreaterThanZero\": int number = Integer.parseInt(actualValue.toString()); if (!isGreaterThanZero(number)) { String message = String.format(\"%s\\nActual value '%d' less than or equals to zero\\n\", prefix, number); result.fail(message); } break; case \"hasSemicolon\": String str = actualValue.toString(); if (!hasSemicolon(str)) { String message = String.format(\"%s\\nActual value '%s' doesn't contain semicolon a symbol\\n\", prefix, str); result.fail(message); } break; default: result.compareByDefault(prefix, expectedValue, actualValue); break; } } private boolean isGreaterThanZero(int value) { return value > 0; } private boolean hasSemicolon(String value) { return value.contains(\";\"); } @Override public boolean isMatch(Object expectedValue) { return expectedValue.toString().startsWith(MY_KEYWORD); } } In your json file { \"id\": \"my-wildcard:isGreaterThanZero\", \"email\": \"my-wildcard:hasSemicolon\" } After that you need to register your custom comparator. There are two ways: Using JsonComparatorContext Using this one you will be able to specify your comparators for each validation. JsonComparatorContext comparatorContext = JsonComparatorContext.context() .withComparator(new CustomComparator()) .withComparator(new OtherCustomComparator()); myApiMethod.validateResponse(comparatorContext); Using Service Provider This option provides the ability to register your comparators, which will be always available for response validation, to the whole project. Just create a file named com.zebrunner.carina.api.apitools.validation.JsonKeywordComparator in /resources/META-INF/services folder and set the path(s) of your implementation(s) into it: com.zebrunner.carina.demo.CustomComparator com.zebrunner.carina.demo.OtherCustomComparator","title":"Custom wildcards"},{"location":"automation/api/#validation-against-json-schema","text":"When you need to validate response structure regardless of the actual values, you may use validation by JSON schema. In this case, you need an actual response from the service, let's say we have the following: { \"email\": \"test@domain.com\", \"firstName\": \"SOME FIRST NAME\", \"id\": 11111 } Now we need to generate a schema (you may use any generator you like, for example, https://jsonschema.net/). IMPORTANT: For now, the schemas of version draft03 and draft04 are supported only. Please, use the appropriate generator (e.g. https://www.liquid-technologies.com/online-json-to-schema-converter) In the tool like this you need to provide the original JSON from the response, then choose some schema options (allow the additional properties in objects, mark the current object properties as required, hard-code some expected values, etc.) and then generate the schema. Copy-paste the generated schema into test resources, and you're ready to use it in the test. Make sure that you change all the required flags to true. After that, create a new file in the resources and place it into an appropriate endpoint package: { \"type\": \"object\", \"$schema\": \"http://json-schema.org/draft-03/schema\", \"id\": \"http://jsonschema.net\", \"required\": true, \"properties\": { \"email\": { \"type\": \"string\", \"id\": \"http://jsonschema.net/email\", \"required\": true }, \"firstName\": { \"type\": \"string\", \"id\": \"http://jsonschema.net/firstName\", \"required\": true }, \"id\": { \"type\": \"number\", \"id\": \"http://jsonschema.net/id\", \"required\": true } } } And finally, we call JSON validation from Java test as the following: @Test public void testCheckJSONSchema() { PostUserLoginMethod api = new PostUserLoginMethod(); api.expectResponseStatus(HttpResponseStatusType.OK_200); api.callAPI(); api.validateResponseAgainstJSONSchema(\"api/testdata/users/login/_post/rs.schema\"); }","title":"Validation against JSON schema"},{"location":"automation/api/#building-requests-with-an-array","text":"There are a couple of options for building a request with an array of items provided by the framework: 1. The first one uses hardcoded placeholders for changeable variables. { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ { \"name\": \"${task_name_1}\", \"description\": \"${task_description_1}\" } <#if task_name_2?exists || task_description_2?exists>, { \"name\": \"${task_name_2}\", \"description\": \"${task_description_2}\" } </#if> <#if task_name_3?exists || task_description_3?exists>, { \"name\": \"${task_name_3}\", \"description\": \"${task_description_3}\" } </#if> ] } As you see, this structure is quite flexible. If you need 2 taskTypes items, you need to declare at least task_name_2 or task_description_2 property. If you need 3 items in addition to that, you need to declare a task_name_3 or task_description_3 property. Otherwise, the array will contain only 1 item. For instance, you need to build JSON which contains a taskTypes array. Then the template with placeholders will be the following: It's easy to extend such a structure. You just need to add items with similar placeholders increasing their index. Another approach is based on using Freemarker loop. Here is the template example for the same JSON: <#if task_name_1?exists> <#assign task_names = [task_name_1]> <#assign task_descriptions = [task_description_1]> </#if> <#if task_name_2?exists> <#assign task_names = [task_name_1, task_name_2]> <#assign task_descriptions = [task_description_1, task_description_2]> </#if> <#if task_name_3?exists> <#assign task_names = [task_name_1, task_name_2, task_name_3]> <#assign task_descriptions = [task_description_1, task_description_2, task_description_3]> </#if> { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ <#list 0..task_names?size-1 as i> { \"name\": \"${task_names[i]}\", \"description\": \"${task_descriptions[i]}\" } <#sep>, </#sep> </#list> ] } This approach is useful when the structure of an array item is quite complex. So, it makes sense to specify the item attributes only once, doing it inside #list operation. This approach also allows to choose the amount of array items dynamically. But note that you should specify all properties for every item, so this view cannot be used for negative tests when you need to miss some properties.","title":"Building requests with an array"},{"location":"automation/api/#validation-of-responses-with-an-array","text":"Sometimes you can face a situation when you need to validate the presence of only one item (or a couple of them) in a JSON array ignoring the rest of the items. In such case, you can use a validation option ARRAY_CONTAINS. Here is a code sample: JSONAssert.assertEquals(expectedRs, actualRs, new JsonKeywordsComparator(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey() + \"content\")); The expected array: { \"totalElements\": \"skip\", \"pageNumber\": \"skip\", \"pageSize\": \"skip\", \"content\": [ { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 1\" }, { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 2\" } ] } And the actual response: { \"totalElements\": 1017, \"pageNumber\": 0, \"pageSize\": 100, \"content\": [ { \"id\": 11111, \"brand\": \"test\", \"clientName\": \"CLIENT 1\" }, { \"id\": 22222, \"brand\": \"test\", \"clientName\": \"CLIENT 2\" }, { \"id\": 3333, \"brand\": \"test\", \"clientName\": \"CLIENT 3\" }, { \"id\": 4444, \"brand\": \"test\", \"clientName\": \"CLIENT 4\" } ] }","title":"Validation of responses with an array"},{"location":"automation/api/#deserialization-of-json","text":"Sometimes you may need to transform your JSON response to POJO. It may be useful if you need to validate your response using the data from a database as the expected data. For this purpose, it's better to use Jackson libraries that are already included in Carina framework. For this, you need to prepare the domain class based on your JSON structure. Some online resources provide such opportunities, like https://timboudreau.com/blog/json/read. Let's say we need to deserialize an array of Clients from JSON. An example of the required domain object will be: import org.codehaus.jackson.annotate.JsonCreator; import org.codehaus.jackson.annotate.JsonProperty; public final class Clients { public final Client[] clients; @JsonCreator public Clients(@JsonProperty(\"clients\") Client[] clients) { this.clients = clients; } public static final class Client { public final long id; public final String brand; public final String clientName; @JsonCreator public Client(@JsonProperty(\"id\") long id, @JsonProperty(\"brand\") String brand, @JsonProperty(\"clientName\") String clientName) { this.id = id; this.brand = brand; this.clientName = clientName; } } public Client[] getClients() { return clients; } } Pay attention that POJO field names can differ from JSON properties. In this case, @JsonProperty annotation can be used for mapping. An example of a deserialization code: GetClientsMethod getClientsMethod = new GetClientsMethod(\"11111\"); getClientsMethod.expectResponseStatus(HttpResponseStatusType.OK_200); String rs = getClientsMethod.callAPI().asString(); ObjectMapper mapper = new ObjectMapper(); Clients clients = mapper.readValue(rs, Clients.class); Then you can use POJO object for any kind of validation or for easy retrieving of the required properties.","title":"Deserialization of JSON"},{"location":"automation/api/#security","text":"Carina provides some security features that could be used to hide/protect sensitive data in your API calls.","title":"Security"},{"location":"automation/api/#encryption-of-api-method-properties","text":"It's possible to use default carina crypto logic for automatic decription of sensitive data. In order to encrypt the data you can use carina's CryptoConsole Then you can save your encrypted properties using default pattern: \"{crypt:ENCRYPTED_TXT}\" During properties parsing process carina-api module will automatically decrypt the text and put decrypted value into request body.","title":"Encryption of API method properties"},{"location":"automation/api/#hiding-of-api-request-headers","text":"In order to hide the value of API request header you need to annotate your API method with @HideRequestHeadersInLogs annotation. Usage sample: @HideRequestHeadersInLogs(headers = \"Content-Type\") public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Then in your test logs for mentioned headers you'll get \"[ BLACKLISTED ]\" mask","title":"Hiding of API request headers"},{"location":"automation/api/#hiding-of-api-call-body-parts","text":"If you want not to show some sensitive data in body of your api calls in test logs then you'll need to annotate your API method with @HideRequestBodyPartsInLogs/@HideResponseBodyPartsInLogs annotations. These annotations support both json and xml content type. As the value of annotation you need to pass array of JSON or XML paths you want to hide. Once done in test logs you'll get \"********\" mask instead of actual values. Example for json: @HideRequestBodyPartsInLogs(paths = { \"$.[*].username\", \"$.[*].id\" }) @HideResponseBodyPartsInLogs(paths = { \"$.[*].address.zipcode\", \"$.[*].address.geo.lat\", \"$.[*].id\" }) public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Example for xml: @HideRequestBodyPartsInLogs(paths = { \"//root/city/text()\" }) @HideResponseBodyPartsInLogs(paths = { \"//root/state/text()\" }) @ContentType(type = \"application/xml\") public class XmlPostMethod extends AbstractApiMethodV2 { public XmlPostMethod() { } } Important: for XML content type it's obligatory to pass @ContentType annotation to your API method indicating actual header value. If @ContentType is not specified then data will be automatically considered as JSON.","title":"Hiding of API call body parts"},{"location":"automation/api/#soap-documentation","text":"SOAP (Simple Object Access Protocol) is a standards-based web services access protocol. It mostly relies on XML documents. Let\u2019s create some automated SOAP tests on demonstrative Web Service: https://www.crcind.com/csp/samples/SOAP.Demo.cls . AddInteger method adds two integers and returns the result. LookupCity method returns the city and state for the given U.S. ZIP Code packaged within a Sample.Address object First of all, we need to create a request template and response template. It is located in /carina-demo/src/test/resources/api/soap/addinteger.","title":"SOAP documentation"},{"location":"automation/api/#rqxml","text":"<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:tem=\"http://tempuri.org\"> <soapenv:Header/> <soapenv:Body> <tem:AddInteger> <tem:Arg1>${firstNumber}</tem:Arg1> <tem:Arg2>${secondNumber}</tem:Arg2> </tem:AddInteger> </soapenv:Body> </soapenv:Envelope> rs.xml <SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"> <SOAP-ENV:Body> <AddIntegerResponse xmlns=\"http://tempuri.org\"> <#if firstNumber?? and secondNumber??> <AddIntegerResult>${firstNumber+secondNumber}</AddIntegerResult> </#if> </AddIntegerResponse> </SOAP-ENV:Body> </SOAP-ENV:Envelope> This templates contain some placeholders that can be later replaced from properties file.","title":"rq.xml"},{"location":"automation/api/#soapproperties","text":"#=============== AddInteger properties ===========# firstNumber=4 secondNumber=6 result=10 Now we are ready to create SOAP service domain object which will be used to interact with web service and perform additional response validations. This domain object is located in /carina-demo/src/main/java/com/zebrunner/carina/demo/soap/ , make sure that it extends AbstractApiMethodV2. We can specify the endpoint-url, expected HttpStatus, paths to request and response templates and content type using annotations. LookupCity.java @Endpoint(url = \"${base_url}\", methodType = HttpMethodType.POST) @SuccessfulHttpStatus(status = HttpResponseStatusType.OK_200) @RequestTemplatePath(path = \"api/soap/lookupcity/rq.xml\") @ResponseTemplatePath(path = \"src/test/resources/api/soap/lookupcity/rs.xml\") @ContentType(type = \"text/xml\") public class LookupCityMethod extends AbstractApiMethodV2 { public LookupCityMethod() { replaceUrlPlaceholder(\"base_url\",Configuration.getEnvArg(\"soap_url\")); } } Then we can create test class with soap test methods. This class is located in /carina-demo/src/test/java/com/zebrunner/carina/demo/ . Test class must implement IAbstractTest. Test methods should start with @Test annotation. To send SOAP request we have to set some request headers. SOAPAction header indicates the intent of the SOAP HTTP request. We can validate the response by Response Status. Also we can use response data and compare it to expected results. SoapSampleTest.java public class SoapSampleTest implements IAbstractTest { @Test public void testAddInteger() { AddIntegerMethod soap = new AddIntegerMethod(); soap.setProperties(\"api/soap/soap.properties\"); soap.setHeaders(String.format(\"SOAPAction=%s\", \"http://tempuri.org/SOAP.Demo.AddInteger\")); Response response = soap.callAPIExpectSuccess(); XmlPath rsBody = XmlPath.given(response.asString()); Integer actualResult = rsBody.getInt(\"AddIntegerResult\"); Integer expectedResult = Integer.valueOf(soap.getProperties().getProperty(\"result\")); Assert.assertEquals(actualResult, expectedResult); } } Method ValidateResponse can be used only with JSON files. To validate the whole xml responses we can use ValidateXMLRespone method. @Test public void testLookupCity() throws Exception{ LookupCityMethod soap = new LookupCityMethod(); soap.setProperties(\"api/soap/soap.properties\"); soap.setHeaders(String.format(\"SOAPAction=%s\", \"http://tempuri.org/SOAP.Demo.LookupCity\")); soap.callAPIExpectSuccess(); soap.validateXmlResponse(XmlCompareMode.STRICT); }","title":"soap.properties"},{"location":"automation/mobile/","text":"Carina framework provides a useful and elegant way of Mobile (Android and iOS) Test Automation. The best practices have a lot in common with web automation, so it's highly recommended to look through Web automation article . Mobile special requirements: To run mobile tests, Appium is used instead of Selenium. There are 2 versions of Appium: desktop and console ones, and both are good for Carina. Appium must be running every time before the test run. Android special requirements: Android SDK (part of Android Studio ) is an important component for work. Pay attention that after installing Android Studio you sometimes (depends on a version) need to additionally install ADB (Mac only). Edit your PATH variable and add ANDROID_HOME (path to \"sdk\" folder) to PATH. Sometimes (mostly on Mac) need to add paths to important folders inside sdk, such as \"platform-tools\" (ADB is located here), \"tools\" and \"build-tools\". apk file - installation file of a program that's being tested is required, the same for both - a real device and an emulator. iOS special requirements: Xcode is a vital component for work so iOS testing is available only on Mac OS. Installation file of a program that's being tested is required. For a real device it's ipa file, and for a simulator it is app file. App file should be provided by developers and has special signatures to work correctly. Mobile config properties We can provide any Appium capability in the _config.properties file using capabilities.name=value format. In the table below we are providing the description of the most popular mobile capabilities: Attribute Meaning Default value Example capabilities.deviceName Device name for report n/a Sumsung_Galaxy_J5 capabilities.deviceType The only custom Carina capability to determine the type of a device n/a phone/tablet/tv... capabilities.platformName Name of the mobile platform n/a Android/iOS/AndroidTV/tvOS capabilities.platformVersion Version of the mobile platform n/a 6.0.1 capabilities.app Path to the application (apk/app/ipa) which is tested, can be provided as a pattern from AWS S3 storage with automatic downloading n/a D:/application.apk, s3://qaprosoft.com/android/myapk.*-release.apk capabilities.newCommandTimeout New implicit timeout in seconds to wait for the element for mobile automation n/a 180 capabilities.udid Unique Device ID n/a 759b543c capabilities.appActivity Activity name for the Android activity you want to launch from your package. n/a com.amazon.mShop.HomeActivity capabilities.appPackage Java package of the Android app you want to run n/a in.amazon.mShop.android.shopping capabilities.noSign Skips checking and signing of the app with debug keys, will work only with UiAutomator and not with selendroid, defaults to false n/a true, false capabilities.autoGrantPermissions Has Appium automatically determine which permissions your app requires and grants them to the app on install. Defaults to false n/a true, false Actual list of Appium capabilities can be found here . Example for Android of _config.properties: selenium_url=http://localhost:4723/wd/hub #============ Android Local Mobile ===================# capabilities.platformName=ANDROID capabilities.deviceName=Nexus_6 capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.noSign=true capabilities.autoGrantPermissions=true #=====================================================# Example for iOS of _config.properties: selenium_url=http://localhost:4723/wd/hub #======== Local Run for iOS Mobile ===============# capabilities.platformName=iOS capabilities.deviceName=iPhone X capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip #=====================================================# Implementation of Page Objects: The main idea is the same as in web-testing . How to find locators for Android application To obtain the locators of elements from an Android app different programs are used such as Appium itself or convenient Android SDK tool: uiautomatorviewer . Example: @FindBy(xpath = \"//*[@resource-id='name_input']\") private ExtendedWebElement input; How to find locators for iOS application To obtain the locators of elements from an iOS app different programs are used such as Appium itself or convenient Macaca App Inspector . To speed up element detection @Predicate annotation can be used used. Complicate \"xpath\" can't be used with predicates. Example: @FindBy(xpath = \"name = 'DONE'\") @Predicate protected ExtendedWebElement doneButton; Another possibility to find the element is to use @ClassChain annotation. Example: @FindBy(xpath = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") @ClassChain protected ExtendedWebElement developerText; Starting from Carina version 6.0.12, it's recommended to use @ExtendedFindBy() annotation. Example: @ExtendedFindBy(iosClassChain = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") protected ExtendedWebElement developerText; or @ExtendedFindBy(iosPredicate = \"name = 'DONE'\") protected ExtendedWebElement developerText; Implementation of tests Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class SampleTest implements IAbstractTest { String name = \"My name\"; String carName = \"Mercedes\"; @Test() public void sendName() { FirstPage firstPage = new FirstPage(getDriver()); firstPage.clickOnGooleButton(); GoogleTestPage googleTestPage = new GoogleTestPage(getDriver()); googleTestPage.setName(name); googleTestPage.clickOnSpinner(); googleTestPage.selectCar(carName); googleTestPage.clickOnSendYourNameButton(); MyWayOfHelloPage myWayOfHelloPage = new MyWayOfHelloPage(getDriver()); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(name), \"Assert message\" ); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(carName.toLowerCase()), \"Assert message\" ); } } Important: * Test class should implement com.zebrunner.carina.core.IAbstractTest * Test method should start with org.testng.annotations.Test annotation * Use getDriver() method to get driver instance in test * Locate tests in src/test/java source folder How to use CustomTypePageFactory Carina provides the technique to combine Desktop/iOS/Android tests into the single test class/method. For all platforms you should use Page Object Design Pattern , but in a bit improved way. Every page has an abstract declaration and different implementations if needed (by default, 3 ones should be enough: Desktop, iOS/Android): Common abstract page in a common package with common methods and elements; Desktop page in a desktop package with desktop methods and elements; iOS page in ios package with iOS methods and elements; Android page in android package with Android methods and elements. Children pages should extend BasePage implementing all abstract methods. Annotation @DeviceType will provide the information about the device type and the parent (common) page. Examples: Common (Base) Page public abstract class HomePageBase extends AbstractPage { public HomePageBase(WebDriver driver) { super(driver); } public abstract PhoneFinderPageBase openPhoneFinder(); public abstract ComparePageBase openComparePage(); } Android Page @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='Phone Finder']\") protected ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='compare']\") protected ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } iOS Page @DeviceType(pageType = Type.IOS_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"name = 'Phone Finder'\") @Predicate private ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"name = 'Compare'\") @Predicate private ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } } Inside every test, Carina operates with an abstract base page using CustomTypePageFactory and substitutes it by the real implementation based on the desired capabilities in _config.properties etc. Example: @Test public void comparePhonesTest() { HomePageBase homePage = CustomTypePageFactory.initPage(getDriver(), HomePageBase.class); ComparePageBase phoneFinderPage = homePage.openCompare(); ... } If there are differences in application according to OS version, just implement the pages for different versions and include the version parameter in @DeviceType for every page. Example: For Android 8 (either 8.0 or 8.1) @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { ... } Or for a specific version @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8.1\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { ... } How to use Find by Image strategy Find by image strategy is based on appium implementation . Be sure you have OpenCV libraries installed to your system . Find by image logic is covered by @ExtendedFindBy annotation. Example: @ExtendedFindBy(image = \"images/singUp6.png\") private ExtendedWebElement signUpBtn; The list of actions with image elements and related driver settings is available here . Basically, all you need is to create an image template of the element in .png format and place it to your project. We suggest using src/main/resources/ folder to store images. Be sure your image size is less than the real screen size. Real iOS screen sizes are listed here in 'UIKit Size (Points)' column. You can also find the ultimate guide to iPhone resolutions here . How to change context of application In carina-demo there is an example of a tool , that can change context of application. Just add needed context as a field in View enum. // for example NATIVE(\"NATIVE_APP\"), WEB1(\"WEBVIEW_chromeapp\"), WEB2(\"WEBVIEW_opera\"); Then change context in your test/page class where needed. public void testWebView() { WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); LoginPageBase loginPage = welcomePage.clickNextBtn(); loginPage.login(); WebViewPageBase webViewPageBase = initPage(getDriver(), WebViewPageBase.class); MobileContextUtils contextHelper = new MobileContextUtils(); contextHelper.switchMobileContext(View.WEB); ContactUsPageBase contactUsPage = webViewPageBase.goToContactUsPage(); contactUsPage.typeName(\"John Doe\"); contactUsPage.typeEmail(\"some@email.com\"); contactUsPage.typeQuestion(\"This is a message\"); contactUsPage.submit(); Assert.assertTrue(contactUsPage.isErrorMessagePresent() || contactUsPage.isRecaptchaPresent(), \"Error message or captcha was not displayed\"); } What if the mobile app link points to Amazon / Azure/ AppCenter / other When the driver starts, a link to the application is taken from the capabilities. The type of link determines how to process it and get the final (for example, pre-assign) link which will be used when starting the driver instead of the original. If you provide a link to an application located on Amazon, then add the dependency com.zebrunner.carina-aws-s3 , Azure - com.zebrunner.carina-azure , AppCenter - com.zebrunner.carina-appcenter . You can also create your own implementation of getting the final link to the mobile application: Create a class that implements the com.zebrunner.carina.commons.artifact.IArtifactManager interface (from com.zebrunner.carina-commons dependency). The getDirectLink method just transforms the link to the final. Create a class that implements the com.zebrunner.carina.commons.artifact.IArtifactManagerFactory interface and annotate it by com.zebrunner.carina.commons.artifact.ArtifactManagerFactory . So this class will be discovered by Carina Framework at runtime. If Carina Framework does not find a suitable artifact manager to generate final link, then the link will be passed to the driver as is. FAQ Where can I find mobile-specific methods? IMobileUtils - contains methods for interacting with both IOS and Android devices IAndroidUtils , AndroidService - contains methods for interacting with Android devices only IOSUtils - contains methods for interacting with IOS devices only","title":"Mobile"},{"location":"automation/mobile/#mobile-special-requirements","text":"To run mobile tests, Appium is used instead of Selenium. There are 2 versions of Appium: desktop and console ones, and both are good for Carina. Appium must be running every time before the test run.","title":"Mobile special requirements:"},{"location":"automation/mobile/#android-special-requirements","text":"Android SDK (part of Android Studio ) is an important component for work. Pay attention that after installing Android Studio you sometimes (depends on a version) need to additionally install ADB (Mac only). Edit your PATH variable and add ANDROID_HOME (path to \"sdk\" folder) to PATH. Sometimes (mostly on Mac) need to add paths to important folders inside sdk, such as \"platform-tools\" (ADB is located here), \"tools\" and \"build-tools\". apk file - installation file of a program that's being tested is required, the same for both - a real device and an emulator.","title":"Android special requirements:"},{"location":"automation/mobile/#ios-special-requirements","text":"Xcode is a vital component for work so iOS testing is available only on Mac OS. Installation file of a program that's being tested is required. For a real device it's ipa file, and for a simulator it is app file. App file should be provided by developers and has special signatures to work correctly.","title":"iOS special requirements:"},{"location":"automation/mobile/#mobile-config-properties","text":"We can provide any Appium capability in the _config.properties file using capabilities.name=value format. In the table below we are providing the description of the most popular mobile capabilities: Attribute Meaning Default value Example capabilities.deviceName Device name for report n/a Sumsung_Galaxy_J5 capabilities.deviceType The only custom Carina capability to determine the type of a device n/a phone/tablet/tv... capabilities.platformName Name of the mobile platform n/a Android/iOS/AndroidTV/tvOS capabilities.platformVersion Version of the mobile platform n/a 6.0.1 capabilities.app Path to the application (apk/app/ipa) which is tested, can be provided as a pattern from AWS S3 storage with automatic downloading n/a D:/application.apk, s3://qaprosoft.com/android/myapk.*-release.apk capabilities.newCommandTimeout New implicit timeout in seconds to wait for the element for mobile automation n/a 180 capabilities.udid Unique Device ID n/a 759b543c capabilities.appActivity Activity name for the Android activity you want to launch from your package. n/a com.amazon.mShop.HomeActivity capabilities.appPackage Java package of the Android app you want to run n/a in.amazon.mShop.android.shopping capabilities.noSign Skips checking and signing of the app with debug keys, will work only with UiAutomator and not with selendroid, defaults to false n/a true, false capabilities.autoGrantPermissions Has Appium automatically determine which permissions your app requires and grants them to the app on install. Defaults to false n/a true, false Actual list of Appium capabilities can be found here .","title":"Mobile config properties"},{"location":"automation/mobile/#example-for-android-of-_configproperties","text":"selenium_url=http://localhost:4723/wd/hub #============ Android Local Mobile ===================# capabilities.platformName=ANDROID capabilities.deviceName=Nexus_6 capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.noSign=true capabilities.autoGrantPermissions=true #=====================================================#","title":"Example for Android of _config.properties:"},{"location":"automation/mobile/#example-for-ios-of-_configproperties","text":"selenium_url=http://localhost:4723/wd/hub #======== Local Run for iOS Mobile ===============# capabilities.platformName=iOS capabilities.deviceName=iPhone X capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip #=====================================================#","title":"Example for iOS of _config.properties:"},{"location":"automation/mobile/#implementation-of-page-objects","text":"The main idea is the same as in web-testing .","title":"Implementation of Page Objects:"},{"location":"automation/mobile/#how-to-find-locators-for-android-application","text":"To obtain the locators of elements from an Android app different programs are used such as Appium itself or convenient Android SDK tool: uiautomatorviewer . Example: @FindBy(xpath = \"//*[@resource-id='name_input']\") private ExtendedWebElement input;","title":"How to find locators for Android application"},{"location":"automation/mobile/#how-to-find-locators-for-ios-application","text":"To obtain the locators of elements from an iOS app different programs are used such as Appium itself or convenient Macaca App Inspector . To speed up element detection @Predicate annotation can be used used. Complicate \"xpath\" can't be used with predicates. Example: @FindBy(xpath = \"name = 'DONE'\") @Predicate protected ExtendedWebElement doneButton; Another possibility to find the element is to use @ClassChain annotation. Example: @FindBy(xpath = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") @ClassChain protected ExtendedWebElement developerText; Starting from Carina version 6.0.12, it's recommended to use @ExtendedFindBy() annotation. Example: @ExtendedFindBy(iosClassChain = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") protected ExtendedWebElement developerText; or @ExtendedFindBy(iosPredicate = \"name = 'DONE'\") protected ExtendedWebElement developerText;","title":"How to find locators for iOS application"},{"location":"automation/mobile/#implementation-of-tests","text":"Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class SampleTest implements IAbstractTest { String name = \"My name\"; String carName = \"Mercedes\"; @Test() public void sendName() { FirstPage firstPage = new FirstPage(getDriver()); firstPage.clickOnGooleButton(); GoogleTestPage googleTestPage = new GoogleTestPage(getDriver()); googleTestPage.setName(name); googleTestPage.clickOnSpinner(); googleTestPage.selectCar(carName); googleTestPage.clickOnSendYourNameButton(); MyWayOfHelloPage myWayOfHelloPage = new MyWayOfHelloPage(getDriver()); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(name), \"Assert message\" ); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(carName.toLowerCase()), \"Assert message\" ); } } Important: * Test class should implement com.zebrunner.carina.core.IAbstractTest * Test method should start with org.testng.annotations.Test annotation * Use getDriver() method to get driver instance in test * Locate tests in src/test/java source folder","title":"Implementation of tests"},{"location":"automation/mobile/#how-to-use-customtypepagefactory","text":"Carina provides the technique to combine Desktop/iOS/Android tests into the single test class/method. For all platforms you should use Page Object Design Pattern , but in a bit improved way. Every page has an abstract declaration and different implementations if needed (by default, 3 ones should be enough: Desktop, iOS/Android): Common abstract page in a common package with common methods and elements; Desktop page in a desktop package with desktop methods and elements; iOS page in ios package with iOS methods and elements; Android page in android package with Android methods and elements. Children pages should extend BasePage implementing all abstract methods. Annotation @DeviceType will provide the information about the device type and the parent (common) page. Examples: Common (Base) Page public abstract class HomePageBase extends AbstractPage { public HomePageBase(WebDriver driver) { super(driver); } public abstract PhoneFinderPageBase openPhoneFinder(); public abstract ComparePageBase openComparePage(); } Android Page @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='Phone Finder']\") protected ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='compare']\") protected ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } iOS Page @DeviceType(pageType = Type.IOS_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"name = 'Phone Finder'\") @Predicate private ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"name = 'Compare'\") @Predicate private ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } } Inside every test, Carina operates with an abstract base page using CustomTypePageFactory and substitutes it by the real implementation based on the desired capabilities in _config.properties etc. Example: @Test public void comparePhonesTest() { HomePageBase homePage = CustomTypePageFactory.initPage(getDriver(), HomePageBase.class); ComparePageBase phoneFinderPage = homePage.openCompare(); ... } If there are differences in application according to OS version, just implement the pages for different versions and include the version parameter in @DeviceType for every page. Example: For Android 8 (either 8.0 or 8.1) @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { ... } Or for a specific version @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8.1\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { ... }","title":"How to use CustomTypePageFactory"},{"location":"automation/mobile/#how-to-use-find-by-image-strategy","text":"Find by image strategy is based on appium implementation . Be sure you have OpenCV libraries installed to your system . Find by image logic is covered by @ExtendedFindBy annotation. Example: @ExtendedFindBy(image = \"images/singUp6.png\") private ExtendedWebElement signUpBtn; The list of actions with image elements and related driver settings is available here . Basically, all you need is to create an image template of the element in .png format and place it to your project. We suggest using src/main/resources/ folder to store images. Be sure your image size is less than the real screen size. Real iOS screen sizes are listed here in 'UIKit Size (Points)' column. You can also find the ultimate guide to iPhone resolutions here .","title":"How to use Find by Image strategy"},{"location":"automation/mobile/#how-to-change-context-of-application","text":"In carina-demo there is an example of a tool , that can change context of application. Just add needed context as a field in View enum. // for example NATIVE(\"NATIVE_APP\"), WEB1(\"WEBVIEW_chromeapp\"), WEB2(\"WEBVIEW_opera\"); Then change context in your test/page class where needed. public void testWebView() { WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); LoginPageBase loginPage = welcomePage.clickNextBtn(); loginPage.login(); WebViewPageBase webViewPageBase = initPage(getDriver(), WebViewPageBase.class); MobileContextUtils contextHelper = new MobileContextUtils(); contextHelper.switchMobileContext(View.WEB); ContactUsPageBase contactUsPage = webViewPageBase.goToContactUsPage(); contactUsPage.typeName(\"John Doe\"); contactUsPage.typeEmail(\"some@email.com\"); contactUsPage.typeQuestion(\"This is a message\"); contactUsPage.submit(); Assert.assertTrue(contactUsPage.isErrorMessagePresent() || contactUsPage.isRecaptchaPresent(), \"Error message or captcha was not displayed\"); }","title":"How to change context of application"},{"location":"automation/mobile/#what-if-the-mobile-app-link-points-to-amazon-azure-appcenter-other","text":"When the driver starts, a link to the application is taken from the capabilities. The type of link determines how to process it and get the final (for example, pre-assign) link which will be used when starting the driver instead of the original. If you provide a link to an application located on Amazon, then add the dependency com.zebrunner.carina-aws-s3 , Azure - com.zebrunner.carina-azure , AppCenter - com.zebrunner.carina-appcenter . You can also create your own implementation of getting the final link to the mobile application: Create a class that implements the com.zebrunner.carina.commons.artifact.IArtifactManager interface (from com.zebrunner.carina-commons dependency). The getDirectLink method just transforms the link to the final. Create a class that implements the com.zebrunner.carina.commons.artifact.IArtifactManagerFactory interface and annotate it by com.zebrunner.carina.commons.artifact.ArtifactManagerFactory . So this class will be discovered by Carina Framework at runtime. If Carina Framework does not find a suitable artifact manager to generate final link, then the link will be passed to the driver as is.","title":"What if the mobile app link points to Amazon / Azure/ AppCenter / other"},{"location":"automation/mobile/#faq","text":"Where can I find mobile-specific methods? IMobileUtils - contains methods for interacting with both IOS and Android devices IAndroidUtils , AndroidService - contains methods for interacting with Android devices only IOSUtils - contains methods for interacting with IOS devices only","title":"FAQ"},{"location":"automation/web/","text":"Carina framework follows Selenium best practices for web test automation. If you are familiar with Selenium WebDriver and have already implemented a few tests with the Page Object Pattern, the following guide will be much easier for understanding. We have chosen GSM Arena public web site for demonstration purposes, the whole test source code is located in carina-demo Github repo. Implementation of Page Objects When you are writing functional tests using Selenium, the major part of your code will consist of interactions with the web interface you are testing through the WebDriver API. After fetching elements, you will verify some state of an element through various assertions and move on to fetching the next element. You may find WebElements directly in your tests: List<WebElement> zipCodes = driver.findElements(By.id(\"zipCodes\")); for (WebElement zipCode : zipCodes) { if (zipCode.getText().equals(\"12345\")){ zipCode.click(); break; } } WebElement city = driver.findElement(By.id(\"city\")); assertEquals(\"MyCityName\", city.getText()); Some of the typical problems for this type of Selenium tests are: Test cases are difficult to read Changes in the UI break multiple tests, often in several places Duplication of selectors both inside and across tests - no reuse So, instead of having each test fetch elements directly and being fragile towards the UI changes, the Page Object Pattern introduces what is basically a decoupling layer. You create an object that represents the UI you want to test, which can be a whole page or a significant part of it. The responsibility of this object is to wrap HTML elements and encapsulate interactions with the UI, meaning that this is where all calls to WebDriver will go. This is where most WebElements are. And this is the only place you need to modify when the UI changes. In general, Page Object contains locators of the elements situated on the page and some business logic that may be reused by different tests: public class ModelInfoPage extends AbstractPage { @FindBy(css = \".help-display strong\") private ExtendedWebElement displayInfoLabel; @FindBy(css = \".help-camera strong\") private ExtendedWebElement cameraInfoLabel; @FindBy(css = \".help-expansion strong\") private ExtendedWebElement displayRamLabel; @FindBy(css = \".help-battery strong\") private ExtendedWebElement batteryInfoLabel; public ModelInfoPage(WebDriver driver) { super(driver); } public String readDisplay() { assertElementPresent(displayInfoLabel); return displayInfoLabel.getText(); } public String readCamera() { assertElementPresent(cameraInfoLabel); return cameraInfoLabel.getText(); } public String readRam() { assertElementPresent(displayRamLabel); return displayRamLabel.getText(); } public String readBattery() { assertElementPresent(displayInfoLabel); return batteryInfoLabel.getText(); } } Important: Page should extend com.zebrunner.carina.webdriver.gui.AbstractPage Use com.zebrunner.carina.webdriver.decorator.ExtendedWebElement instead of Selenium WebElement Locate Page Object classes in src/main/java Implementation of UI Components In some cases, it is useful to implement UI Objects that may be reused between multiple Page Objects. For instance, a top menu or footer may be shared between multiple pages: public class FooterMenu extends AbstractUIObject { @FindBy(linkText = \"Home\") private ExtendedWebElement homeLink; @FindBy(linkText = \"Compare\") private ExtendedWebElement compareLink; public FooterMenu(WebDriver driver, SearchContext searchContext) { super(driver, searchContext); } public HomePage openHomePage() { homeLink.click(); return new HomePage(driver); } public CompareModelsPage openComparePage() { compareLink.click(); return new CompareModelsPage(driver); } } And then you can use this in Page Object: public class HomePage extends AbstractPage { @FindBy(id = \"footmenu\") private FooterMenu footerMenu; @FindBy(xpath = \"//div[contains(@class, 'brandmenu-v2')]//a\") private List<ExtendedWebElement> brandLinks; public HomePage(WebDriver driver) { super(driver); } public FooterMenu getFooterMenu() { return footerMenu; } public BrandModelsPage selectBrand(String brand) { LOGGER.info(\"selecting '\" + brand + \"' brand...\"); for (ExtendedWebElement brandLink : brandLinks) { String currentBrand = brandLink.getText(); LOGGER.info(\"currentBrand: \" + currentBrand); if (brand.equalsIgnoreCase(currentBrand)) { brandLink.click(); return new BrandModelsPage(driver); } } throw new RuntimeException(\"Unable to open brand: \" + brand); } } Important: UI Object should extend com.zebrunner.carina.webdriver.gui.AbstractUIObject You should call the super constructor super(driver, searchContext) where searchContext is an instance of org.openqa.selenium.SearchContext Locate UI Object classes in src/main/java source folder Implementation of Context annotation In some cases, it is useful to reduce elements locator by using @Context annotation. For example, instead of using: @FindBy(xpath = \"//div[@class='search-field']//input\") private ExtendedWebElement searchField; @FindBy(xpath = \"//div[@class='search-field']//button\") private ExtendedWebElement searchButton; We can aggregate the same locator into new element. Then we need refer to it in @Context annotation like this: @FindBy(xpath = \"//div[@class='search-field']\") private ExtendedWebElement searchComp; @Context(dependsOn = \"searchComp\") @FindBy(tagName = \"input\") private ExtendedWebElement searchField; @Context(dependsOn = \"searchComp\") @FindBy(tagName = \"button\") private ExtendedWebElement searchButton; With context annotation could be also created chains of elements dependency @FindBy(id = \"news\") private ExtendedWebElement newsBlock; @Context(dependsOn = \"newsBlock\") @FindBy(xpath = \".//div[@class='news-item']\") private ExtendedWebElement newsItem; @Context(dependsOn = \"newsItem\") @FindBy(tagName = \"h3\") private ExtendedWebElement newsTitle; @Context can also refer to element from super class by its name. Referred element type could be: ExtendedWebElement Extends from AbstractUIObject Elements type that are marked with @Context annotation could be: ExtendedWebElement Extends from AbstractUIObject List <ExtendedWebElement> List<? extends AbstractUIObject> Work with iframe Before working with an iframe, you need to understand that an iframe is a separate page. Therefore, if we need to work with the internal structure of an iframe, we need to create a separate class for it inherited from AbstractPage, in which we already paint its internal structure, for example: public class Frame extends AbstractPage { @FindBy(xpath = \"//div[@class='tag-of-element']\") private ExtendedWebElement component; public Frame(WebDriver driver) { super(driver); } public void click() { component.click(); } } Let's suppose the iframe is a page component or another component. Then we have to designate it as ExtendedWebElement, for example: @FindBy(xpath = \".//iframe\") private ExtendedWebElement iframe; If we need to perform actions on iframe components, we can do: Frame frame = new Frame(driver); driver.switchTo().frame(iframe.getElement()); frame.click(); getDriver().switchTo().defaultContent(); Implementation of tests Carina framework uses TestNG for test organization. In general, a test represents a manipulation with Page Objects and additional validations of UI events. Here is a sample test implementation: public class WebSampleTest implements IAbstractTest { @Test() @MethodOwner(owner = \"qpsdemo\") public void testCompareModels() { // Open GSM Arena home page and verify page is opened HomePage homePage = new HomePage(getDriver()); homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); CompareModelsPage comparePage = footerMenu.openComparePage(); // Compare 3 models List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); // Verify model announced dates Assert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2015, November\"); Assert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2016, September\"); Assert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); } } It is good practice to implement all elements search logic of Page Object/UI Object side and perform assertions and validations in the test, do not mix this logic. Important: Test class should implement com.zebrunner.carina.core.IAbstractTest Test method should start with org.testng.annotations.Test annotation Use getDriver() method to get driver instance in the test. 1st call of this method will start a driver based on default capabilities. Locate tests in src/test/java source folder Test configuration There are a few critical properties in a _config.properties file which are required for web test execution: url=http://www.gsmarena.com capabilities.browserName=chrome The implemented test cases should be placed in a TestNG xml file according to the test group the test belongs to. You can find more details about TestNG configuration in the official documentation . <!DOCTYPE suite SYSTEM \"https://testng.org/testng-1.0.dtd\"> <suite verbose=\"1\" name=\"Carina Demo Tests - Web Sample\" parallel=\"methods\"> <test name=\"GSM arena web tests\"> <classes> <class name=\"com.zebrunner.carina.demo.WebSampleTest\" /> </classes> </test> </suite> Page opening strategy Determines how Carina detects whether the expected page is opened: By URL (by default) By Element presence on the page By URL and Element To check if a page was opened, you can use the following: page.isPageOpened(); //or page.assertPageOpened(); // equals Assert.assertTrue(page.isPageOpened(),\"PageName not loaded: reason); Page opening strategy configuration can be set in several places: 1) in _config.properties . This determines the whole project page open strategy. 2) In page class. This overrides global page opening strategy for a specific page. public class Page extends AbstractPage { public Page(WebDriver driver){ super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } } 3) In test class. This also overrides global page opening strategy for a specific page. @Test public void test(){ HomePage homePage=new HomePage(getDriver()); homePage.open(); homePage.setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } Strategy usage examples: By URL //This is a default value. To use it, you need to set a real page URLs into your page classes. private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); setPageAbsoluteURL(specificPageUrl); //set's full url //or setPageURL(\"/specific/url\"); //add's String to url from _config_properties } By Element //To use this strategy, you need to specify ui load marker. @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_ELEMENT); setUiLoadedMarker(element); } By URL and Element private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL_AND_ELEMENT); setUiLoadedMarker(element); setPageAbsoluteURL(specificPageUrl); } Element loading strategy Determines how carina detects appearing of web elements on page: By presence. Carina waits for appearance of web elements in page DOM model. By visibility. Carina waits until web elements are visible in page. By presence or visibility (default). It is recommended to use element_loading_strategy=BY_VISIBILITY because in some cases, condition with presence happens faster but elements are still not accessible due to invisibility at this short period of time. Element loading strategy can be set at the same places as Page opening strategy . To check if the element is present: Component component = Page.getComponent(); // equals to Assert.assertTrue(component.isUIObjectPresent(),\"UI object componentName does not present!\"); component.assertUIObjectPresent(); // equals to Assert.assertTrue(!component.isUIObjectPresent(),\"UI object componentName presents!\"); component.assertUIObjectNotPresent(); Dynamic elements loading. waitForJSToLoad() method was introduced in AbstractPage class. It uses JS under the hood and helps to wait till all the dynamic web elements on the page are loaded. FAQ What are the benefits of the AbstractUIObject? The biggest advantage of AbstractUIObject(s) is that you have a single place of truth to declare elements and later change the updated locator in one place. It also allows to considerably speed up all kinds of refactoring, especially after significant changes by developers:) Is it possible to automate WebApp written on React, Angular, Vue, Flutter, Google Web Toolkit and other popular and not frameworks? Carina is a Selenium-based framework so no limitations at this point. Moreover, playing with the page opening and element loading strategies, you can tune this test automation framework to any tool set. Can I operate with Page elements on test classes layer? In general, it is not prohibited, but not recommended! Isolating page elements by private access modificator allows you to control the implementation in the single Page Object class. //In the page class: @FindBy(id = \"js-lang-list-button\") private ExtendedWebElement langListBtn; @FindBy(xpath = \"//div[@id='js-lang-lists']//a\") private List<ExtendedWebElement> langList; public WikipediaLocalePage goToWikipediaLocalePage(WebDriver driver) { openLangList(); if (!langList.isEmpty()) { for (ExtendedWebElement languageBtn : langList) { String localeStr = Configuration.get(Configuration.Parameter.LOCALE); Locale locale = parseLocale(localeStr); if (languageBtn.getAttribute(\"lang\").equals(locale.getLanguage())) { languageBtn.click(); return new WikipediaLocalePage(driver); } } } throw new RuntimeException(\"No language ref was found\"); } public void openLangList() { langListBtn.clickIfPresent(); } //In the test class: public void someTest() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); } How to declare and use an ExtendedWebElement with dynamic xpath? In previous versions of Carina, it was possible to search for an element using a dynamic xpath using such code: ExtendedWebElement spec = findExtendedWebElement(By.xpath( String.format(\"//td[@class='nfo'][%d]//a[text()='%s']\", \"My link\", 1))); However, this element search format is now deprecated and not recommended to use. There is more convenient way to search: 1) Declare an element using the @FindBy annotation and specify a locator based on the convention used by the Formatter : @FindBy(xpath = \"//a[text()='%s']\") private ExtendedWebElement link; @FindBy(xpath = \"//td[@class='nfo'][%d]\") private ExtendedWebElement cell; @FindBy(xpath = \"//td[@class='nfo'][%d]//a[text()='%s']\") private ExtendedWebElement cellLink 2) In code where these elements will be used, use the format method to format the locator and create an ExtendedWebElement based on it for later use: // a link that have the text \"My link\" link.format(\"My link\") // td tag with class 'nfo' by index 2 cell.format(2) // a link that have the text \"My link\" that is in the td tag with class 'nfo' by index 2 cellLink.format(2, \"My link\"); 3) As a result of calling this method, we get a specific ExtendedWebElement, which we can use in the future, for example: //getting text of element cell.format(\"My link\").getText(); How do I install extensions for Chrome? Installing an extension for Chrome is done by using the addEncodedExtensions method of ChromeOptions class, for example: ChromeOptions options = new ChromeCapabilities().getCapability(\"default\"); List<File> paths = new ArrayList(); paths.add(new File(\"path to the file with crx extension (packed Chrome extension)\")); options.addEncodedExtensions(paths); getDriver(\"default\", options);","title":"Web"},{"location":"automation/web/#implementation-of-page-objects","text":"When you are writing functional tests using Selenium, the major part of your code will consist of interactions with the web interface you are testing through the WebDriver API. After fetching elements, you will verify some state of an element through various assertions and move on to fetching the next element. You may find WebElements directly in your tests: List<WebElement> zipCodes = driver.findElements(By.id(\"zipCodes\")); for (WebElement zipCode : zipCodes) { if (zipCode.getText().equals(\"12345\")){ zipCode.click(); break; } } WebElement city = driver.findElement(By.id(\"city\")); assertEquals(\"MyCityName\", city.getText()); Some of the typical problems for this type of Selenium tests are: Test cases are difficult to read Changes in the UI break multiple tests, often in several places Duplication of selectors both inside and across tests - no reuse So, instead of having each test fetch elements directly and being fragile towards the UI changes, the Page Object Pattern introduces what is basically a decoupling layer. You create an object that represents the UI you want to test, which can be a whole page or a significant part of it. The responsibility of this object is to wrap HTML elements and encapsulate interactions with the UI, meaning that this is where all calls to WebDriver will go. This is where most WebElements are. And this is the only place you need to modify when the UI changes. In general, Page Object contains locators of the elements situated on the page and some business logic that may be reused by different tests: public class ModelInfoPage extends AbstractPage { @FindBy(css = \".help-display strong\") private ExtendedWebElement displayInfoLabel; @FindBy(css = \".help-camera strong\") private ExtendedWebElement cameraInfoLabel; @FindBy(css = \".help-expansion strong\") private ExtendedWebElement displayRamLabel; @FindBy(css = \".help-battery strong\") private ExtendedWebElement batteryInfoLabel; public ModelInfoPage(WebDriver driver) { super(driver); } public String readDisplay() { assertElementPresent(displayInfoLabel); return displayInfoLabel.getText(); } public String readCamera() { assertElementPresent(cameraInfoLabel); return cameraInfoLabel.getText(); } public String readRam() { assertElementPresent(displayRamLabel); return displayRamLabel.getText(); } public String readBattery() { assertElementPresent(displayInfoLabel); return batteryInfoLabel.getText(); } } Important: Page should extend com.zebrunner.carina.webdriver.gui.AbstractPage Use com.zebrunner.carina.webdriver.decorator.ExtendedWebElement instead of Selenium WebElement Locate Page Object classes in src/main/java","title":"Implementation of Page Objects"},{"location":"automation/web/#implementation-of-ui-components","text":"In some cases, it is useful to implement UI Objects that may be reused between multiple Page Objects. For instance, a top menu or footer may be shared between multiple pages: public class FooterMenu extends AbstractUIObject { @FindBy(linkText = \"Home\") private ExtendedWebElement homeLink; @FindBy(linkText = \"Compare\") private ExtendedWebElement compareLink; public FooterMenu(WebDriver driver, SearchContext searchContext) { super(driver, searchContext); } public HomePage openHomePage() { homeLink.click(); return new HomePage(driver); } public CompareModelsPage openComparePage() { compareLink.click(); return new CompareModelsPage(driver); } } And then you can use this in Page Object: public class HomePage extends AbstractPage { @FindBy(id = \"footmenu\") private FooterMenu footerMenu; @FindBy(xpath = \"//div[contains(@class, 'brandmenu-v2')]//a\") private List<ExtendedWebElement> brandLinks; public HomePage(WebDriver driver) { super(driver); } public FooterMenu getFooterMenu() { return footerMenu; } public BrandModelsPage selectBrand(String brand) { LOGGER.info(\"selecting '\" + brand + \"' brand...\"); for (ExtendedWebElement brandLink : brandLinks) { String currentBrand = brandLink.getText(); LOGGER.info(\"currentBrand: \" + currentBrand); if (brand.equalsIgnoreCase(currentBrand)) { brandLink.click(); return new BrandModelsPage(driver); } } throw new RuntimeException(\"Unable to open brand: \" + brand); } } Important: UI Object should extend com.zebrunner.carina.webdriver.gui.AbstractUIObject You should call the super constructor super(driver, searchContext) where searchContext is an instance of org.openqa.selenium.SearchContext Locate UI Object classes in src/main/java source folder","title":"Implementation of UI Components"},{"location":"automation/web/#implementation-of-context-annotation","text":"In some cases, it is useful to reduce elements locator by using @Context annotation. For example, instead of using: @FindBy(xpath = \"//div[@class='search-field']//input\") private ExtendedWebElement searchField; @FindBy(xpath = \"//div[@class='search-field']//button\") private ExtendedWebElement searchButton; We can aggregate the same locator into new element. Then we need refer to it in @Context annotation like this: @FindBy(xpath = \"//div[@class='search-field']\") private ExtendedWebElement searchComp; @Context(dependsOn = \"searchComp\") @FindBy(tagName = \"input\") private ExtendedWebElement searchField; @Context(dependsOn = \"searchComp\") @FindBy(tagName = \"button\") private ExtendedWebElement searchButton; With context annotation could be also created chains of elements dependency @FindBy(id = \"news\") private ExtendedWebElement newsBlock; @Context(dependsOn = \"newsBlock\") @FindBy(xpath = \".//div[@class='news-item']\") private ExtendedWebElement newsItem; @Context(dependsOn = \"newsItem\") @FindBy(tagName = \"h3\") private ExtendedWebElement newsTitle; @Context can also refer to element from super class by its name. Referred element type could be: ExtendedWebElement Extends from AbstractUIObject Elements type that are marked with @Context annotation could be: ExtendedWebElement Extends from AbstractUIObject List <ExtendedWebElement> List<? extends AbstractUIObject>","title":"Implementation of Context annotation"},{"location":"automation/web/#work-with-iframe","text":"Before working with an iframe, you need to understand that an iframe is a separate page. Therefore, if we need to work with the internal structure of an iframe, we need to create a separate class for it inherited from AbstractPage, in which we already paint its internal structure, for example: public class Frame extends AbstractPage { @FindBy(xpath = \"//div[@class='tag-of-element']\") private ExtendedWebElement component; public Frame(WebDriver driver) { super(driver); } public void click() { component.click(); } } Let's suppose the iframe is a page component or another component. Then we have to designate it as ExtendedWebElement, for example: @FindBy(xpath = \".//iframe\") private ExtendedWebElement iframe; If we need to perform actions on iframe components, we can do: Frame frame = new Frame(driver); driver.switchTo().frame(iframe.getElement()); frame.click(); getDriver().switchTo().defaultContent();","title":"Work with iframe"},{"location":"automation/web/#implementation-of-tests","text":"Carina framework uses TestNG for test organization. In general, a test represents a manipulation with Page Objects and additional validations of UI events. Here is a sample test implementation: public class WebSampleTest implements IAbstractTest { @Test() @MethodOwner(owner = \"qpsdemo\") public void testCompareModels() { // Open GSM Arena home page and verify page is opened HomePage homePage = new HomePage(getDriver()); homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); CompareModelsPage comparePage = footerMenu.openComparePage(); // Compare 3 models List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); // Verify model announced dates Assert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2015, November\"); Assert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2016, September\"); Assert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); } } It is good practice to implement all elements search logic of Page Object/UI Object side and perform assertions and validations in the test, do not mix this logic. Important: Test class should implement com.zebrunner.carina.core.IAbstractTest Test method should start with org.testng.annotations.Test annotation Use getDriver() method to get driver instance in the test. 1st call of this method will start a driver based on default capabilities. Locate tests in src/test/java source folder","title":"Implementation of tests"},{"location":"automation/web/#test-configuration","text":"There are a few critical properties in a _config.properties file which are required for web test execution: url=http://www.gsmarena.com capabilities.browserName=chrome The implemented test cases should be placed in a TestNG xml file according to the test group the test belongs to. You can find more details about TestNG configuration in the official documentation . <!DOCTYPE suite SYSTEM \"https://testng.org/testng-1.0.dtd\"> <suite verbose=\"1\" name=\"Carina Demo Tests - Web Sample\" parallel=\"methods\"> <test name=\"GSM arena web tests\"> <classes> <class name=\"com.zebrunner.carina.demo.WebSampleTest\" /> </classes> </test> </suite>","title":"Test configuration"},{"location":"automation/web/#page-opening-strategy","text":"Determines how Carina detects whether the expected page is opened: By URL (by default) By Element presence on the page By URL and Element To check if a page was opened, you can use the following: page.isPageOpened(); //or page.assertPageOpened(); // equals Assert.assertTrue(page.isPageOpened(),\"PageName not loaded: reason); Page opening strategy configuration can be set in several places: 1) in _config.properties . This determines the whole project page open strategy. 2) In page class. This overrides global page opening strategy for a specific page. public class Page extends AbstractPage { public Page(WebDriver driver){ super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } } 3) In test class. This also overrides global page opening strategy for a specific page. @Test public void test(){ HomePage homePage=new HomePage(getDriver()); homePage.open(); homePage.setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } Strategy usage examples: By URL //This is a default value. To use it, you need to set a real page URLs into your page classes. private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); setPageAbsoluteURL(specificPageUrl); //set's full url //or setPageURL(\"/specific/url\"); //add's String to url from _config_properties } By Element //To use this strategy, you need to specify ui load marker. @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_ELEMENT); setUiLoadedMarker(element); } By URL and Element private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL_AND_ELEMENT); setUiLoadedMarker(element); setPageAbsoluteURL(specificPageUrl); }","title":"Page opening strategy"},{"location":"automation/web/#element-loading-strategy","text":"Determines how carina detects appearing of web elements on page: By presence. Carina waits for appearance of web elements in page DOM model. By visibility. Carina waits until web elements are visible in page. By presence or visibility (default). It is recommended to use element_loading_strategy=BY_VISIBILITY because in some cases, condition with presence happens faster but elements are still not accessible due to invisibility at this short period of time. Element loading strategy can be set at the same places as Page opening strategy . To check if the element is present: Component component = Page.getComponent(); // equals to Assert.assertTrue(component.isUIObjectPresent(),\"UI object componentName does not present!\"); component.assertUIObjectPresent(); // equals to Assert.assertTrue(!component.isUIObjectPresent(),\"UI object componentName presents!\"); component.assertUIObjectNotPresent(); Dynamic elements loading. waitForJSToLoad() method was introduced in AbstractPage class. It uses JS under the hood and helps to wait till all the dynamic web elements on the page are loaded.","title":"Element loading strategy"},{"location":"automation/web/#faq","text":"What are the benefits of the AbstractUIObject? The biggest advantage of AbstractUIObject(s) is that you have a single place of truth to declare elements and later change the updated locator in one place. It also allows to considerably speed up all kinds of refactoring, especially after significant changes by developers:) Is it possible to automate WebApp written on React, Angular, Vue, Flutter, Google Web Toolkit and other popular and not frameworks? Carina is a Selenium-based framework so no limitations at this point. Moreover, playing with the page opening and element loading strategies, you can tune this test automation framework to any tool set. Can I operate with Page elements on test classes layer? In general, it is not prohibited, but not recommended! Isolating page elements by private access modificator allows you to control the implementation in the single Page Object class. //In the page class: @FindBy(id = \"js-lang-list-button\") private ExtendedWebElement langListBtn; @FindBy(xpath = \"//div[@id='js-lang-lists']//a\") private List<ExtendedWebElement> langList; public WikipediaLocalePage goToWikipediaLocalePage(WebDriver driver) { openLangList(); if (!langList.isEmpty()) { for (ExtendedWebElement languageBtn : langList) { String localeStr = Configuration.get(Configuration.Parameter.LOCALE); Locale locale = parseLocale(localeStr); if (languageBtn.getAttribute(\"lang\").equals(locale.getLanguage())) { languageBtn.click(); return new WikipediaLocalePage(driver); } } } throw new RuntimeException(\"No language ref was found\"); } public void openLangList() { langListBtn.clickIfPresent(); } //In the test class: public void someTest() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); } How to declare and use an ExtendedWebElement with dynamic xpath? In previous versions of Carina, it was possible to search for an element using a dynamic xpath using such code: ExtendedWebElement spec = findExtendedWebElement(By.xpath( String.format(\"//td[@class='nfo'][%d]//a[text()='%s']\", \"My link\", 1))); However, this element search format is now deprecated and not recommended to use. There is more convenient way to search: 1) Declare an element using the @FindBy annotation and specify a locator based on the convention used by the Formatter : @FindBy(xpath = \"//a[text()='%s']\") private ExtendedWebElement link; @FindBy(xpath = \"//td[@class='nfo'][%d]\") private ExtendedWebElement cell; @FindBy(xpath = \"//td[@class='nfo'][%d]//a[text()='%s']\") private ExtendedWebElement cellLink 2) In code where these elements will be used, use the format method to format the locator and create an ExtendedWebElement based on it for later use: // a link that have the text \"My link\" link.format(\"My link\") // td tag with class 'nfo' by index 2 cell.format(2) // a link that have the text \"My link\" that is in the td tag with class 'nfo' by index 2 cellLink.format(2, \"My link\"); 3) As a result of calling this method, we get a specific ExtendedWebElement, which we can use in the future, for example: //getting text of element cell.format(\"My link\").getText(); How do I install extensions for Chrome? Installing an extension for Chrome is done by using the addEncodedExtensions method of ChromeOptions class, for example: ChromeOptions options = new ChromeCapabilities().getCapability(\"default\"); List<File> paths = new ArrayList(); paths.add(new File(\"path to the file with crx extension (packed Chrome extension)\")); options.addEncodedExtensions(paths); getDriver(\"default\", options);","title":"FAQ"},{"location":"automation/windows/","text":"Windows To do Windows application automation, you need to: Download windows driver Enable developers mode for Windows Start Appium or WinAppDriver Set carina's configuration #path to your Appium/WinAppDriver server selenium_url=http://localhost:4723/wd/hub #Should be set to specify windows automation session capabilities.platformName=Windows capabilities.automationName=Windows #path to application you want to test capabilities.app=C:/Windows/system32/win32calc.exe That's all. To get access to the driver use getDriver(). Write and run tests as usual. If you want to pass specific parameters to WindowsDriver refer to Appium documentation . Code example: //page.class example public class CalculatorHomePage extends AbstractPage { @FindBy(xpath = \"/Window/Pane/Button[10]\") ExtendedWebElement fiveButton; @FindBy(xpath = \"/Window/Pane/Button[5]\") ExtendedWebElement oneButton; @FindBy(xpath = \"/Window/Pane/Button[23]\") ExtendedWebElement plusButton; @FindBy(xpath = \"/Window/Pane/Button[28]\") ExtendedWebElement resultButton; @FindBy(xpath = \"/Window/Pane/Text[3]\") ExtendedWebElement resultField; public CalculatorHomePage(WebDriver driver) { super(driver); } public void sumOneAndFive(){ fiveButton.click(); plusButton.click(); oneButton.click(); resultButton.click(); } public String getResult(){ return resultField.getText(); } } //test.class example public class CalculatorTest implements IAbstractTest { @Test public void calculatorSumTest(){ CalculatorHomePage calculator = new CalculatorHomePage(getDriver()); calculator.sumOneAndFive(); Assert.assertEquals(calculator.getResult().trim(), \"6\"); } }","title":"Windows"},{"location":"automation/windows/#windows","text":"To do Windows application automation, you need to: Download windows driver Enable developers mode for Windows Start Appium or WinAppDriver Set carina's configuration #path to your Appium/WinAppDriver server selenium_url=http://localhost:4723/wd/hub #Should be set to specify windows automation session capabilities.platformName=Windows capabilities.automationName=Windows #path to application you want to test capabilities.app=C:/Windows/system32/win32calc.exe That's all. To get access to the driver use getDriver(). Write and run tests as usual. If you want to pass specific parameters to WindowsDriver refer to Appium documentation . Code example: //page.class example public class CalculatorHomePage extends AbstractPage { @FindBy(xpath = \"/Window/Pane/Button[10]\") ExtendedWebElement fiveButton; @FindBy(xpath = \"/Window/Pane/Button[5]\") ExtendedWebElement oneButton; @FindBy(xpath = \"/Window/Pane/Button[23]\") ExtendedWebElement plusButton; @FindBy(xpath = \"/Window/Pane/Button[28]\") ExtendedWebElement resultButton; @FindBy(xpath = \"/Window/Pane/Text[3]\") ExtendedWebElement resultField; public CalculatorHomePage(WebDriver driver) { super(driver); } public void sumOneAndFive(){ fiveButton.click(); plusButton.click(); oneButton.click(); resultButton.click(); } public String getResult(){ return resultField.getText(); } } //test.class example public class CalculatorTest implements IAbstractTest { @Test public void calculatorSumTest(){ CalculatorHomePage calculator = new CalculatorHomePage(getDriver()); calculator.sumOneAndFive(); Assert.assertEquals(calculator.getResult().trim(), \"6\"); } }","title":"Windows"},{"location":"integration/zebrunner/","text":"Zebrunner Reporting Integration Integrating the Carina framework with Zebrunner is easy! Before the start, make sure you have Zebrunner PRO organization tenant or Zebrunner Community Edition installed. Let\u2019s begin the integration! Create agent.properties file Navigate to the folder src/main/resources and create agent.properties file (if not already created). Configure agent parameters Declare integration parameters in agent.properties: reporting.enabled=true reporting.server.hostname=https://bestcompany.zebrunner.com reporting.server.access-token=c4OXu6ch8KI3rkYraZiaDrRB7kCIndfadHSmltgVFjBiAx5LcK reporting.run.display-name=Localization Tests reporting.run.build=1.15.0.134-SNAPSHOT reporting.run.environment=QA Possible parameters in agent.properties: reporting.enabled - enables or disables reporting. The default value is false. If disabled, the agent will use no op component implementations that will simply log output for tracing purposes with the trace level; reporting.server.hostname - mandatory if reporting is enabled. Zebrunner server hostname. Can be obtained in Zebrunner on the 'Account & Profile' page under the 'Service URL' section; reporting.server.access-token - mandatory if reporting is enabled. Access token must be used to perform API calls. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Token' section; reporting.run.display-name - optional value. The display name of the test run. The default value is Default Suite; reporting.run.build - optional value. The build number that is associated with the test run. It can depict either the test build number or the application build number; reporting.run.environment - optional value. The environment in which the tests will run. More details and examples of Environment variables, Program arguments, etc. can be found in the Documentation . The integration is in place! Now you can: Report tests from Carina based project into Zebrunner Track test results in real-time Perform smart test analysis with logs, videos and screenshots Create quality trends\u2019 reports with dozens of metrics Join us in our support Telegram channel for more updates in Carina and Zebrunner! Want to get the advanced test execution and reporting for your testing? Sign up for a FREE 14-day trial in Zebrunner PRO .","title":"Zebrunner"},{"location":"integration/zebrunner/#zebrunner-reporting-integration","text":"Integrating the Carina framework with Zebrunner is easy! Before the start, make sure you have Zebrunner PRO organization tenant or Zebrunner Community Edition installed. Let\u2019s begin the integration!","title":"Zebrunner Reporting Integration"},{"location":"integration/zebrunner/#create-agentproperties-file","text":"Navigate to the folder src/main/resources and create agent.properties file (if not already created).","title":"Create agent.properties file"},{"location":"integration/zebrunner/#configure-agent-parameters","text":"Declare integration parameters in agent.properties: reporting.enabled=true reporting.server.hostname=https://bestcompany.zebrunner.com reporting.server.access-token=c4OXu6ch8KI3rkYraZiaDrRB7kCIndfadHSmltgVFjBiAx5LcK reporting.run.display-name=Localization Tests reporting.run.build=1.15.0.134-SNAPSHOT reporting.run.environment=QA Possible parameters in agent.properties: reporting.enabled - enables or disables reporting. The default value is false. If disabled, the agent will use no op component implementations that will simply log output for tracing purposes with the trace level; reporting.server.hostname - mandatory if reporting is enabled. Zebrunner server hostname. Can be obtained in Zebrunner on the 'Account & Profile' page under the 'Service URL' section; reporting.server.access-token - mandatory if reporting is enabled. Access token must be used to perform API calls. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Token' section; reporting.run.display-name - optional value. The display name of the test run. The default value is Default Suite; reporting.run.build - optional value. The build number that is associated with the test run. It can depict either the test build number or the application build number; reporting.run.environment - optional value. The environment in which the tests will run. More details and examples of Environment variables, Program arguments, etc. can be found in the Documentation .","title":"Configure agent parameters"},{"location":"integration/zebrunner/#the-integration-is-in-place","text":"Now you can: Report tests from Carina based project into Zebrunner Track test results in real-time Perform smart test analysis with logs, videos and screenshots Create quality trends\u2019 reports with dozens of metrics Join us in our support Telegram channel for more updates in Carina and Zebrunner! Want to get the advanced test execution and reporting for your testing? Sign up for a FREE 14-day trial in Zebrunner PRO .","title":"The integration is in place!"}]}