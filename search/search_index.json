{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Carina is a Java-based test automation framework that unites all testing layers: Mobile applications (web, native, hybrid), WEB applications, REST services, Databases. TRY DEMO PROJECT NOW Carina framework is built on top of the most popular open-source solutions like Selenium, Appium, TestNG allowing to reduce dependence on the specific technology stack. Carina supports all popular browsers (IE, Edge, Safari, Chrome, Firefox) and mobile devices (iOS/Android). A special feature for a mobile domain: it reuses test automation code between IOS/Android up to 70-80%. As far as our framework is built in Java, it is cross-platform. Tests may be easily executed both on Unix or Windows OS. All you need is JDK 11 installed. The framework supports different types of databases - both relational and nonrelational (MySQL, SQL Server, Oracle, PostgreSQL), providing amazing experience of DAO layer implementation using MyBatis ORM framework. API testing is based on a Freemarker template engine. It enables great flexibility in generating REST requests, and responses are dynamically changed by incoming arguments. Carina is fully integrated into Zebrunner that helps to setup a production-ready environment for running Mobile, Web and API tests. Feel free to ask any questions if you are going to use it in your company.","title":"Overview"},{"location":"configuration/","text":"Configuration files There are multiple properties files located in src/main/resources: api.properties - API test endpoints reference config.properties - global test configuration database.properties - database connection properties email.properties - emailable reports config testdata.properties - test user credentials All the properties may be retrieved in a test using R class: R.API.get(\"GetUserMethods\") R.CONFIG.get(\"browser\") R.DATABASE.get(\"db.url\") R.EMAIL.get(\"title\") R.TESTDATA.get(\"user.email\") The default config properties can be obtained by Configuration.get(Parameter.BROWSER) All the project configuration properties are located in a _config.properties file. In the table below we are providing a description of most of the parameters: Attribute Meaning Example url Base application URL http://qaprosoft.com browser Browser for testing chrome / firefox / safari / iexplore headless Run tests in headless browser mode. Enabled when headless=true. Default: false. Boolean browser_language Browser language or nothing to use the English version by default. \"es\", \"fr\" selenium_url Selenium/Appium server url http://localhost:4444/wd/hub app_version Application version/build number for reporting 1.2.5 locale Locale for using L10N feature en_GB,de_DE,fr_FR retry_interval Timeout interval between calling HTML DOM for the element. Note: in ms. For mobile automation specify a number from 500-1000 range Integer auto_screenshot Global switch for taking screenshots. When disabled, screenshots will be captured only after failures Boolean report_url Direct HTTP link to Jenkins workspace report folder. Automatically specified by CI http://localhost:8888/job /my_project/1/eTAF_Report max_screen_history Max number of reports artifacts saving in history. Default: 10 Integer env Environment specific configuration. More about this feature STAG, PROD, DEMO driver_event_listeners Comma-separated list of extra driver listeners listeners. Listeners provide extra custom actions for WebDriver and have to be the instances of WebDriverEventListener com.some_company.core.EventListener max_driver_count Max number of drivers per thread. Default: 3 Integer driver_recorder Enable embedded carina recorder for driver session log/video artifacts generation. It is recommended to use for Selenium/Appium hubs which can't record such artifacts automatically. Default: false Boolean forcibly_disable_driver_quit If enabled turns off webdriver shutdown after test finishing by any reason. Default: false Boolean custom_capabilities Name of a properties file with custom capabilities (key-value) custom.properties proxy_host Hostname of the server host.example.com proxy_port Port number 80 proxy_protocols Comma-separated list of internet protocols used to carry the connection information from the source requesting the connection to the destination for which the connection was requested. http, https, ftp, socks browsermob_proxy Boolean parameter which enables or disables the automatic BrowserMob proxy launch true, false browsermob_port Port number for BrowserMob proxy (if nothing or 0 specified, then any free port will be reused) Integer browsermob_ports_range Range of ports that will be used for starting of browsermob proxy. First available port from the range will be used. If all ports are used then test will wait for the first freed port. 8001:8003 proxy_set_to_system Boolean parameter which enables or disables the setup of a proxy true, false no_proxy Excluded hostname(s) for communication via proxy. Available only when proxy_host and proxy_port are declared! localhost.example.com explicit_timeout Timeout is seconds to wait for a certain condition to occur before proceeding further in the code Integer auto_download The enabled parameter prevents downloading a dialog and downloading a file automatically. The feature is currently available for Chrome and FireFox false, true auto_download_apps MIME types / Internet Media Types. The parameter is needed only to configure auto downloading for FireFox application/pdf, list of values auto_download_folder Path to auto download folder for Chrome and Firefox browsers. If nothing specified custom_artifacts_folder or default artifacts folder is used String project_report_directory Path to a folder where the testing report will be saved ./reports big_screen_width Screenshots will be resized according to this width if their own width is bigger. Default: -1 to keep existing size. Integer big_screen_height Screenshots will be resized according to this height if their own height is bigger. Default: -1 to keep existing size. Integer init_retry_count Number of attempts to create a driver. The default value 0 means that there will be only 1 attempt Integer init_retry_interval Interval in seconds between the attempts to create a driver Integer retry_count Number of test-retryings in case of failure. The default value 0 means that a test will be performed only once Integer thread_count Default number of threads to use when running tests in parallel. Set thread-count=custom to disable any updates on carina side. Integer data_provider_thread_count Default number of threads to use for data providers when running tests in parallel. Integer core_log_level Level for Carina logging ALL, DEBUG, ERROR, WARN, FATAL, INFO, OFF, TRACE core_log_packages Comma-separated list of core packages where you want to redefine the log level com.qaprosoft.carina.core, com.zebrunner etc log_all_json API response will be logged in JSON format Boolean date_format Date format for DateUtils.class HH:mm:ss dd/MM/yyyy, HH:mm MM/dd/yyyy time_format Date format for DateUtils.class HH:mm:ss.SSS, HH:mm a zzz crypto_key_path Path to a file with a crypto key ./src/main/resources/crypto.key suite_name Suite name for the report and TestRail. If this parameter is NULL, will be taken from TestNG xml (the parameter suite name) or _email.properties (the title) Advanced Acceptance access_key_id Access key id for Amazon S3 build uploader. More info here gkhcvdgvceUYF67897hbjsbdc secret_key Secret key for Amazon S3 build uploader. More info here gkhcvdgvceUYF67897hbjsbdc appcenter_token Token for authentication in Hockey App gkhcvdgvceUYF67897hbjsbdc Encoding for a new localization UTF-8 localization_testing Enables auto verification for elements that are marked with @Localized true, false tls_keysecure_location Path to a directory with tls secure keys ./tls/keysecure health_check_class Class to execute health checks Custom class health_check_methods Comma-separated list of methods of health_check_class to execute preliminarily doThis, doThat test_run_rules Executing rules logic: test_run_rules={RULE_NAME_ENUM}=>{RULE_VALUE1}&&{RULE_VALUE2};;... test_run_rules=PRIORITY=>P1&&P2&&P4;;OWNER=>owner;;TAGS=>tag1=temp||!!feature=reg element_loading_strategy Determines how carina detects appearing of web elements on page: by presence in DOM model or by visibility or by any of these conditions BY_PRESENCE, BY_VISIBILITY, BY_PRESENCE_OR_VISIBILITY page_opening_strategy Determines how carina detects whether expected page is opened: by expected url pattern, by marker element loading state or by both these conditions BY_ELEMENT, BY_URL, BY_URL_AND_ELEMENT Most of the properties may be read in the following way: Configuration.get(Parameter.URL) // returns string value Configuration.getBoolean(Parameter.AUTO_SCREENSHOT) // returns boolean value Configuration.getInt(Parameter.BIG_SCREEN_WIDTH) //return int value Configuration.getDouble(Parameter.MAX_DRIVER_COUNT) // returns double value Environment specific configuration In some cases, it is required to support multiple environments for testing. Let's assume we have STAG and PROD environments which have different application URLs. In this case, we need to specify the following properties in _config.properties: env=PROD STAG.url=http://stag-app-server.com PROD.url=http://prod-app-server.com And get an env-specific argument in the test in the following way: Configuration.getEnvArg(\"url\") As a result, you switch between the environments just changing the env argument in the _config.properties file. Tests execution filter configuration The test_run_rules parameter is responsible for filtering tests. There are 3 filter types: 1) PRIORITY - enum field (from P0 to P6) 2) OWNER - the test owner 3) TAGS - custom label Example of how to attach labels in code: @Test @TestPriority(Priority.P3) @MethodOwner(owner = \"Josh\") @MethodOwner(owner = \"Jake\") @TestTag(name = \"feature\", value = \"web\") @TestTag(name = \"type\", value = \"regression\") public void t4(){ ... some code ... } test_run_rules parameter parse logic: 1) A simple filter: test_run_rules=OWNER=>Josh #Where OWNER is tag, and \"=>\" split's tag and rule part. #Because of the \"Josh\" rule, test will be executed if it has Josh as owner 2) With negative logic: test_run_rules=OWNER=>!!Josh #Test will be executed if it hasn't got Josh as owner 3) With boolean logic: #Use || or && to create more difficult rules #where || == OR; && == AND. test_run_rules=OWNER=>Josh||Jake #Test will be executed if it has at least Josh or Jake as owner. test_run_rules=OWNER=>Josh&&Jake #Test will be executed if it has at least Jish and Jake as owner test_run_rules=OWNER=>Josh&&Jake||Peter #Expression will be processed in sequential priority, like #test_run_rules=OWNER=>((Josh&&Jake)||Peter) #So test will be executed if it has at least (Josh and Jake) or (Peter) as owner 4) To add more tags to the rule use \";;\", example: #;; works as && (AND) but for tags test_run_rules=PRIORITY=>!!P1;;OWNER=>Josh&&!!Jake;;TAGS=>feature=web&&!!type=smoke||feature=android #Test will be executed if it has #1) no @TestPriority(Priority.P1) #AND #2) @MethodOwner(owner = \"Josh\") without @MethodOwner(owner = \"Jake\") #AND #3) (@TestTag(name = \"feature\", value = \"web\") without @TestTag(name = \"type\", value = \"smoke\")) or @TestTag(name = \"feature\", value = \"android\") #In other words, will be executed tests with Priority that differs from P1, with Josh as owner if there no Jake #and if they are for not smoke web or if they are for android. Zebrunner Reporting configuration agent.properties file is used for Zebrunner Reporting integration, here you should specify some values for a proper integration: Attribute Meaning Example reporting.enabled Root switch true/false reporting.server.hostname Service URL https://mycompany.zebrunner.com reporting.server.access-token Access Token eyJhbGciOiJIUzUxMiJ9... reporting.projectKey Project Name empty or any existing name","title":"Configuration"},{"location":"configuration/#configuration-files","text":"There are multiple properties files located in src/main/resources: api.properties - API test endpoints reference config.properties - global test configuration database.properties - database connection properties email.properties - emailable reports config testdata.properties - test user credentials All the properties may be retrieved in a test using R class: R.API.get(\"GetUserMethods\") R.CONFIG.get(\"browser\") R.DATABASE.get(\"db.url\") R.EMAIL.get(\"title\") R.TESTDATA.get(\"user.email\") The default config properties can be obtained by Configuration.get(Parameter.BROWSER) All the project configuration properties are located in a _config.properties file. In the table below we are providing a description of most of the parameters: Attribute Meaning Example url Base application URL http://qaprosoft.com browser Browser for testing chrome / firefox / safari / iexplore headless Run tests in headless browser mode. Enabled when headless=true. Default: false. Boolean browser_language Browser language or nothing to use the English version by default. \"es\", \"fr\" selenium_url Selenium/Appium server url http://localhost:4444/wd/hub app_version Application version/build number for reporting 1.2.5 locale Locale for using L10N feature en_GB,de_DE,fr_FR retry_interval Timeout interval between calling HTML DOM for the element. Note: in ms. For mobile automation specify a number from 500-1000 range Integer auto_screenshot Global switch for taking screenshots. When disabled, screenshots will be captured only after failures Boolean report_url Direct HTTP link to Jenkins workspace report folder. Automatically specified by CI http://localhost:8888/job /my_project/1/eTAF_Report max_screen_history Max number of reports artifacts saving in history. Default: 10 Integer env Environment specific configuration. More about this feature STAG, PROD, DEMO driver_event_listeners Comma-separated list of extra driver listeners listeners. Listeners provide extra custom actions for WebDriver and have to be the instances of WebDriverEventListener com.some_company.core.EventListener max_driver_count Max number of drivers per thread. Default: 3 Integer driver_recorder Enable embedded carina recorder for driver session log/video artifacts generation. It is recommended to use for Selenium/Appium hubs which can't record such artifacts automatically. Default: false Boolean forcibly_disable_driver_quit If enabled turns off webdriver shutdown after test finishing by any reason. Default: false Boolean custom_capabilities Name of a properties file with custom capabilities (key-value) custom.properties proxy_host Hostname of the server host.example.com proxy_port Port number 80 proxy_protocols Comma-separated list of internet protocols used to carry the connection information from the source requesting the connection to the destination for which the connection was requested. http, https, ftp, socks browsermob_proxy Boolean parameter which enables or disables the automatic BrowserMob proxy launch true, false browsermob_port Port number for BrowserMob proxy (if nothing or 0 specified, then any free port will be reused) Integer browsermob_ports_range Range of ports that will be used for starting of browsermob proxy. First available port from the range will be used. If all ports are used then test will wait for the first freed port. 8001:8003 proxy_set_to_system Boolean parameter which enables or disables the setup of a proxy true, false no_proxy Excluded hostname(s) for communication via proxy. Available only when proxy_host and proxy_port are declared! localhost.example.com explicit_timeout Timeout is seconds to wait for a certain condition to occur before proceeding further in the code Integer auto_download The enabled parameter prevents downloading a dialog and downloading a file automatically. The feature is currently available for Chrome and FireFox false, true auto_download_apps MIME types / Internet Media Types. The parameter is needed only to configure auto downloading for FireFox application/pdf, list of values auto_download_folder Path to auto download folder for Chrome and Firefox browsers. If nothing specified custom_artifacts_folder or default artifacts folder is used String project_report_directory Path to a folder where the testing report will be saved ./reports big_screen_width Screenshots will be resized according to this width if their own width is bigger. Default: -1 to keep existing size. Integer big_screen_height Screenshots will be resized according to this height if their own height is bigger. Default: -1 to keep existing size. Integer init_retry_count Number of attempts to create a driver. The default value 0 means that there will be only 1 attempt Integer init_retry_interval Interval in seconds between the attempts to create a driver Integer retry_count Number of test-retryings in case of failure. The default value 0 means that a test will be performed only once Integer thread_count Default number of threads to use when running tests in parallel. Set thread-count=custom to disable any updates on carina side. Integer data_provider_thread_count Default number of threads to use for data providers when running tests in parallel. Integer core_log_level Level for Carina logging ALL, DEBUG, ERROR, WARN, FATAL, INFO, OFF, TRACE core_log_packages Comma-separated list of core packages where you want to redefine the log level com.qaprosoft.carina.core, com.zebrunner etc log_all_json API response will be logged in JSON format Boolean date_format Date format for DateUtils.class HH:mm:ss dd/MM/yyyy, HH:mm MM/dd/yyyy time_format Date format for DateUtils.class HH:mm:ss.SSS, HH:mm a zzz crypto_key_path Path to a file with a crypto key ./src/main/resources/crypto.key suite_name Suite name for the report and TestRail. If this parameter is NULL, will be taken from TestNG xml (the parameter suite name) or _email.properties (the title) Advanced Acceptance access_key_id Access key id for Amazon S3 build uploader. More info here gkhcvdgvceUYF67897hbjsbdc secret_key Secret key for Amazon S3 build uploader. More info here gkhcvdgvceUYF67897hbjsbdc appcenter_token Token for authentication in Hockey App gkhcvdgvceUYF67897hbjsbdc Encoding for a new localization UTF-8 localization_testing Enables auto verification for elements that are marked with @Localized true, false tls_keysecure_location Path to a directory with tls secure keys ./tls/keysecure health_check_class Class to execute health checks Custom class health_check_methods Comma-separated list of methods of health_check_class to execute preliminarily doThis, doThat test_run_rules Executing rules logic: test_run_rules={RULE_NAME_ENUM}=>{RULE_VALUE1}&&{RULE_VALUE2};;... test_run_rules=PRIORITY=>P1&&P2&&P4;;OWNER=>owner;;TAGS=>tag1=temp||!!feature=reg element_loading_strategy Determines how carina detects appearing of web elements on page: by presence in DOM model or by visibility or by any of these conditions BY_PRESENCE, BY_VISIBILITY, BY_PRESENCE_OR_VISIBILITY page_opening_strategy Determines how carina detects whether expected page is opened: by expected url pattern, by marker element loading state or by both these conditions BY_ELEMENT, BY_URL, BY_URL_AND_ELEMENT Most of the properties may be read in the following way: Configuration.get(Parameter.URL) // returns string value Configuration.getBoolean(Parameter.AUTO_SCREENSHOT) // returns boolean value Configuration.getInt(Parameter.BIG_SCREEN_WIDTH) //return int value Configuration.getDouble(Parameter.MAX_DRIVER_COUNT) // returns double value","title":"Configuration files"},{"location":"configuration/#environment-specific-configuration","text":"In some cases, it is required to support multiple environments for testing. Let's assume we have STAG and PROD environments which have different application URLs. In this case, we need to specify the following properties in _config.properties: env=PROD STAG.url=http://stag-app-server.com PROD.url=http://prod-app-server.com And get an env-specific argument in the test in the following way: Configuration.getEnvArg(\"url\") As a result, you switch between the environments just changing the env argument in the _config.properties file.","title":"Environment specific configuration"},{"location":"configuration/#tests-execution-filter-configuration","text":"The test_run_rules parameter is responsible for filtering tests. There are 3 filter types: 1) PRIORITY - enum field (from P0 to P6) 2) OWNER - the test owner 3) TAGS - custom label Example of how to attach labels in code: @Test @TestPriority(Priority.P3) @MethodOwner(owner = \"Josh\") @MethodOwner(owner = \"Jake\") @TestTag(name = \"feature\", value = \"web\") @TestTag(name = \"type\", value = \"regression\") public void t4(){ ... some code ... } test_run_rules parameter parse logic: 1) A simple filter: test_run_rules=OWNER=>Josh #Where OWNER is tag, and \"=>\" split's tag and rule part. #Because of the \"Josh\" rule, test will be executed if it has Josh as owner 2) With negative logic: test_run_rules=OWNER=>!!Josh #Test will be executed if it hasn't got Josh as owner 3) With boolean logic: #Use || or && to create more difficult rules #where || == OR; && == AND. test_run_rules=OWNER=>Josh||Jake #Test will be executed if it has at least Josh or Jake as owner. test_run_rules=OWNER=>Josh&&Jake #Test will be executed if it has at least Jish and Jake as owner test_run_rules=OWNER=>Josh&&Jake||Peter #Expression will be processed in sequential priority, like #test_run_rules=OWNER=>((Josh&&Jake)||Peter) #So test will be executed if it has at least (Josh and Jake) or (Peter) as owner 4) To add more tags to the rule use \";;\", example: #;; works as && (AND) but for tags test_run_rules=PRIORITY=>!!P1;;OWNER=>Josh&&!!Jake;;TAGS=>feature=web&&!!type=smoke||feature=android #Test will be executed if it has #1) no @TestPriority(Priority.P1) #AND #2) @MethodOwner(owner = \"Josh\") without @MethodOwner(owner = \"Jake\") #AND #3) (@TestTag(name = \"feature\", value = \"web\") without @TestTag(name = \"type\", value = \"smoke\")) or @TestTag(name = \"feature\", value = \"android\") #In other words, will be executed tests with Priority that differs from P1, with Josh as owner if there no Jake #and if they are for not smoke web or if they are for android.","title":"Tests execution filter configuration"},{"location":"configuration/#zebrunner-reporting-configuration","text":"agent.properties file is used for Zebrunner Reporting integration, here you should specify some values for a proper integration: Attribute Meaning Example reporting.enabled Root switch true/false reporting.server.hostname Service URL https://mycompany.zebrunner.com reporting.server.access-token Access Token eyJhbGciOiJIUzUxMiJ9... reporting.projectKey Project Name empty or any existing name","title":"Zebrunner Reporting configuration"},{"location":"contribution/","text":"Configure ssh connection based on git documentation https://help.github.com/articles/connecting-to-github-with-ssh . 1) Fork repository https://github.com/zebrunner/carina to your own user. 2) Clone your fork to your local machine : git clone git@github.com:your_fork_url/carina.git 3) git remote add origin <your_fork_url> (can be already added) 4) git fetch origin 5) git remote add upstream git@github.com:qaprosoft/carina.git 6) git fetch upstream 7) git checkout -b work_local_branch upstream/master And then, after adding the files ( git add ...), use git commit (add description) and then push : git push origin work_local_branch:work_remote_branch And on https://github.com/zebrunner/carina you will see the possibility to \"Compare & Pull Request\"","title":"Contribution"},{"location":"cucumber/","text":"BDD approach with Cucumber Carina allows you to integrate BDD approach into your test project easily. Under the hood it uses popular BDD framework Cucumber extending its basic functionality and integrating cool test reports. To integrate carina-cucumber functionality you just need to add its library into your project. For instance with maven that can be done by adding next lines into your pom.xml: <dependency> <groupId>com.qaprosoft</groupId> <artifactId>carina-cucumber</artifactId> <version>${carina-cucumber_version}</version> </dependency> Setting up cucumber test with carina In order to automate your test on cucumber you'll need to implement couple of things: Write down text of your scenario using cucumber syntax Declare each step of your scenario in Jave \u0441ode Map text representation of scenario with Java classes describing it Carina supports Gherkin syntax for describing of test scenarios. More details on syntax can be found here . Example of such scenario: Feature: GSM Arena News testing In order to use Cucumber in my project, I want to check how to test GSM Arena News page @demo Scenario: GSM Arena open page - original Given I am on main page When I open 'News' page Then page 'News' should be open And page 'News' should contains all items File should be stored in test/java/resources/features/ package and have .feature extension. To declare steps in Java you need to use cucumber annotations @Given, @When, @Then, etc. More details on all possible annotations could be found in official cucumber documentation . In case if some steps declaration is missing you'll get informative error in your console when you run the test. If you need to operate with WebDriver instance within the class where you're declaring Java methods for you steps you can use IDriverPool class of carina. Example: public class GSMArenaNewsSteps implements IDriverPool { @Given(\"^I am on main page\") public boolean iAmOnMainPage() { HomePage homePage = new HomePage(getDriver()); homePage.open(); return homePage.isPageOpened(); } } Finally, to map text steps with Java declaration you need to create test class and extend it from CucumberBaseTest carina class. Then use @CucumberOptions annotation in order to complete the mapping itself. Class body can be empty since all logic for buildind of scripts and running them is implemented inside CucumberBaseTest class. Here is the sample of such code: @CucumberOptions(features = \"src/test/resources/features/GSMArenaNews.feature\", glue = \"com.qaprosoft.carina.demo.cucumber.steps\", plugin = {\"pretty\", \"html:target/cucumber-core-test-report\", \"pretty:target/cucumber-core-test-report.txt\", \"json:target/cucumber-core-test-report.json\", \"junit:target/cucumber-core-test-report.xml\"} ) public class CucumberWebSampleTest extends CucumberBaseTest {} Cucumber report In addition to default integration of your cucumber tests with Zebrunner reporting tool you can get extended cucumber report available by default. It's getting generated automatically once test is done (in case if you enabled json reporting for your test by \"json:target/some-report-name.json\" plugin) Then after report being generated the link to it will be added to your emailable HTML report generated by Carina: To get this link valid you'll need to secify proper path to your report folder using report_url carina config property. In case of local run it should refer to your local report folder. Here is the sample of the report: Parallel execution You can execute cucumber tests in parallel. You can control it by data-provider-thread-count property from carina properties list. The value of that parameter will define maximum amount of parallel threads for your cucumber tests.","title":"Cucumber"},{"location":"cucumber/#bdd-approach-with-cucumber","text":"Carina allows you to integrate BDD approach into your test project easily. Under the hood it uses popular BDD framework Cucumber extending its basic functionality and integrating cool test reports. To integrate carina-cucumber functionality you just need to add its library into your project. For instance with maven that can be done by adding next lines into your pom.xml: <dependency> <groupId>com.qaprosoft</groupId> <artifactId>carina-cucumber</artifactId> <version>${carina-cucumber_version}</version> </dependency>","title":"BDD approach with Cucumber"},{"location":"cucumber/#setting-up-cucumber-test-with-carina","text":"In order to automate your test on cucumber you'll need to implement couple of things: Write down text of your scenario using cucumber syntax Declare each step of your scenario in Jave \u0441ode Map text representation of scenario with Java classes describing it Carina supports Gherkin syntax for describing of test scenarios. More details on syntax can be found here . Example of such scenario: Feature: GSM Arena News testing In order to use Cucumber in my project, I want to check how to test GSM Arena News page @demo Scenario: GSM Arena open page - original Given I am on main page When I open 'News' page Then page 'News' should be open And page 'News' should contains all items File should be stored in test/java/resources/features/ package and have .feature extension. To declare steps in Java you need to use cucumber annotations @Given, @When, @Then, etc. More details on all possible annotations could be found in official cucumber documentation . In case if some steps declaration is missing you'll get informative error in your console when you run the test. If you need to operate with WebDriver instance within the class where you're declaring Java methods for you steps you can use IDriverPool class of carina. Example: public class GSMArenaNewsSteps implements IDriverPool { @Given(\"^I am on main page\") public boolean iAmOnMainPage() { HomePage homePage = new HomePage(getDriver()); homePage.open(); return homePage.isPageOpened(); } } Finally, to map text steps with Java declaration you need to create test class and extend it from CucumberBaseTest carina class. Then use @CucumberOptions annotation in order to complete the mapping itself. Class body can be empty since all logic for buildind of scripts and running them is implemented inside CucumberBaseTest class. Here is the sample of such code: @CucumberOptions(features = \"src/test/resources/features/GSMArenaNews.feature\", glue = \"com.qaprosoft.carina.demo.cucumber.steps\", plugin = {\"pretty\", \"html:target/cucumber-core-test-report\", \"pretty:target/cucumber-core-test-report.txt\", \"json:target/cucumber-core-test-report.json\", \"junit:target/cucumber-core-test-report.xml\"} ) public class CucumberWebSampleTest extends CucumberBaseTest {}","title":"Setting up cucumber test with carina"},{"location":"cucumber/#cucumber-report","text":"In addition to default integration of your cucumber tests with Zebrunner reporting tool you can get extended cucumber report available by default. It's getting generated automatically once test is done (in case if you enabled json reporting for your test by \"json:target/some-report-name.json\" plugin) Then after report being generated the link to it will be added to your emailable HTML report generated by Carina: To get this link valid you'll need to secify proper path to your report folder using report_url carina config property. In case of local run it should refer to your local report folder. Here is the sample of the report:","title":"Cucumber report"},{"location":"cucumber/#parallel-execution","text":"You can execute cucumber tests in parallel. You can control it by data-provider-thread-count property from carina properties list. The value of that parameter will define maximum amount of parallel threads for your cucumber tests.","title":"Parallel execution"},{"location":"execution/","text":"Selenium/Appium Before running any web or mobile test you have to start Selenium/Appium locally or use a remote Selenium Grid. We recommend to use lightweight Zebrunner Selenoid and MCloud solutions. Running tests Note: Starting from 7.0.4 consider that instead of extends AbstractTest we have to implements IAbstractTest interface There are several options to execute a test: you may run test suite from Eclipse IDE or initiate test execution from the console using Maven Surefire plugin built into Carina framework. To run test suite from Eclipse IDE, just select the required TestNG xml file: Right click > Run As > TestNG suite To run the same test suite from the console, navigate to the test project root (where pom.xml is located) and execute the following command: mvn clean -Dsuite=api test Overriden configuration parameters migth be provided as Java arguments: mvn clean -Denv=STAG -Dbrowser=firefox -Dsuite=web test","title":"Execution"},{"location":"execution/#seleniumappium","text":"Before running any web or mobile test you have to start Selenium/Appium locally or use a remote Selenium Grid. We recommend to use lightweight Zebrunner Selenoid and MCloud solutions.","title":"Selenium/Appium"},{"location":"execution/#running-tests","text":"Note: Starting from 7.0.4 consider that instead of extends AbstractTest we have to implements IAbstractTest interface There are several options to execute a test: you may run test suite from Eclipse IDE or initiate test execution from the console using Maven Surefire plugin built into Carina framework. To run test suite from Eclipse IDE, just select the required TestNG xml file: Right click > Run As > TestNG suite To run the same test suite from the console, navigate to the test project root (where pom.xml is located) and execute the following command: mvn clean -Dsuite=api test Overriden configuration parameters migth be provided as Java arguments: mvn clean -Denv=STAG -Dbrowser=firefox -Dsuite=web test","title":"Running tests"},{"location":"getting_started/","text":"Install and configure JDK 11+ Install and configure Apache Maven 3.6.0+ Download the latest version of Eclipse and install TestNG plugin , maven-dependency-plugin connector and optionally lombok Generating project The easiest way to initialize a new project is to use Carina archetype, you will get correct project structure along with test samples. Run below command from any empty folder: mvn archetype:generate -DarchetypeGroupId=com.qaprosoft \\ -DarchetypeArtifactId=carina-archetype \\ -DarchetypeVersion=RELEASE \\ -DgroupId=<your_groupId> \\ -DartifactId=<your_artifactId> \\ -Dname=\"<you_project_name>\" \\ -Durl=<your_project_url> \\ -Dversion=<your_project_version> If any attribute contains spaces, it should be set in quotes (e.g.: -Dname=\"Hello World\"). In the above Maven command you need to specify 5 attributes, while the first 3 should be left unchanged: Attribute Meaning Example -DgroupId Company domain in reverse order com.mycompany -DartifactId Java project name project-qa -Dname Name with more details \"Test Automation Project\" -Durl Company URL http://mycompany.com -Dversion Project version 1.0 Import to Eclipse If the generation is successfully complete, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean eclipse:eclipse By executing this command, Maven should resolve all dependencies, downloading the required libraries to your local repository and generating the Eclipse classpath. Before importing a new project to Eclipse, you should link your IDE to your Maven repository by executing the following task: mvn -Declipse.workspace=<path_to_workspace> eclipse:configure-workspace Here you need to specify the absolute path to the Eclipse workspace. After that, restart Eclipse IDE. Now you can import generated projects such as \"Existing Java Project\" into Eclipse IDE.","title":"Getting started"},{"location":"getting_started/#generating-project","text":"The easiest way to initialize a new project is to use Carina archetype, you will get correct project structure along with test samples. Run below command from any empty folder: mvn archetype:generate -DarchetypeGroupId=com.qaprosoft \\ -DarchetypeArtifactId=carina-archetype \\ -DarchetypeVersion=RELEASE \\ -DgroupId=<your_groupId> \\ -DartifactId=<your_artifactId> \\ -Dname=\"<you_project_name>\" \\ -Durl=<your_project_url> \\ -Dversion=<your_project_version> If any attribute contains spaces, it should be set in quotes (e.g.: -Dname=\"Hello World\"). In the above Maven command you need to specify 5 attributes, while the first 3 should be left unchanged: Attribute Meaning Example -DgroupId Company domain in reverse order com.mycompany -DartifactId Java project name project-qa -Dname Name with more details \"Test Automation Project\" -Durl Company URL http://mycompany.com -Dversion Project version 1.0","title":"Generating project"},{"location":"getting_started/#import-to-eclipse","text":"If the generation is successfully complete, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean eclipse:eclipse By executing this command, Maven should resolve all dependencies, downloading the required libraries to your local repository and generating the Eclipse classpath. Before importing a new project to Eclipse, you should link your IDE to your Maven repository by executing the following task: mvn -Declipse.workspace=<path_to_workspace> eclipse:configure-workspace Here you need to specify the absolute path to the Eclipse workspace. After that, restart Eclipse IDE. Now you can import generated projects such as \"Existing Java Project\" into Eclipse IDE.","title":"Import to Eclipse"},{"location":"project_structure/","text":"Note: Starting from 7.0.4 consider that instead of extends AbstractTest we have to implements IAbstractTest interface Carina test project is structured as a standard Maven project: carina-demo |-- pom.xml |-- src/test/java |-- src/test/resources |-- api |-- testng_suites |-- xls |-- src/main/java |-- src/main/resources |-- L10N src/test/java - contains test classes organized using TestNG annotations src/test/resources - contains TestNG xml files, API templates and XLS/CSV data providers etc src/main/java - contains page object classes, API domains and additional utilities src/main/resources - contains L10N resources, configuration properties files and MyBatis profiles if needed","title":"Project structure"},{"location":"zebrIntegration/","text":"How to integrate Carina Framework with Zebrunner Community Edition Integrating the Carina framework with Zebrunner Community Edition is easy! Before the start, make sure you have Zebrunner Community Edition installed together with the Reporting service . If you haven\u2019t yet used Zebrunner CE, follow the User Guide with the steps on installation and configuration. Let\u2019s begin the integration! Note: If you already use the Carina framework in your testing, you can skip Steps 1-2 and begin with Step 3. Step 1. Generate the carina-demo project Step 2. Generate Zebrunner agent If the generation is completed successfully, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean compile After executing this command, the Zebrunner agent will be generated. Note: In case you start running tests without executing this command, you\u2019ll get the following message: Error opening zip file or JAR manifest missing : /Users/\u2026/carina-demo/target/agent/zebrunner-agent.jar Step 3. Create agent.yaml or agent.properties file Navigate to the folder src/main/resources and create agent.yaml or agent.properties file (if not already created). Step 4. Configure Zebrunner agent In this example, let\u2019s perform the configuration on the basis of file extension YAML. Below is a sample configuration file: reporting: enabled: true server: hostname: localhost:8080 access-token: <token> run: display-name: Nightly Regression Suite build: 1.12.1.96-SNAPSHOT environment: DEV Possible parameters in agent.yaml: reporting.enabled - enables or disables reporting. The default value is false. If disabled, the agent will use no op component implementations that will simply log output for tracing purposes with the trace level; reporting.server.hostname - mandatory if reporting is enabled. Zebrunner server hostname. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Service URL' section; reporting.server.access-token - mandatory if reporting is enabled. Access token must be used to perform API calls. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Token' section; reporting.run.display-name - optional value. The display name of the test run. The default value is Default Suite; reporting.run.build - optional value. The build number that is associated with the test run. It can depict either the test build number or the application build number; reporting.run.environment - optional value. The environment in which the tests will run. More details and examples of Environment variables, Program arguments, Properties file can be found in the Documentation in the section \u2018Tracking of test results\u2019. The integration is in place! Now you can: Report tests from Carina into Zebrunner CE Track test results in real-time Perform smart test analysis with logs, videos and screenshots Create quality trends\u2019 reports with dozens of metrics Join us in our support Telegram channel for more updates in Carina and Zebrunner Community Edition! Want to get the advanced test execution and reporting for your testing? Sign up for a FREE 30-day trial in Zebrunner PRO .","title":"Integration with Zebrunner"},{"location":"zebrIntegration/#how-to-integrate-carina-framework-with-zebrunner-community-edition","text":"Integrating the Carina framework with Zebrunner Community Edition is easy! Before the start, make sure you have Zebrunner Community Edition installed together with the Reporting service . If you haven\u2019t yet used Zebrunner CE, follow the User Guide with the steps on installation and configuration. Let\u2019s begin the integration! Note: If you already use the Carina framework in your testing, you can skip Steps 1-2 and begin with Step 3.","title":"How to integrate Carina Framework with Zebrunner Community Edition"},{"location":"zebrIntegration/#step-1-generate-the-carina-demo-project","text":"","title":"Step 1. Generate the carina-demo project"},{"location":"zebrIntegration/#step-2-generate-zebrunner-agent","text":"If the generation is completed successfully, you will see a new project folder with a name equal to the artifactId attribute specified during the generation, so navigate to this folder (where pom.xml is located) and execute the following Maven task: mvn clean compile After executing this command, the Zebrunner agent will be generated. Note: In case you start running tests without executing this command, you\u2019ll get the following message: Error opening zip file or JAR manifest missing : /Users/\u2026/carina-demo/target/agent/zebrunner-agent.jar","title":"Step 2. Generate Zebrunner agent"},{"location":"zebrIntegration/#step-3-create-agentyaml-or-agentproperties-file","text":"Navigate to the folder src/main/resources and create agent.yaml or agent.properties file (if not already created).","title":"Step 3. Create agent.yaml or agent.properties file"},{"location":"zebrIntegration/#step-4-configure-zebrunner-agent","text":"In this example, let\u2019s perform the configuration on the basis of file extension YAML. Below is a sample configuration file: reporting: enabled: true server: hostname: localhost:8080 access-token: <token> run: display-name: Nightly Regression Suite build: 1.12.1.96-SNAPSHOT environment: DEV Possible parameters in agent.yaml: reporting.enabled - enables or disables reporting. The default value is false. If disabled, the agent will use no op component implementations that will simply log output for tracing purposes with the trace level; reporting.server.hostname - mandatory if reporting is enabled. Zebrunner server hostname. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Service URL' section; reporting.server.access-token - mandatory if reporting is enabled. Access token must be used to perform API calls. Can be obtained in Zebrunner on the 'Account & profile' page under the 'Token' section; reporting.run.display-name - optional value. The display name of the test run. The default value is Default Suite; reporting.run.build - optional value. The build number that is associated with the test run. It can depict either the test build number or the application build number; reporting.run.environment - optional value. The environment in which the tests will run. More details and examples of Environment variables, Program arguments, Properties file can be found in the Documentation in the section \u2018Tracking of test results\u2019.","title":"Step 4. Configure Zebrunner agent"},{"location":"zebrIntegration/#the-integration-is-in-place","text":"Now you can: Report tests from Carina into Zebrunner CE Track test results in real-time Perform smart test analysis with logs, videos and screenshots Create quality trends\u2019 reports with dozens of metrics Join us in our support Telegram channel for more updates in Carina and Zebrunner Community Edition! Want to get the advanced test execution and reporting for your testing? Sign up for a FREE 30-day trial in Zebrunner PRO .","title":"The integration is in place!"},{"location":"advanced/database/","text":"Database usage Here is a simple DB schema that will be used for this sample: We will implement mapping for Users and UserPreferences tables. Dependencies For integration with DB, we recommend to use MyBatis ORM framework. MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. To start with, let's add the required dependencies into Maven pom.xml: <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.2</version> </dependency> <!-- Postgres driver --> <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.6</version> </dependency> <!-- MySQL driver --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.17</version> </dependency> Mappers The next step is MyBatis mappers implementation, read the official documentation to understand all the details. Let's place all the mappers into src/main/resources/mappers . Here is a UserMapper.xml sample: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> <mapper namespace=\"com.qaprosoft.carina.demo.db.mappers.UserMapper\"> <insert id=\"create\" useGeneratedKeys=\"true\" keyProperty=\"id\"> <![CDATA[ INSERT INTO carina.USERS (USERNAME, PASSWORD, FIRST_NAME, LAST_NAME, EMAIL, STATUS) VALUES ( #{username}, #{password}, #{firstName}, #{lastName}, #{email}, #{status} ) ]]> </insert> <sql id=\"getUser\"> <![CDATA[ SELECT U.ID AS USER_ID, U.USERNAME AS USER_USERNAME, U.PASSWORD AS USER_PASSWORD, U.FIRST_NAME AS USER_FIRST_NAME, U.LAST_NAME AS USER_LAST_NAME, U.EMAIL AS USER_EMAIL, U.STATUS AS USER_STATUS, UP.ID AS USER_PREFERENCE_ID, UP.NAME AS USER_PREFERENCE_NAME, UP.VALUE AS USER_PREFERENCE_VALUE, UP.USER_ID AS USER_PREFERENCE_USER_ID FROM carina.USERS U LEFT JOIN carina.USER_PREFERENCES UP ON UP.USER_ID = U.ID ]]> </sql> <select id=\"findById\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.ID = #{id}; ]]> </select> <select id=\"findByUserName\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.USERNAME = #{username}; ]]> </select> <update id=\"update\"> <![CDATA[ UPDATE carina.USERS ]]> <set> <if test=\"null != firstName\"> <![CDATA[ FIRST_NAME = #{firstName}, ]]> </if> <if test=\"null != lastName\"> <![CDATA[ LAST_NAME = #{lastName}, ]]> </if> <if test=\"null != email\"> <![CDATA[ EMAIL = #{email}, ]]> </if> <if test=\"null != username\"> <![CDATA[ USERNAME = #{username}, ]]> </if> <if test=\"null != password\"> <![CDATA[ PASSWORD = #{password}, ]]> </if> </set> <![CDATA[ WHERE ID = #{id} ]]> </update> <delete id=\"delete\"> <![CDATA[ DELETE FROM carina.USERS WHERE ID = #{id} ]]> </delete> <resultMap type=\"com.qaprosoft.carina.demo.db.models.User\" id=\"UserResultMap\" autoMapping=\"false\"> <id column=\"USER_ID\" property=\"id\" /> <result column=\"USER_USERNAME\" property=\"username\" /> <result column=\"USER_PASSWORD\" property=\"password\" /> <result column=\"USER_FIRST_NAME\" property=\"firstName\" /> <result column=\"USER_LAST_NAME\" property=\"lastName\" /> <result column=\"USER_EMAIL\" property=\"email\" /> <result column=\"USER_STATUS\" property=\"status\" /> <collection property=\"preferences\" ofType=\"com.qaprosoft.carina.demo.db.models.UserPreference\" resultMap=\"com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper.UserPreferenceResultMap\" /> </resultMap> </mapper> Now we have to implement a DB domain object User class which reflects the DB table structure: package com.qaprosoft.carina.demo.db.models; import java.util.ArrayList; import java.util.List; public class User { private Long id; private String username; private String password; private String email; private String firstName; private String lastName; private Status status; private List<UserPreference> preferences = new ArrayList<>(); public User() { } public enum Status { ACTIVE, INACTIVE } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public List<UserPreference> getPreferences() { return preferences; } public void setPreferences(List<UserPreference> preferences) { this.preferences = preferences; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } Also, we have to describe the mapper interface, UserMapper interface : package com.qaprosoft.carina.demo.db.mappers; import com.qaprosoft.carina.demo.db.models.User; public interface UserMapper { void create(User user); User findById(long id); User findByUserName(String username); void update(User user); void delete(User user); } Configuration First of all, we need to place DB credentials into src/main/resources/_database.properties : #===============================================================# #================== Database configuration ====================# #===============================================================# db.url=jdbc:postgresql://localhost:5432/postgres db.driver=org.postgresql.Driver db.user=postgres db.pass=postgres #db.url=jdbc:mysql://localhost:3306/mysql #db.driver=com.mysql.jdbc.Driver #db.user=mysql #db.pass=mysql All the mappers and reference to _database.properties should be specified in src/main/resources/mybatis-config.xml : <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> <configuration> <properties resource=\"_database.properties\" /> <environments default=\"development\"> <environment id=\"development\"> <transactionManager type=\"JDBC\" /> <dataSource type=\"POOLED\"> <property name=\"driver\" value=\"${db.driver}\" /> <property name=\"url\" value=\"${db.url}\" /> <property name=\"username\" value=\"${db.user}\" /> <property name=\"password\" value=\"${db.pass}\" /> </dataSource> </environment> </environments> <mappers> <mapper resource=\"mappers/UserMapper.xml\" /> <mapper resource=\"mappers/UserPreferenceMapper.xml\" /> </mappers> </configuration> Connection factory Connection factory is responsible for MyBatis context initialization and creation of mapper instances, take a look at the sample implementation of ConnectionFactory : package com.qaprosoft.carina.demo.utils; import java.io.IOException; import java.io.Reader; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.qaprosoft.carina.demo.db.mappers.UserMapper; import com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper; public class ConnectionFactory { private static SqlSessionFactory factory; static { Reader reader = null; try { reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); } catch (IOException e) { throw new RuntimeException(e.getMessage()); } factory = new SqlSessionFactoryBuilder().build(reader); } public static SqlSessionFactory getSqlSessionFactory() { return factory; } public static UserMapper getUserMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserMapper.class); } public static UserPreferenceMapper getUserPreferenceMapperMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserPreferenceMapper.class); } } Usage sample Finally, DBSampleTest illustrates the usage of MyBatis in tests: package com.qaprosoft.carina.demo; import static org.testng.Assert.assertEquals; import static org.testng.Assert.assertNull; import com.qaprosoft.carina.core.foundation.IAbstractTest; import com.zebrunner.agent.core.annotation.TestLabel; import org.apache.ibatis.session.SqlSession; import org.testng.annotations.Test; import com.qaprosoft.carina.demo.db.mappers.UserMapper; import com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper; import com.qaprosoft.carina.demo.db.models.User; import com.qaprosoft.carina.demo.db.models.User.Status; import com.qaprosoft.carina.demo.utils.ConnectionFactory; import com.qaprosoft.carina.demo.db.models.UserPreference; /** * This sample shows how create DB test. * * @author qpsdemo */ public class DBSampleTest implements IAbstractTest { ... @Test @TestLabel(name = \"feature\", value = \"database\") public void createUser() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } @Test(dependsOnMethods = \"createUser\") @TestLabel(name = \"feature\", value = \"database\") public void createUserPreference() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); UserPreferenceMapper userPreferenceMapper = session.getMapper(UserPreferenceMapper.class); USER_PREFERENCE.setUserId(USER.getId()); userPreferenceMapper.create(USER_PREFERENCE); checkUserPreference(userMapper.findById(USER.getId()).getPreferences().get(0)); } } ... }","title":"Database"},{"location":"advanced/database/#database-usage","text":"Here is a simple DB schema that will be used for this sample: We will implement mapping for Users and UserPreferences tables.","title":"Database usage"},{"location":"advanced/database/#dependencies","text":"For integration with DB, we recommend to use MyBatis ORM framework. MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. To start with, let's add the required dependencies into Maven pom.xml: <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.2</version> </dependency> <!-- Postgres driver --> <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.6</version> </dependency> <!-- MySQL driver --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.17</version> </dependency>","title":"Dependencies"},{"location":"advanced/database/#mappers","text":"The next step is MyBatis mappers implementation, read the official documentation to understand all the details. Let's place all the mappers into src/main/resources/mappers . Here is a UserMapper.xml sample: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> <mapper namespace=\"com.qaprosoft.carina.demo.db.mappers.UserMapper\"> <insert id=\"create\" useGeneratedKeys=\"true\" keyProperty=\"id\"> <![CDATA[ INSERT INTO carina.USERS (USERNAME, PASSWORD, FIRST_NAME, LAST_NAME, EMAIL, STATUS) VALUES ( #{username}, #{password}, #{firstName}, #{lastName}, #{email}, #{status} ) ]]> </insert> <sql id=\"getUser\"> <![CDATA[ SELECT U.ID AS USER_ID, U.USERNAME AS USER_USERNAME, U.PASSWORD AS USER_PASSWORD, U.FIRST_NAME AS USER_FIRST_NAME, U.LAST_NAME AS USER_LAST_NAME, U.EMAIL AS USER_EMAIL, U.STATUS AS USER_STATUS, UP.ID AS USER_PREFERENCE_ID, UP.NAME AS USER_PREFERENCE_NAME, UP.VALUE AS USER_PREFERENCE_VALUE, UP.USER_ID AS USER_PREFERENCE_USER_ID FROM carina.USERS U LEFT JOIN carina.USER_PREFERENCES UP ON UP.USER_ID = U.ID ]]> </sql> <select id=\"findById\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.ID = #{id}; ]]> </select> <select id=\"findByUserName\" resultMap=\"UserResultMap\"> <include refid=\"getUser\" /> <![CDATA[ WHERE U.USERNAME = #{username}; ]]> </select> <update id=\"update\"> <![CDATA[ UPDATE carina.USERS ]]> <set> <if test=\"null != firstName\"> <![CDATA[ FIRST_NAME = #{firstName}, ]]> </if> <if test=\"null != lastName\"> <![CDATA[ LAST_NAME = #{lastName}, ]]> </if> <if test=\"null != email\"> <![CDATA[ EMAIL = #{email}, ]]> </if> <if test=\"null != username\"> <![CDATA[ USERNAME = #{username}, ]]> </if> <if test=\"null != password\"> <![CDATA[ PASSWORD = #{password}, ]]> </if> </set> <![CDATA[ WHERE ID = #{id} ]]> </update> <delete id=\"delete\"> <![CDATA[ DELETE FROM carina.USERS WHERE ID = #{id} ]]> </delete> <resultMap type=\"com.qaprosoft.carina.demo.db.models.User\" id=\"UserResultMap\" autoMapping=\"false\"> <id column=\"USER_ID\" property=\"id\" /> <result column=\"USER_USERNAME\" property=\"username\" /> <result column=\"USER_PASSWORD\" property=\"password\" /> <result column=\"USER_FIRST_NAME\" property=\"firstName\" /> <result column=\"USER_LAST_NAME\" property=\"lastName\" /> <result column=\"USER_EMAIL\" property=\"email\" /> <result column=\"USER_STATUS\" property=\"status\" /> <collection property=\"preferences\" ofType=\"com.qaprosoft.carina.demo.db.models.UserPreference\" resultMap=\"com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper.UserPreferenceResultMap\" /> </resultMap> </mapper> Now we have to implement a DB domain object User class which reflects the DB table structure: package com.qaprosoft.carina.demo.db.models; import java.util.ArrayList; import java.util.List; public class User { private Long id; private String username; private String password; private String email; private String firstName; private String lastName; private Status status; private List<UserPreference> preferences = new ArrayList<>(); public User() { } public enum Status { ACTIVE, INACTIVE } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public List<UserPreference> getPreferences() { return preferences; } public void setPreferences(List<UserPreference> preferences) { this.preferences = preferences; } public Status getStatus() { return status; } public void setStatus(Status status) { this.status = status; } } Also, we have to describe the mapper interface, UserMapper interface : package com.qaprosoft.carina.demo.db.mappers; import com.qaprosoft.carina.demo.db.models.User; public interface UserMapper { void create(User user); User findById(long id); User findByUserName(String username); void update(User user); void delete(User user); }","title":"Mappers"},{"location":"advanced/database/#configuration","text":"First of all, we need to place DB credentials into src/main/resources/_database.properties : #===============================================================# #================== Database configuration ====================# #===============================================================# db.url=jdbc:postgresql://localhost:5432/postgres db.driver=org.postgresql.Driver db.user=postgres db.pass=postgres #db.url=jdbc:mysql://localhost:3306/mysql #db.driver=com.mysql.jdbc.Driver #db.user=mysql #db.pass=mysql All the mappers and reference to _database.properties should be specified in src/main/resources/mybatis-config.xml : <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> <configuration> <properties resource=\"_database.properties\" /> <environments default=\"development\"> <environment id=\"development\"> <transactionManager type=\"JDBC\" /> <dataSource type=\"POOLED\"> <property name=\"driver\" value=\"${db.driver}\" /> <property name=\"url\" value=\"${db.url}\" /> <property name=\"username\" value=\"${db.user}\" /> <property name=\"password\" value=\"${db.pass}\" /> </dataSource> </environment> </environments> <mappers> <mapper resource=\"mappers/UserMapper.xml\" /> <mapper resource=\"mappers/UserPreferenceMapper.xml\" /> </mappers> </configuration>","title":"Configuration"},{"location":"advanced/database/#connection-factory","text":"Connection factory is responsible for MyBatis context initialization and creation of mapper instances, take a look at the sample implementation of ConnectionFactory : package com.qaprosoft.carina.demo.utils; import java.io.IOException; import java.io.Reader; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.qaprosoft.carina.demo.db.mappers.UserMapper; import com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper; public class ConnectionFactory { private static SqlSessionFactory factory; static { Reader reader = null; try { reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); } catch (IOException e) { throw new RuntimeException(e.getMessage()); } factory = new SqlSessionFactoryBuilder().build(reader); } public static SqlSessionFactory getSqlSessionFactory() { return factory; } public static UserMapper getUserMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserMapper.class); } public static UserPreferenceMapper getUserPreferenceMapperMapper() { return ConnectionFactory.getSqlSessionFactory().openSession(true).getMapper(UserPreferenceMapper.class); } }","title":"Connection factory"},{"location":"advanced/database/#usage-sample","text":"Finally, DBSampleTest illustrates the usage of MyBatis in tests: package com.qaprosoft.carina.demo; import static org.testng.Assert.assertEquals; import static org.testng.Assert.assertNull; import com.qaprosoft.carina.core.foundation.IAbstractTest; import com.zebrunner.agent.core.annotation.TestLabel; import org.apache.ibatis.session.SqlSession; import org.testng.annotations.Test; import com.qaprosoft.carina.demo.db.mappers.UserMapper; import com.qaprosoft.carina.demo.db.mappers.UserPreferenceMapper; import com.qaprosoft.carina.demo.db.models.User; import com.qaprosoft.carina.demo.db.models.User.Status; import com.qaprosoft.carina.demo.utils.ConnectionFactory; import com.qaprosoft.carina.demo.db.models.UserPreference; /** * This sample shows how create DB test. * * @author qpsdemo */ public class DBSampleTest implements IAbstractTest { ... @Test @TestLabel(name = \"feature\", value = \"database\") public void createUser() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } @Test(dependsOnMethods = \"createUser\") @TestLabel(name = \"feature\", value = \"database\") public void createUserPreference() { try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); UserPreferenceMapper userPreferenceMapper = session.getMapper(UserPreferenceMapper.class); USER_PREFERENCE.setUserId(USER.getId()); userPreferenceMapper.create(USER_PREFERENCE); checkUserPreference(userMapper.findById(USER.getId()).getPreferences().get(0)); } } ... }","title":"Usage sample"},{"location":"advanced/dataprovider/","text":"Dataprovider usage Modern test automation frameworks should support data-driven testing, when you are able to verify a variety of edge cases providing test data sets into the tests using external data sources. Carina is not an exception, the framework supports multiple ways of test parametrization (see the samples ): Java data-providers XML parametrization XLS data-providers CSV data-providers Java data-provider As far as Carina is based on TestNG framework, you are able to use well known Java data-providers which return a matrix of Objects and pass it to the appropriate test arguments. You have to use dataProvider attribute along with @Test annotation and implement the method annotated with @DataProvider that will return Object[][] as a test data set: @Test(dataProvider = \"DP1\") public void testMuliplyOperation(int a, int b, int c) { int actual = a * b; int expected = c; Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } @DataProvider(parallel = false, name = \"DP1\") public static Object[][] dataprovider() { return new Object[][] { { 2, 3, 6 }, { 6, 6, 36 }, { 5, 8, 40 } }; } XML parametrization TestNG supports parametrization from XML files when you organize test suites using XML files. The parameterized test method should be annotated with @Parameters({ \"a\", \"b\", \"c\" }) and appropriate method arguments should be listed. Also, you have to pass all required parameters from an XML suite file: @Test @Parameters({ \"a\", \"b\", \"c\" }) public void testSubstractOperation(int a, int b, int c) { int actual = Integer.valueOf(a) - Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid substract result!\"); } ... <test name=\"Substract operation test\"> <parameter name=\"a\" value=\"12\"/> <parameter name=\"b\" value=\"3\"/> <parameter name=\"c\" value=\"9\"/> <classes> <class name=\"com.qaprosoft.carina.demo.DataprovidersSampleTest\"> <methods> <include name=\"testSubstractOperation\"/> </methods> </class> </classes> </test> ... XLS/CSV data-providers Carina test framework provides a possibility to write all tests with data providers in one place, including parametrization using external XLS/CSV spreadsheets. First of all, you need to declare a test class that implements IAbstractTest.java . After that, you can specify data provider tests as follows. public class DataprovidersSampleTest implements IAbstractTest { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"xls/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\", dsArgs = \"a,b,c\") public void testSumOperation(String a, String b, String c) { int actual = Integer.valueOf(a) + Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } } This test uses XLS/CSV files as a data source. Every line in a spreadsheet is a set of arguments for a test. You should specify the dataProvider parameter for TestNG annotation @Test . Carina test framework initially defines several data provider methods in IAbstractTest.java , which you've extended earlier: createData method (data provider name = \"DataProvider\") for common use cases createDataSingeThread method (data provider name = \"SingleDataProvider\") for a single-thread execution. To specify the XLS/CSV spreadsheets for a test, you should declare @XlsDataSourceParameters annotation and define its parameters: path - file path located in src/test/resources sheet - sheet name dsUid - data-source unique identifier dsArgs - column names from the sheet Here you can look at a spreadsheet as a data provider example for your further tests: In the TUID column, you should specify some unique test identifier that will be set at the beginning of the test name in a test result report. In the next columns, you can specify arguments for a test and their values in the bottom lines. They will be used as parameters in @XlsDataSourceParameters . In this example, the values of a, b, c arguments were defined in 3 sets of values with different TUID. DataProvider with huge number of columns In some cases, we have to provide 10+ columns into a test. In this case, there is one tricky point. Just removing dsArgs dataprovider parameter will collect all the lines into a single HashMap object, so you can dynamically get any column in a test using the column name. public class DataprovidersSampleTest implements IAbstractTest { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"xls/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\") public void testSumOperation(HashMap<String, String> args) { int actual = Integer.valueOf(args.get(\"a\")) + Integer.valueOf(args.get(\"b\")); int expected = Integer.valueOf(args.get(\"c\")); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } }","title":"DataProvider"},{"location":"advanced/dataprovider/#dataprovider-usage","text":"Modern test automation frameworks should support data-driven testing, when you are able to verify a variety of edge cases providing test data sets into the tests using external data sources. Carina is not an exception, the framework supports multiple ways of test parametrization (see the samples ): Java data-providers XML parametrization XLS data-providers CSV data-providers","title":"Dataprovider usage"},{"location":"advanced/dataprovider/#java-data-provider","text":"As far as Carina is based on TestNG framework, you are able to use well known Java data-providers which return a matrix of Objects and pass it to the appropriate test arguments. You have to use dataProvider attribute along with @Test annotation and implement the method annotated with @DataProvider that will return Object[][] as a test data set: @Test(dataProvider = \"DP1\") public void testMuliplyOperation(int a, int b, int c) { int actual = a * b; int expected = c; Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } @DataProvider(parallel = false, name = \"DP1\") public static Object[][] dataprovider() { return new Object[][] { { 2, 3, 6 }, { 6, 6, 36 }, { 5, 8, 40 } }; }","title":"Java data-provider"},{"location":"advanced/dataprovider/#xml-parametrization","text":"TestNG supports parametrization from XML files when you organize test suites using XML files. The parameterized test method should be annotated with @Parameters({ \"a\", \"b\", \"c\" }) and appropriate method arguments should be listed. Also, you have to pass all required parameters from an XML suite file: @Test @Parameters({ \"a\", \"b\", \"c\" }) public void testSubstractOperation(int a, int b, int c) { int actual = Integer.valueOf(a) - Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid substract result!\"); } ... <test name=\"Substract operation test\"> <parameter name=\"a\" value=\"12\"/> <parameter name=\"b\" value=\"3\"/> <parameter name=\"c\" value=\"9\"/> <classes> <class name=\"com.qaprosoft.carina.demo.DataprovidersSampleTest\"> <methods> <include name=\"testSubstractOperation\"/> </methods> </class> </classes> </test> ...","title":"XML parametrization"},{"location":"advanced/dataprovider/#xlscsv-data-providers","text":"Carina test framework provides a possibility to write all tests with data providers in one place, including parametrization using external XLS/CSV spreadsheets. First of all, you need to declare a test class that implements IAbstractTest.java . After that, you can specify data provider tests as follows. public class DataprovidersSampleTest implements IAbstractTest { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"xls/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\", dsArgs = \"a,b,c\") public void testSumOperation(String a, String b, String c) { int actual = Integer.valueOf(a) + Integer.valueOf(b); int expected = Integer.valueOf(c); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } } This test uses XLS/CSV files as a data source. Every line in a spreadsheet is a set of arguments for a test. You should specify the dataProvider parameter for TestNG annotation @Test . Carina test framework initially defines several data provider methods in IAbstractTest.java , which you've extended earlier: createData method (data provider name = \"DataProvider\") for common use cases createDataSingeThread method (data provider name = \"SingleDataProvider\") for a single-thread execution. To specify the XLS/CSV spreadsheets for a test, you should declare @XlsDataSourceParameters annotation and define its parameters: path - file path located in src/test/resources sheet - sheet name dsUid - data-source unique identifier dsArgs - column names from the sheet Here you can look at a spreadsheet as a data provider example for your further tests: In the TUID column, you should specify some unique test identifier that will be set at the beginning of the test name in a test result report. In the next columns, you can specify arguments for a test and their values in the bottom lines. They will be used as parameters in @XlsDataSourceParameters . In this example, the values of a, b, c arguments were defined in 3 sets of values with different TUID.","title":"XLS/CSV data-providers"},{"location":"advanced/dataprovider/#dataprovider-with-huge-number-of-columns","text":"In some cases, we have to provide 10+ columns into a test. In this case, there is one tricky point. Just removing dsArgs dataprovider parameter will collect all the lines into a single HashMap object, so you can dynamically get any column in a test using the column name. public class DataprovidersSampleTest implements IAbstractTest { @Test(dataProvider = \"DataProvider\") @XlsDataSourceParameters(path = \"xls/demo.xlsx\", sheet = \"Calculator\", dsUid = \"TUID\") public void testSumOperation(HashMap<String, String> args) { int actual = Integer.valueOf(args.get(\"a\")) + Integer.valueOf(args.get(\"b\")); int expected = Integer.valueOf(args.get(\"c\")); Assert.assertEquals(actual, expected, \"Invalid sum result!\"); } }","title":"DataProvider with huge number of columns"},{"location":"advanced/driver/","text":"Driver usage All described methods are implemented inside IDriverPool interface and accessible by default from any test class. To access this functionality from another places like your services just implement this interface. Each thread has their own named driver pool Supported Browsers: Chrome, Firefox, Internet Explorer, Microsoft Edge, Opera, Safari etc Initialization getDriver() is the core method to start any Selenium/Appium session. It will create a RemoteWebDriver named \"default\" based on default capabilities from configuration. 1st call of the method in current thread should start new driver. Next calls will return existing object. getDriver(String name) start named driver session using default capabilities from configuration. That's allow to start several drivers (up to 3 according to max_driver_count property) getDriver(String name, DesiredCapabilities capabilities) start named driver session using custom capabilities. getDriver(String name, DesiredCapabilities capabilities, String seleniumHost) start named driver session using custom capabilities vs custom selenium url. Example: @Test public void carinaCapsTest() { // Chrome default capabilities builder usage: WebDriver chromeDriver = getDriver(\"chrome\", new ChromeCapabilities().getCapability(\"Chrome Browser\")); HomePage homePageChrome = new HomePage(chromeDriver); homePageChrome.open(); // Firefox default capabilities builder usage: getDriver(\"firefox\", new FirefoxCapabilities().getCapability(\"Firefox Browser\")); HomePage homePageFirefox = new HomePage(getDriver(\"firefox\")); // return named \"firefox\" driver from the pool to init HomePage. homePageFirefox.open(); // Safari, Edge, Opera and IE default capabilities builder usage: HomePage homePageSafari = new HomePage(getDriver(\"safari\", new SafariCapabilities().getCapability(\"Safari Browser\"))); homePageSafari.open(); getDriver(\"edge\", new EdgeCapabilities().getCapability(\"Edge Browser\")); getDriver(\"opera\", new OperaCapabilities().getCapability(\"Opera Browser\")); getDriver(\"ie\", new IECapabilities().getCapability(\"Internet Explorer Browser\")); } @Test public void desiredCapsTest() { // Manage DesiredCapabilities on your own to build complicated caps structure: DesiredCapabilities capabilities = DesiredCapabilities.safari(); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); HomePage safariHomePage = new HomePage(getDriver(\"safari\", capabilities)); safariHomePage.open(); Assert.assertTrue(safariHomePage.isPageOpened()); } Capabilities Simple key value Selenium/Appium pairs can be provided in _config.properties using capabilities.name=value , for example: capabilities.automationName=uiautomator2 capabilities.deviceName=Samsung_Galaxy_S10 capabilities.platformName=ANDROID capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.newCommandTimeout=180 Visit selenium or appium to see all capabilities. Options Options and arguments could be provided through _config.properties using comma separated values for multiple options/args, for example: firefox_args=--no-first-run,--disable-notifications firefox_preferences= chrome_args= chrome_experimental_opts= chrome_mobile_emulation_opts= To provide complicated structures use advanced approach to build capabilities/options/arguments: public void someTest() { FirefoxOptions options = new FirefoxOptions(); options.addArguments(\"--no-first-run\"); options.addArguments(\"--disable-notifications\"); DesiredCapabilities capabilities = DesiredCapabilities.firefox(); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); capabilities.setCapability(FirefoxOptions.FIREFOX_OPTIONS, options); HomePage homePage = new HomePage(getDriver(\"firefox\", capabilities)); homePage.open(); Assert.assertTrue(homePage.isPageOpened()); } Quit Quit driver operation is executed automatically based on driver init phase, i.e. no need to do it inside your test code . @BeforeSuite drivers belong to all tests/classes and will be closed in @AfterSuite only @BeforeTest drivers belong to all <test> classes and will be closed in @AfterTest . @BeforeClass drivers belong to all tests inside current class and will be closed in @AfterClass @BeforeMethod or inside Test Method drivers belong to current test method and will be closed in @AfterMethod Also driver is saved for all dependent test methods inside test class by default. To quit driver forcibly if needed use quitDriver() or quitDriver(name) To disable driver quit strategy completely and cotrol drivers init/quit on your own provide forcibly_disable_driver_quit=true or execute from any place of your test code CarinaListener.disableDriversCleanup(); Restart restartDriver() quit current driver and start new one with the same capabilities restartDriver(boolean isSameDevice) quit current driver and start new one on the same device using uuid capability. It is fully compatible with MCloud farm.","title":"Driver"},{"location":"advanced/driver/#driver-usage","text":"All described methods are implemented inside IDriverPool interface and accessible by default from any test class. To access this functionality from another places like your services just implement this interface. Each thread has their own named driver pool Supported Browsers: Chrome, Firefox, Internet Explorer, Microsoft Edge, Opera, Safari etc","title":"Driver usage"},{"location":"advanced/driver/#initialization","text":"getDriver() is the core method to start any Selenium/Appium session. It will create a RemoteWebDriver named \"default\" based on default capabilities from configuration. 1st call of the method in current thread should start new driver. Next calls will return existing object. getDriver(String name) start named driver session using default capabilities from configuration. That's allow to start several drivers (up to 3 according to max_driver_count property) getDriver(String name, DesiredCapabilities capabilities) start named driver session using custom capabilities. getDriver(String name, DesiredCapabilities capabilities, String seleniumHost) start named driver session using custom capabilities vs custom selenium url. Example: @Test public void carinaCapsTest() { // Chrome default capabilities builder usage: WebDriver chromeDriver = getDriver(\"chrome\", new ChromeCapabilities().getCapability(\"Chrome Browser\")); HomePage homePageChrome = new HomePage(chromeDriver); homePageChrome.open(); // Firefox default capabilities builder usage: getDriver(\"firefox\", new FirefoxCapabilities().getCapability(\"Firefox Browser\")); HomePage homePageFirefox = new HomePage(getDriver(\"firefox\")); // return named \"firefox\" driver from the pool to init HomePage. homePageFirefox.open(); // Safari, Edge, Opera and IE default capabilities builder usage: HomePage homePageSafari = new HomePage(getDriver(\"safari\", new SafariCapabilities().getCapability(\"Safari Browser\"))); homePageSafari.open(); getDriver(\"edge\", new EdgeCapabilities().getCapability(\"Edge Browser\")); getDriver(\"opera\", new OperaCapabilities().getCapability(\"Opera Browser\")); getDriver(\"ie\", new IECapabilities().getCapability(\"Internet Explorer Browser\")); } @Test public void desiredCapsTest() { // Manage DesiredCapabilities on your own to build complicated caps structure: DesiredCapabilities capabilities = DesiredCapabilities.safari(); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); HomePage safariHomePage = new HomePage(getDriver(\"safari\", capabilities)); safariHomePage.open(); Assert.assertTrue(safariHomePage.isPageOpened()); }","title":"Initialization"},{"location":"advanced/driver/#capabilities","text":"Simple key value Selenium/Appium pairs can be provided in _config.properties using capabilities.name=value , for example: capabilities.automationName=uiautomator2 capabilities.deviceName=Samsung_Galaxy_S10 capabilities.platformName=ANDROID capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.newCommandTimeout=180 Visit selenium or appium to see all capabilities.","title":"Capabilities"},{"location":"advanced/driver/#options","text":"Options and arguments could be provided through _config.properties using comma separated values for multiple options/args, for example: firefox_args=--no-first-run,--disable-notifications firefox_preferences= chrome_args= chrome_experimental_opts= chrome_mobile_emulation_opts= To provide complicated structures use advanced approach to build capabilities/options/arguments: public void someTest() { FirefoxOptions options = new FirefoxOptions(); options.addArguments(\"--no-first-run\"); options.addArguments(\"--disable-notifications\"); DesiredCapabilities capabilities = DesiredCapabilities.firefox(); capabilities.setCapability(CapabilityType.PLATFORM_NAME, SpecialKeywords.MAC); capabilities.setCapability(FirefoxOptions.FIREFOX_OPTIONS, options); HomePage homePage = new HomePage(getDriver(\"firefox\", capabilities)); homePage.open(); Assert.assertTrue(homePage.isPageOpened()); }","title":"Options"},{"location":"advanced/driver/#quit","text":"Quit driver operation is executed automatically based on driver init phase, i.e. no need to do it inside your test code . @BeforeSuite drivers belong to all tests/classes and will be closed in @AfterSuite only @BeforeTest drivers belong to all <test> classes and will be closed in @AfterTest . @BeforeClass drivers belong to all tests inside current class and will be closed in @AfterClass @BeforeMethod or inside Test Method drivers belong to current test method and will be closed in @AfterMethod Also driver is saved for all dependent test methods inside test class by default. To quit driver forcibly if needed use quitDriver() or quitDriver(name) To disable driver quit strategy completely and cotrol drivers init/quit on your own provide forcibly_disable_driver_quit=true or execute from any place of your test code CarinaListener.disableDriversCleanup();","title":"Quit"},{"location":"advanced/driver/#restart","text":"restartDriver() quit current driver and start new one with the same capabilities restartDriver(boolean isSameDevice) quit current driver and start new one on the same device using uuid capability. It is fully compatible with MCloud farm.","title":"Restart"},{"location":"advanced/localization/","text":"Localization usage There is an enhanced L10N utility to support localized (L10N) test automation testing. It can load localized resources on the fly and verify texts if needed. We recommend to use existing localized resources and don't generate them by automation team! Prerequisites Localized resources should be located in src/main/resources/L10N folder. Each localized resource file has unique keys with translated values. Verify that there is a must have file without any postfix like locale.properties . This file will be considered as a default localization. Implementation Define parameters in _config.properties . #Localization language locale=de_DE #Optionally you could operate browser locale as well by using browser_language=en_US #Enables auto verification for elements, that are marked with @Localized (by default it's false) localization_testing=true #Encoding for a new localization (by default UTF-8) localization_encoding=UTF-8 Then declare page elements with @Localized annotation. For example: @Localized @FindBy(id = \"pt-createaccount\") private ExtendedWebElement createAccountElem; @Localized @FindBy(id = \"pt-anoncontribs\") private ExtendedWebElement contribElem; @Localized @FindBy(xpath = \"//nav[@id='p-navigation']/descendant::ul[@class='vector-menu-content-list']/*\") private List<ExtendedWebElement> pageLinks; Add to the project resources that corresponds to @Localized elements: #!The key from locale file should have Page name + name of variable that needs to be compared. WikipediaLocalePage.createAccountElem=fi\u00f3k l\u00e9trehoz\u00e1sa WikipediaLocalePage.contribElem=k\u00f6zrem\u0171k\u00f6d\u00e9sek #!Elements from List should have the same name of a variable + current element's number WikipediaLocalePage.pageLinks0=Kezd\u0151lap WikipediaLocalePage.pageLinks1=Tartalom WikipediaLocalePage.pageLinks2=Kiemelt sz\u00f3cikkek WikipediaLocalePage.pageLinks3=Friss v\u00e1ltoztat\u00e1sok WikipediaLocalePage.pageLinks4=Lap tal\u00e1lomra WikipediaLocalePage.pageLinks5=Tudakoz\u00f3 For elements that are operated in test and marked with @Localized annotation Carina will automatically compare text from the page with text from your locale_xx_XX.properties file. Every mismatch will be collected in L10N.class. To assert collected assertions use L10N.assertAll() method. If you want to do it manually use L10N.getText(key) to get expected translations from resources: String welcomeText = wikipediaLocalePage.getWelcomeText(); String expectedWelcomeText = L10N.getText(\"welcomeText\"); Assert.assertEquals(welcomeText, expectedWelcomeText.trim(), \"Wikipedia welcome text was not the expected.\"); Resources generation To generate resources with Carina, you need to enable localization_testing parameter.For elements that are need localization, you need to mark them with @Localized and operate with them. In test call L10N.flush() to create new locale file in your project directory. Example: public void testAddNewLanguages() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); wikipediaLocalePage.hoverWelcomeText(); wikipediaLocalePage.hoverContribElem(); wikipediaLocalePage.hoverCreateAccountElem(); wikipediaLocalePage.hoverHeaders(); wikipediaLocalePage.clickDiscussionBtn(); L10N.flush(); L10N.assertAll(); // not necessary for resources generation } Finding elements with a help of locales Declare elements with L10N prefix where needed. Use key after the \":\" sign in @FindBy annotations which will be replaced by actual localized translations. @FindBy(xpath = \"//*[text()='{L10N:welcomeText}'\") private ExtendedWebElement welcomeText; @FindBy(linkText = \"{L10N:discussionElem}\") private ExtendedWebElement discussionBtn; At runtime actual translations will be used to locate elements xpath = \"//*[text()='{L10N:HomePage.welcomeText}'\" # actual value at run-time: xpath = \"//*[text()='Willkommen bei Wikipedia'\"","title":"Localization"},{"location":"advanced/localization/#localization-usage","text":"There is an enhanced L10N utility to support localized (L10N) test automation testing. It can load localized resources on the fly and verify texts if needed. We recommend to use existing localized resources and don't generate them by automation team!","title":"Localization usage"},{"location":"advanced/localization/#prerequisites","text":"Localized resources should be located in src/main/resources/L10N folder. Each localized resource file has unique keys with translated values. Verify that there is a must have file without any postfix like locale.properties . This file will be considered as a default localization.","title":"Prerequisites"},{"location":"advanced/localization/#implementation","text":"Define parameters in _config.properties . #Localization language locale=de_DE #Optionally you could operate browser locale as well by using browser_language=en_US #Enables auto verification for elements, that are marked with @Localized (by default it's false) localization_testing=true #Encoding for a new localization (by default UTF-8) localization_encoding=UTF-8 Then declare page elements with @Localized annotation. For example: @Localized @FindBy(id = \"pt-createaccount\") private ExtendedWebElement createAccountElem; @Localized @FindBy(id = \"pt-anoncontribs\") private ExtendedWebElement contribElem; @Localized @FindBy(xpath = \"//nav[@id='p-navigation']/descendant::ul[@class='vector-menu-content-list']/*\") private List<ExtendedWebElement> pageLinks; Add to the project resources that corresponds to @Localized elements: #!The key from locale file should have Page name + name of variable that needs to be compared. WikipediaLocalePage.createAccountElem=fi\u00f3k l\u00e9trehoz\u00e1sa WikipediaLocalePage.contribElem=k\u00f6zrem\u0171k\u00f6d\u00e9sek #!Elements from List should have the same name of a variable + current element's number WikipediaLocalePage.pageLinks0=Kezd\u0151lap WikipediaLocalePage.pageLinks1=Tartalom WikipediaLocalePage.pageLinks2=Kiemelt sz\u00f3cikkek WikipediaLocalePage.pageLinks3=Friss v\u00e1ltoztat\u00e1sok WikipediaLocalePage.pageLinks4=Lap tal\u00e1lomra WikipediaLocalePage.pageLinks5=Tudakoz\u00f3 For elements that are operated in test and marked with @Localized annotation Carina will automatically compare text from the page with text from your locale_xx_XX.properties file. Every mismatch will be collected in L10N.class. To assert collected assertions use L10N.assertAll() method. If you want to do it manually use L10N.getText(key) to get expected translations from resources: String welcomeText = wikipediaLocalePage.getWelcomeText(); String expectedWelcomeText = L10N.getText(\"welcomeText\"); Assert.assertEquals(welcomeText, expectedWelcomeText.trim(), \"Wikipedia welcome text was not the expected.\");","title":"Implementation"},{"location":"advanced/localization/#resources-generation","text":"To generate resources with Carina, you need to enable localization_testing parameter.For elements that are need localization, you need to mark them with @Localized and operate with them. In test call L10N.flush() to create new locale file in your project directory. Example: public void testAddNewLanguages() { WikipediaHomePage wikipediaHomePage = new WikipediaHomePage(getDriver()); wikipediaHomePage.open(); WikipediaLocalePage wikipediaLocalePage = wikipediaHomePage.goToWikipediaLocalePage(getDriver()); wikipediaLocalePage.hoverWelcomeText(); wikipediaLocalePage.hoverContribElem(); wikipediaLocalePage.hoverCreateAccountElem(); wikipediaLocalePage.hoverHeaders(); wikipediaLocalePage.clickDiscussionBtn(); L10N.flush(); L10N.assertAll(); // not necessary for resources generation }","title":"Resources generation"},{"location":"advanced/localization/#finding-elements-with-a-help-of-locales","text":"Declare elements with L10N prefix where needed. Use key after the \":\" sign in @FindBy annotations which will be replaced by actual localized translations. @FindBy(xpath = \"//*[text()='{L10N:welcomeText}'\") private ExtendedWebElement welcomeText; @FindBy(linkText = \"{L10N:discussionElem}\") private ExtendedWebElement discussionBtn; At runtime actual translations will be used to locate elements xpath = \"//*[text()='{L10N:HomePage.welcomeText}'\" # actual value at run-time: xpath = \"//*[text()='Willkommen bei Wikipedia'\"","title":"Finding elements with a help of locales"},{"location":"advanced/program_flow/","text":"Program flow Under the hood Carina use TestNG framework, so the first class to initialize is RemoteTestNGStarter.class. Program life cycle logic could be observed at TestNG.class run() method. The initializing turn comes to Carina when CarinaListenerChain.class object created. It extends ListenerChain.class which will create, sort and attach AbstractTest.class listeners. This whole sequence is described in TestRunner.class init() method. AbstractTest.class listeners are: @LinkedListeners({ CarinaListener.class, TestRunListener.class, DataProviderInterceptor.class }) Theese listeners being attached and created when transform(IListenersAnnotation annotation, Class testClass) method is called. TestRunListener.class and DataProviderInterceptor.class are implemented in zebrunner. CarinaListener.class as it comes from the name is a Carina's listener. Because CarinaListener object created, the class static field is initialized in it. There are several important steps inside: R.reinit(). This method load's default values for all parameters from carina-core , then override's them with users configuration (api.properties, config.properties, testdata.properties, email.properties, report.properties, database.properties). Configure log4j properties Initializing L10N feature. Then listeners attached to different Lists according to their implementations in TestNG: After that methods are called in appropriate order in the ListenerChain.class : onStart(ISuite suite). There is called every ISuiteListener's onStart() method that where mentioned in AbstractTest.class (CarinaListener and TestRunListener). CarinaListener.class onStart(ISuite suite) method will configure logging level and thread count. now your test class is considered initialized and onStart(ITestContext testContext) method is called. Udid is generated there. onBeforeClass(ITestClass testClass). Complete steps described in @BeforeClass annotation from your test. onTestStart(ITestResult result) provide described data to test. Next TestRunner.class runs code described in your test.class. The following route depends on what you are doing in your test: UI (web, mobile) @Test @MethodOwner() public void webTest() { HomePage chromeHomePage = new HomePage(getDriver()); chromeHomePage.open(); Assert.assertTrue(chromeHomePage.isPageOpened(), \"Chrome home page is not opened!\"); } Debug entry point at : AbstractPage constructor and IDriverPool getDriver() method. API @Test() public void testCreateUser() throws Exception { PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } Debug entry point at : AbstractApiMethodV2 constructor. Database @Test public void createUser() { User USER = new User() {{ setUsername(\"bmarley\"); setFirstName(\"Bob\"); setLastName(\"Marley\"); setStatus(Status.ACTIVE); }}; try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } These are user's classes, samples at carina-demo: UserMapper , ConnectionFactory , User .","title":"Program flow"},{"location":"advanced/program_flow/#program-flow","text":"Under the hood Carina use TestNG framework, so the first class to initialize is RemoteTestNGStarter.class. Program life cycle logic could be observed at TestNG.class run() method. The initializing turn comes to Carina when CarinaListenerChain.class object created. It extends ListenerChain.class which will create, sort and attach AbstractTest.class listeners. This whole sequence is described in TestRunner.class init() method. AbstractTest.class listeners are: @LinkedListeners({ CarinaListener.class, TestRunListener.class, DataProviderInterceptor.class }) Theese listeners being attached and created when transform(IListenersAnnotation annotation, Class testClass) method is called. TestRunListener.class and DataProviderInterceptor.class are implemented in zebrunner. CarinaListener.class as it comes from the name is a Carina's listener. Because CarinaListener object created, the class static field is initialized in it. There are several important steps inside: R.reinit(). This method load's default values for all parameters from carina-core , then override's them with users configuration (api.properties, config.properties, testdata.properties, email.properties, report.properties, database.properties). Configure log4j properties Initializing L10N feature. Then listeners attached to different Lists according to their implementations in TestNG: After that methods are called in appropriate order in the ListenerChain.class : onStart(ISuite suite). There is called every ISuiteListener's onStart() method that where mentioned in AbstractTest.class (CarinaListener and TestRunListener). CarinaListener.class onStart(ISuite suite) method will configure logging level and thread count. now your test class is considered initialized and onStart(ITestContext testContext) method is called. Udid is generated there. onBeforeClass(ITestClass testClass). Complete steps described in @BeforeClass annotation from your test. onTestStart(ITestResult result) provide described data to test. Next TestRunner.class runs code described in your test.class. The following route depends on what you are doing in your test: UI (web, mobile) @Test @MethodOwner() public void webTest() { HomePage chromeHomePage = new HomePage(getDriver()); chromeHomePage.open(); Assert.assertTrue(chromeHomePage.isPageOpened(), \"Chrome home page is not opened!\"); } Debug entry point at : AbstractPage constructor and IDriverPool getDriver() method. API @Test() public void testCreateUser() throws Exception { PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } Debug entry point at : AbstractApiMethodV2 constructor. Database @Test public void createUser() { User USER = new User() {{ setUsername(\"bmarley\"); setFirstName(\"Bob\"); setLastName(\"Marley\"); setStatus(Status.ACTIVE); }}; try (SqlSession session = ConnectionFactory.getSqlSessionFactory().openSession(true)) { UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.create(USER); checkUser(userMapper.findById(USER.getId())); } } These are user's classes, samples at carina-demo: UserMapper , ConnectionFactory , User .","title":"Program flow"},{"location":"advanced/proxy/","text":"Proxy usage There is a possibility to send all test traffic via proxy including the embedded light-weight BrowserMob proxy server. There are several properties available to manage all kinds of proxy usage: proxy_host=NULL proxy_port=NULL proxy_protocols=http,https,ftp proxy_set_to_system=true browsermob_proxy=false browsermob_disabled_mitm=false browsermob_port=0 Declare proxy_host, proxy_port and proxy_protocols to send all Web and API test traffic via your static network proxy. Also, to enable proxy for TestNG Java process, proxy_set_to_system must be specifed to true , otherwise only WebDrivers and API clients will be proxied. Note: The above settings are mostly required to get public internet access through corporate proxies. Raising inbuilt proxy-server (BrowserMob) Also, Carina can start an embedded proxy to proxy/view/filter requests/responses. There is an inbuilt library BrowserMobProxy in Carina-proxy module. Below you can find BrowserMob proxy related parameters in your config.properties file: browsermob_proxy=true browsermob_disabled_mitm=false browsermob_port=0 browsermob_ports_range=NULL With the enabled browsermob_proxy , Carina will start the dedicated proxy instance on every test method. Carina automatically detects an IP address for your local browsermob proxy and puts it into the capabilities in case if proxy_host=NULL . If you want to map some publicly available IP address for your browsermob proxy instance then you'll need to override it via proxy_host property. E.g. proxy_host=myhostname is useful in case of running maven process inside a docker container. Override the hostname, and it will be available from Selenium instance. browsermob_port=0 means that Carina dynamically identifies a free port for a proxy session. browsermob_ports_range=8001:8003 means that Carina will use only ports from given range for starting of browsermob sessions. That's reasonable for cases when only several ports are shared at environment and can be accessed from other machines within the network. If all ports are used then test will wait for the first freed port. browsermob_disabled_mitm is disabled by default. Important! If you have troubles with SSL traffic sniffing, the first thing you should do is to change browsermob_disabled_mitm property value! Using proxy-server in Java code: Make sure the driver instance is already started: getDriver(); Note: During the driver startup, Carina automatically starts proxy and adjusts browser capabilities to track the desired protocols. To get proxy instance for the current test/thread, you can call: BrowserMobProxy proxy = ProxyPool.getProxy(); Enable the required Har capture type using: proxy.enableHarCaptureTypes(CaptureType.REQUEST_CONTENT, CaptureType.RESPONSE_CONTENT); There are a lot of possible content types: CaptureType.RESPONSE_COOKIES CaptureType.RESPONSE_HEADERS CaptureType.REQUEST_HEADERS CaptureType.RESPONSE_CONTENT CaptureType.REQUEST_CONTENT ... They all can be set as comma-separated parameters. You may want to save the captured content into a .har file: proxy.newHar(HAR_NAME); //Some testing activity... //Saving har to a file... File file = new File(HAR_NAME + \".har\"); Assert.assertNotNull(proxy.getHar(), \"Har is NULL!\"); try { proxy.getHar().writeTo(file); } catch (IOException e) { e.printStackTrace(); } Your .har file will be created in the project root folder There are four methods to support request and response interception: addRequestFilter addResponseFilter addFirstHttpFilterFactory addLastHttpFilterFactory To add and configure content filters, look here . Dealing with MITM and installing SSL certificate into your system: For Mac users: Go here and save it as ca-certificate-rsa.cer . A double click creates a file. The next window should appear: After authorization, the certificate will be added into your system certificates, but it's still untrusted: To make it trusted, double click on it. The following window should appear: First, click the drop-down menu and select Always Trust option. Then close the window (a second authorization will be required): Make sure the red cross on your certificate turned into a blue one: Adding SSL certificate into Java keystore: If you are still receiving the following exception: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target you may need to set up ca-certificate-rsa.cer into your Java keystore. For Mac and Linux users: sudo keytool -importcert -alias browsermob -file pathToYourCertificateLocation/BrowserMobCertificate.crt -keystore /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/security/cacerts You will be asked to enter your Mac profile password and a Java keystore password (by default: changeit).","title":"Proxy"},{"location":"advanced/proxy/#proxy-usage","text":"There is a possibility to send all test traffic via proxy including the embedded light-weight BrowserMob proxy server. There are several properties available to manage all kinds of proxy usage: proxy_host=NULL proxy_port=NULL proxy_protocols=http,https,ftp proxy_set_to_system=true browsermob_proxy=false browsermob_disabled_mitm=false browsermob_port=0 Declare proxy_host, proxy_port and proxy_protocols to send all Web and API test traffic via your static network proxy. Also, to enable proxy for TestNG Java process, proxy_set_to_system must be specifed to true , otherwise only WebDrivers and API clients will be proxied. Note: The above settings are mostly required to get public internet access through corporate proxies.","title":"Proxy usage"},{"location":"advanced/proxy/#raising-inbuilt-proxy-server-browsermob","text":"Also, Carina can start an embedded proxy to proxy/view/filter requests/responses. There is an inbuilt library BrowserMobProxy in Carina-proxy module. Below you can find BrowserMob proxy related parameters in your config.properties file: browsermob_proxy=true browsermob_disabled_mitm=false browsermob_port=0 browsermob_ports_range=NULL With the enabled browsermob_proxy , Carina will start the dedicated proxy instance on every test method. Carina automatically detects an IP address for your local browsermob proxy and puts it into the capabilities in case if proxy_host=NULL . If you want to map some publicly available IP address for your browsermob proxy instance then you'll need to override it via proxy_host property. E.g. proxy_host=myhostname is useful in case of running maven process inside a docker container. Override the hostname, and it will be available from Selenium instance. browsermob_port=0 means that Carina dynamically identifies a free port for a proxy session. browsermob_ports_range=8001:8003 means that Carina will use only ports from given range for starting of browsermob sessions. That's reasonable for cases when only several ports are shared at environment and can be accessed from other machines within the network. If all ports are used then test will wait for the first freed port. browsermob_disabled_mitm is disabled by default. Important! If you have troubles with SSL traffic sniffing, the first thing you should do is to change browsermob_disabled_mitm property value!","title":"Raising inbuilt proxy-server (BrowserMob)"},{"location":"advanced/proxy/#using-proxy-server-in-java-code","text":"Make sure the driver instance is already started: getDriver(); Note: During the driver startup, Carina automatically starts proxy and adjusts browser capabilities to track the desired protocols. To get proxy instance for the current test/thread, you can call: BrowserMobProxy proxy = ProxyPool.getProxy(); Enable the required Har capture type using: proxy.enableHarCaptureTypes(CaptureType.REQUEST_CONTENT, CaptureType.RESPONSE_CONTENT); There are a lot of possible content types: CaptureType.RESPONSE_COOKIES CaptureType.RESPONSE_HEADERS CaptureType.REQUEST_HEADERS CaptureType.RESPONSE_CONTENT CaptureType.REQUEST_CONTENT ... They all can be set as comma-separated parameters. You may want to save the captured content into a .har file: proxy.newHar(HAR_NAME); //Some testing activity... //Saving har to a file... File file = new File(HAR_NAME + \".har\"); Assert.assertNotNull(proxy.getHar(), \"Har is NULL!\"); try { proxy.getHar().writeTo(file); } catch (IOException e) { e.printStackTrace(); } Your .har file will be created in the project root folder There are four methods to support request and response interception: addRequestFilter addResponseFilter addFirstHttpFilterFactory addLastHttpFilterFactory To add and configure content filters, look here .","title":"Using proxy-server in Java code:"},{"location":"advanced/proxy/#dealing-with-mitm-and-installing-ssl-certificate-into-your-system","text":"","title":"Dealing with MITM and installing SSL certificate into your system:"},{"location":"advanced/proxy/#for-mac-users","text":"Go here and save it as ca-certificate-rsa.cer . A double click creates a file. The next window should appear: After authorization, the certificate will be added into your system certificates, but it's still untrusted: To make it trusted, double click on it. The following window should appear: First, click the drop-down menu and select Always Trust option. Then close the window (a second authorization will be required): Make sure the red cross on your certificate turned into a blue one:","title":"For Mac users:"},{"location":"advanced/proxy/#adding-ssl-certificate-into-java-keystore","text":"If you are still receiving the following exception: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target you may need to set up ca-certificate-rsa.cer into your Java keystore.","title":"Adding SSL certificate into Java keystore:"},{"location":"advanced/proxy/#for-mac-and-linux-users","text":"sudo keytool -importcert -alias browsermob -file pathToYourCertificateLocation/BrowserMobCertificate.crt -keystore /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/security/cacerts You will be asked to enter your Mac profile password and a Java keystore password (by default: changeit).","title":"For Mac and Linux users:"},{"location":"advanced/security/","text":"Security Security functionality in Carina framework is required for sensitive data that should be hidden in test configurations and logging. It uses a symmetric key encryption algorithm for security implementation, which means that anyone may encrypt/decrypt the data in the same way, using the same key. In Carina framework, AES encryption is used by default with a 128-bit security key. Anyone may generate their own security key and encrypt the data using this key, so that the decrypted valid data may be used in the test only if the valid key is specified in the test configuration. Also, one may use the default common key located in test resources, giving access to all other users for secured data decryption. Secured data preparation For secured data preparation, we implemented a special tool that helps to generate crypto keys and encrypt/decrypt test data files. Here is a usage tip: com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -generate -key_file \"file_path_to_save_key\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -encrypt -string \"string_to_encrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -decrypt -string \"string_to_decrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -encrypt -file \"csv_file_to_encrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -decrypt -file \"csv_file_to_decrypt\" -key_file \"key_file_path\" To generate an individual crypto key: Go to \"Run configuration\" in Eclipse Create a new Java application configuration selecting the project and the main class com.qaprosoft.carina.core.foundation.crypto.CryptoConsole : Set arguments Press Apply and then Run A crypto key will be generated: To prepare a test data file with secured data: Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values. Go to \u201cRun configuration\u201d, navigate to the arguments tab and execute the encryption command specifying the key path and input file: A file with encrypted data will be generated: To encrypt a single string, use the following config: The encrypted string will be shown in the console: To decrypt the encrypted file, execute: The decrypted file will be generated: Secured data usage You may use encrypted values, both in test configuration and test data files; pay attention to the fact that there is no explicit BeforeTest listener for data decryption, so there is no way to find out later in the test if the data is sensitive or not. All the decryption logic is located in WebDriverHelper that wraps Selenium WebDriver methods for interaction with UI and encapsulates action logging logic. Every method that receives a text tests if the text contains {crypt:...} pattern, and if it does, decrypts it and passes it to UI- logging, and screenshots are populated with hidden characters: \u0421arina also supports advanced decryption. This means that you can decrypt only the part of the string that you need. This the decryptByPattern method of the CryptoTool class. To decrypt your string use it like this: String value = \"test@gmail.com/{crypt:8O9iA4+f3nMzz85szmvKmQ==}\" CryptoTool cryptoTool = new CryptoTool(\"path_to_your_crypto_key\"); Pattern CRYPTO_PATTERN = Pattern.compile(SpecialKeywords.CRYPT); String decryptedValue = cryptoTool.decryptByPattern(value, CRYPTO_PATTERN); As a result decryptedValue will be test@gmail.com/EncryptMe .","title":"Security"},{"location":"advanced/security/#security","text":"Security functionality in Carina framework is required for sensitive data that should be hidden in test configurations and logging. It uses a symmetric key encryption algorithm for security implementation, which means that anyone may encrypt/decrypt the data in the same way, using the same key. In Carina framework, AES encryption is used by default with a 128-bit security key. Anyone may generate their own security key and encrypt the data using this key, so that the decrypted valid data may be used in the test only if the valid key is specified in the test configuration. Also, one may use the default common key located in test resources, giving access to all other users for secured data decryption.","title":"Security"},{"location":"advanced/security/#secured-data-preparation","text":"For secured data preparation, we implemented a special tool that helps to generate crypto keys and encrypt/decrypt test data files. Here is a usage tip: com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -generate -key_file \"file_path_to_save_key\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -encrypt -string \"string_to_encrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -decrypt -string \"string_to_decrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -encrypt -file \"csv_file_to_encrypt\" -key_file \"key_file_path\" com.qaprosoft.carina.core.foundation.crypto.CryptoConsole -decrypt -file \"csv_file_to_decrypt\" -key_file \"key_file_path\" To generate an individual crypto key: Go to \"Run configuration\" in Eclipse Create a new Java application configuration selecting the project and the main class com.qaprosoft.carina.core.foundation.crypto.CryptoConsole : Set arguments Press Apply and then Run A crypto key will be generated: To prepare a test data file with secured data: Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values Prepare an input file using the pattern {crypt:str_to_encrypt} for secured values. Go to \u201cRun configuration\u201d, navigate to the arguments tab and execute the encryption command specifying the key path and input file: A file with encrypted data will be generated: To encrypt a single string, use the following config: The encrypted string will be shown in the console: To decrypt the encrypted file, execute: The decrypted file will be generated:","title":"Secured data preparation"},{"location":"advanced/security/#secured-data-usage","text":"You may use encrypted values, both in test configuration and test data files; pay attention to the fact that there is no explicit BeforeTest listener for data decryption, so there is no way to find out later in the test if the data is sensitive or not. All the decryption logic is located in WebDriverHelper that wraps Selenium WebDriver methods for interaction with UI and encapsulates action logging logic. Every method that receives a text tests if the text contains {crypt:...} pattern, and if it does, decrypts it and passes it to UI- logging, and screenshots are populated with hidden characters: \u0421arina also supports advanced decryption. This means that you can decrypt only the part of the string that you need. This the decryptByPattern method of the CryptoTool class. To decrypt your string use it like this: String value = \"test@gmail.com/{crypt:8O9iA4+f3nMzz85szmvKmQ==}\" CryptoTool cryptoTool = new CryptoTool(\"path_to_your_crypto_key\"); Pattern CRYPTO_PATTERN = Pattern.compile(SpecialKeywords.CRYPT); String decryptedValue = cryptoTool.decryptByPattern(value, CRYPTO_PATTERN); As a result decryptedValue will be test@gmail.com/EncryptMe .","title":"Secured data usage"},{"location":"automation/api/","text":"Note: Starting from 7.0.4 consider that instead of extends AbstractTest we have to implements IAbstractTest interface Introduction Rest API testing is a vital part of integration testing process, it may be used separately or together with web, mobile or DB testing. The general process may be described by the following steps: Compile an HTTP request with the required meta data Send the prepared data to the required server endpoint Validate the HTTP status and response data Extract some response data for the next requests Build a call to the next (or the same) endpoint using (or not using) the data from the previous response The schema below demonstrates the sequence: From this perspective, we decided to use the following instruments: Rest-assured - \"Testing and validation of REST services in Java are harder than in dynamic languages such as Ruby and Groovy. REST Assured brings the simplicity of using these languages into the Java domain.\" Freemarker - \"Apache FreeMarker is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data.\" JsonPath - a library for extracting data from JSON body JsonAssert - a library for comparing the actual JSON body with an expected one Json-schema-validator - a library for validating of JSON body for matching to JSON schema Example of test implementation Let's create an automated test for the next call: POST https://jsonplaceholder.typicode.com/users request with a request body [ { \"id\": 1, \"name\": \"SOME_NAME\", \"username\": \"SOME_USERNAME\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"SOME_COMPANY_NAME\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } ] and the response body the same as the request body Definition of request and response templates If we are going to send POST request, we need to create a request template with some placeholders that may be replaced by different arguments for different test flows. The best place to store these resources is src/test/resources/api package, try to keep REST hierarchy in a package structure for better maintenance and visibility: Request (rq.json) and response (rs.json) templates have some placeholders that will be populated from the tests later on: While user.properties contains some default value which may be replaced later: REST service call domain object Now we are ready to create REST service domain object which will be used to interact with web service and perform additional response validations. Our domain object is located in /carina-demo/src/main/java/com/qaprosoft/carina/demo/api, make sure that it extends AbstractApiMethodV2 and triggers the base class constructor for initialization. In general cases, you will specify the path to request and response templates along with default properties files (all of them have been created in the previous step). Also, we replace the URL placeholder to set an appropriate environment. package com.qaprosoft.carina.demo.api; import com.qaprosoft.carina.core.foundation.api.AbstractApiMethodV2; import com.qaprosoft.carina.core.foundation.utils.Configuration; public class PostUserMethod extends AbstractApiMethodV2 { public PostUserMethod() { super(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } } HTTP method and path The last step before the test implementation itself is the association of the domain object class and the required HTTP method and path. It should be defined in /carina-demo/src/main/resources/_api.properties file, the key should be equal to domain class name, the value has the following pattern {http_method}:{http_path}. The HTTP path may contain placeholders, the HTTP method should be one of the following variants: GET, POST, PUT, UPDATE, DELETE. #=====================================================# #=================== API methods ====================# #=====================================================# GetUserMethods=GET:${base_url}/users PostUserMethod=POST:${base_url}/users DeleteUserMethod=DELETE:${base_url}/users/1 PutPostsMethod=PUT:${base_url}/posts/1 PatchPostsMethod=PATCH:${base_url}/posts/1 API test API test is a general TestNG test, a class should extend APITest, in our case, the test implements IAbstractTest that encapsulates some test data and login method. The test is located in /carina-demo/src/test/java/com/qaprosoft/carina/demo. package com.qaprosoft.carina.demo; import java.lang.invoke.MethodHandles; import com.qaprosoft.carina.core.foundation.IAbstractTest; import org.skyscreamer.jsonassert.JSONCompareMode; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.testng.annotations.Test; import com.qaprosoft.apitools.validation.JsonCompareKeywords; import com.qaprosoft.carina.core.foundation.api.http.HttpResponseStatusType; import com.qaprosoft.carina.core.foundation.utils.ownership.MethodOwner; import com.qaprosoft.carina.core.foundation.utils.tag.Priority; import com.qaprosoft.carina.core.foundation.utils.tag.TestPriority; import com.qaprosoft.carina.demo.api.DeleteUserMethod; import com.qaprosoft.carina.demo.api.GetUserMethods; import com.qaprosoft.carina.demo.api.PostUserMethod; /** * This sample shows how create REST API tests. * * @author qpsdemo */ public class APISampleTest implements IAbstractTest { private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() throws Exception { LOGGER.info(\"test\"); setCases(\"4555,54545\"); PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUserMissingSomeFields() throws Exception { PostUserMethod api = new PostUserMethod(); api.getProperties().remove(\"name\"); api.getProperties().remove(\"username\"); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testGetUsers() { GetUserMethods getUsersMethods = new GetUserMethods(); getUsersMethods.expectResponseStatus(HttpResponseStatusType.OK_200); getUsersMethods.callAPI(); getUsersMethods.validateResponse(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey()); getUsersMethods.validateResponseAgainstSchema(\"api/users/_get/rs.schema\"); } @Test() @MethodOwner(owner = \"qpsdemo\") @TestPriority(Priority.P1) public void testDeleteUsers() { DeleteUserMethod deleteUserMethod = new DeleteUserMethod(); deleteUserMethod.expectResponseStatus(HttpResponseStatusType.OK_200); deleteUserMethod.callAPI(); deleteUserMethod.validateResponse(); } } Test steps once again Create REST call object Specify the properties for a request/response placeholder Add headers if required Specify the expected HTTP status Call API Validate the response by a template or parse some data by JSON path Make further calls using the data from the previous call if needed Useful features The framework contains a list of useful features for building requests and validation of responses. It makes the support of such tests easier and at the same time minimizes the amount of test data. Wildcards In some cases, you may need to generate data in the request to make the request data unique. The best way to do this is to use wildcards for data generation: { \"username\": \"generate_word(10)\", // Will generate random alphanumeric string with 10 characters \"zip\": \"generate_number(6)\", // Will generate random number with 6 digits \"birthday\": \"generate_date(yyyy-MM-dd;0)\" // Will generate current date (first arg is date format, second is delta in days from now) } Another option is to specify the placeholder in the request template and then pass some generated value directly from the test method. Wildcards are also useful for response validation. In some cases, you may need to skip some values or validate by regex: { \"id\": \"skip\", // Will skip actual value validation and just verify id key presence \"signup_date\": \"regex:\\\\d{4}-\\\\d{2}-\\\\d{2}\", // Will validate date value by specified regex } Validation against JSON schema When you need to validate response structure regardless of the actual values, you may use validation by JSON schema. In this case, you need an actual response from the service, let's say we have the following: { \"email\": \"test@domain.com\", \"firstName\": \"SOME FIRST NAME\", \"id\": 11111 } Now we need to generate a schema (you may use any generator you like, for example, https://jsonschema.net/). IMPORTANT: For now, the schemas of version draft03 and draft04 are supported only. Please, use the appropriate generator (e.g. https://www.liquid-technologies.com/online-json-to-schema-converter) In the tool like this you need to provide the original JSON from the response, then choose some schema options (allow the additional properties in objects, mark the current object properties as required, hard-code some expected values, etc.) and then generate the schema. Copy-paste the generated schema into test resources, and you're ready to use it in the test. Make sure that you change all the required flags to true. After that, create a new file in the resources and place it into an appropriate endpoint package: { \"type\":\"object\", \"$schema\": \"http://json-schema.org/draft-03/schema\", \"id\": \"http://jsonschema.net\", \"required\":true, \"properties\":{ \"email\": { \"type\":\"string\", \"id\": \"http://jsonschema.net/email\", \"required\":true }, \"firstName\": { \"type\":\"string\", \"id\": \"http://jsonschema.net/firstName\", \"required\":true }, \"id\": { \"type\":\"number\", \"id\": \"http://jsonschema.net/id\", \"required\":true } } } And finally, we call JSON validation from Java test as the following: @Test public void testCheckJSONSchema() { PostUserLoginMethod api = new PostUserLoginMethod(); api.expectResponseStatus(HttpResponseStatusType.OK_200); api.callAPI(); api.validateResponseAgainstJSONSchema(\"api/testdata/users/login/_post/rs.schema\"); } Building requests with an array There are a couple of options for building a request with an array of items provided by the framework: 1. The first one uses hardcoded placeholders for changeable variables. { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ { \"name\": \"${task_name_1}\", \"description\": \"${task_description_1}\" } <#if task_name_2?exists || task_description_2?exists>, { \"name\": \"${task_name_2}\", \"description\": \"${task_description_2}\" } </#if> <#if task_name_3?exists || task_description_3?exists>, { \"name\": \"${task_name_3}\", \"description\": \"${task_description_3}\" } </#if> ] } As you see, this structure is quite flexible. If you need 2 taskTypes items, you need to declare at least task_name_2 or task_description_2 property. If you need 3 items in addition to that, you need to declare a task_name_3 or task_description_3 property. Otherwise, the array will contain only 1 item. For instance, you need to build JSON which contains a taskTypes array. Then the template with placeholders will be the following: It's easy to extend such a structure. You just need to add items with similar placeholders increasing their index. Another approach is based on using Freemarker loop. Here is the template example for the same JSON: <#if task_name_1?exists> <#assign task_names = [task_name_1]> <#assign task_descriptions = [task_description_1]> </#if> <#if task_name_2?exists> <#assign task_names = [task_name_1, task_name_2]> <#assign task_descriptions = [task_description_1, task_description_2]> </#if> <#if task_name_3?exists> <#assign task_names = [task_name_1, task_name_2, task_name_3]> <#assign task_descriptions = [task_description_1, task_description_2, task_description_3]> </#if> { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ <#list 0..task_names?size-1 as i> { \"name\": \"${task_names[i]}\", \"description\": \"${task_descriptions[i]}\" } <#if (i + 1) < task_names?size>,</#if> </#list> ] } This approach is useful when the structure of an array item is quite complex. So, it makes sense to specify the item attributes only once, doing it inside #list operation. This approach also allows to choose the amount of array items dynamically. But note that you should specify all properties for every item, so this view cannot be used for negative tests when you need to miss some properties. Validation of responses with an array Sometimes you can face a situation when you need to validate the presence of only one item (or a couple of them) in a JSON array ignoring the rest of the items. In such case, you can use a validation option ARRAY_CONTAINS. Here is a code sample: JSONAssert.assertEquals(expectedRs, actualRs, new JsonKeywordsComparator(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey() + \"content\")); The expected array: { \"totalElements\": \"skip\", \"pageNumber\": \"skip\", \"pageSize\": \"skip\", \"content\": [ { \"id\": skip, \"brand\": \"skip\", \"clientName\": \"CLIENT 1\" }, { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 2\" } ] } And the actual response: { \"totalElements\": 1017, \"pageNumber\": 0, \"pageSize\": 100, \"content\": [ { \"id\": 11111, \"brand\": \"test\", \"clientName\": \"CLIENT 1\" }, { \"id\": 22222, \"brand\": \"test\", \"clientName\": \"CLIENT 2\" }, { \"id\": 3333, \"brand\": \"test\", \"clientName\": \"CLIENT 3\" }, { \"id\": 4444, \"brand\": \"test\", \"clientName\": \"CLIENT 4\" } ] } Deserialization of JSON Sometimes you may need to transform your JSON response to POJO. It may be useful if you need to validate your response using the data from a database as the expected data. For this purpose, it's better to use Jackson libraries that are already included in Carina framework. For this, you need to prepare the domain class based on your JSON structure. Some online resources provide such opportunities, like https://timboudreau.com/blog/json/read. Let's say we need to deserialize an array of Clients from JSON. An example of the required domain object will be: import org.codehaus.jackson.annotate.JsonCreator; import org.codehaus.jackson.annotate.JsonProperty; public final class Clients { public final Client clients[]; @JsonCreator public Clients(@JsonProperty(\"clients\") Client[] clients) { this.clients = clients; } public static final class Client { public final long id; public final String brand; public final String clientName; ...... @JsonCreator public Client(@JsonProperty(\"id\") long id, @JsonProperty(\"brand\") String brand, @JsonProperty(\"clientName\") String clientName,.....) { this.id = id; this.brand = brand; this.clientName = clientName; ......... } } public Client[] getClients() { return clients; } } Pay attention that POJO field names can differ from JSON properties. In this case, @JsonProperty annotation can be used for mapping. An example of a deserialization code: GetClientsMethod getClientsMethod = new GetClientsMethod(\"11111\"); getClientsMethod.expectResponseStatus(HttpResponseStatusType.OK_200); String rs = getClientsMethod.callAPI().asString(); ObjectMapper mapper = new ObjectMapper(); Clients clients = mapper.readValue(rs, Clients.class); Then you can use POJO object for any kind of validation or for easy retrieving of the required properties. Security Carina provides some security features that could be used to hide/protect sensitive data in your API calls. Encryption of API method properties It's possible to use default carina crypto logic for automatic decription of sensitive data. In order to encrypt the data you can use carina's CryptoConsole Then you can save your encrypted properties using default pattern: \"{crypt:ENCRYPTED_TXT}\" During properties parsing process carina-api module will automatically decrypt the text and put decrypted value into request body. Hiding of API request headers In order to hide the value of API request header you need to annotate your API method with @HideRequestHeadersInLogs annotation. Usage sample: @HideRequestHeadersInLogs(headers = \"Content-Type\") public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Then in your test logs for mentioned headers you'll get \"[ BLACKLISTED ]\" mask Hiding of API call body parts If you want not to show some sensitive data in body of your api calls in test logs then you'll need to annotate your API method with @HideRequestBodyPartsInLogs/@HideResponseBodyPartsInLogs annotations. These annotations support both json and xml content type. As the value of annotation you need to pass array of JSON or XML paths you want to hide. Once done in test logs you'll get \"********\" mask instead of actual values. Example for json: @HideRequestBodyPartsInLogs(paths = { \"$.[*].username\", \"$.[*].id\" }) @HideResponseBodyPartsInLogs(paths = { \"$.[*].address.zipcode\", \"$.[*].address.geo.lat\", \"$.[*].id\" }) public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Example for xml: @HideRequestBodyPartsInLogs(paths = { \"//root/city/text()\" }) @HideResponseBodyPartsInLogs(paths = { \"//root/state/text()\" }) @ContentType(type = \"application/xml\") public class XmlPostMethod extends AbstractApiMethodV2 { public XmlPostMethod() { } } Important: for XML content type it's obligatory to pass @ContentType annotation to your API method indicating actual header value. If @ContentType is not specified then data will be automatically considered as JSON.","title":"API"},{"location":"automation/api/#introduction","text":"Rest API testing is a vital part of integration testing process, it may be used separately or together with web, mobile or DB testing. The general process may be described by the following steps: Compile an HTTP request with the required meta data Send the prepared data to the required server endpoint Validate the HTTP status and response data Extract some response data for the next requests Build a call to the next (or the same) endpoint using (or not using) the data from the previous response The schema below demonstrates the sequence: From this perspective, we decided to use the following instruments: Rest-assured - \"Testing and validation of REST services in Java are harder than in dynamic languages such as Ruby and Groovy. REST Assured brings the simplicity of using these languages into the Java domain.\" Freemarker - \"Apache FreeMarker is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data.\" JsonPath - a library for extracting data from JSON body JsonAssert - a library for comparing the actual JSON body with an expected one Json-schema-validator - a library for validating of JSON body for matching to JSON schema","title":"Introduction"},{"location":"automation/api/#example-of-test-implementation","text":"Let's create an automated test for the next call: POST https://jsonplaceholder.typicode.com/users request with a request body [ { \"id\": 1, \"name\": \"SOME_NAME\", \"username\": \"SOME_USERNAME\", \"email\": \"Sincere@april.biz\", \"address\": { \"street\": \"Kulas Light\", \"suite\": \"Apt. 556\", \"city\": \"Gwenborough\", \"zipcode\": \"92998-3874\", \"geo\": { \"lat\": \"-37.3159\", \"lng\": \"81.1496\" } }, \"phone\": \"1-770-736-8031 x56442\", \"website\": \"hildegard.org\", \"company\": { \"name\": \"SOME_COMPANY_NAME\", \"catchPhrase\": \"Multi-layered client-server neural-net\", \"bs\": \"harness real-time e-markets\" } } ] and the response body the same as the request body","title":"Example of test implementation"},{"location":"automation/api/#definition-of-request-and-response-templates","text":"If we are going to send POST request, we need to create a request template with some placeholders that may be replaced by different arguments for different test flows. The best place to store these resources is src/test/resources/api package, try to keep REST hierarchy in a package structure for better maintenance and visibility: Request (rq.json) and response (rs.json) templates have some placeholders that will be populated from the tests later on: While user.properties contains some default value which may be replaced later:","title":"Definition of request and response templates"},{"location":"automation/api/#rest-service-call-domain-object","text":"Now we are ready to create REST service domain object which will be used to interact with web service and perform additional response validations. Our domain object is located in /carina-demo/src/main/java/com/qaprosoft/carina/demo/api, make sure that it extends AbstractApiMethodV2 and triggers the base class constructor for initialization. In general cases, you will specify the path to request and response templates along with default properties files (all of them have been created in the previous step). Also, we replace the URL placeholder to set an appropriate environment. package com.qaprosoft.carina.demo.api; import com.qaprosoft.carina.core.foundation.api.AbstractApiMethodV2; import com.qaprosoft.carina.core.foundation.utils.Configuration; public class PostUserMethod extends AbstractApiMethodV2 { public PostUserMethod() { super(\"api/users/_post/rq.json\", \"api/users/_post/rs.json\", \"api/users/user.properties\"); replaceUrlPlaceholder(\"base_url\", Configuration.getEnvArg(\"api_url\")); } }","title":"REST service call domain object"},{"location":"automation/api/#http-method-and-path","text":"The last step before the test implementation itself is the association of the domain object class and the required HTTP method and path. It should be defined in /carina-demo/src/main/resources/_api.properties file, the key should be equal to domain class name, the value has the following pattern {http_method}:{http_path}. The HTTP path may contain placeholders, the HTTP method should be one of the following variants: GET, POST, PUT, UPDATE, DELETE. #=====================================================# #=================== API methods ====================# #=====================================================# GetUserMethods=GET:${base_url}/users PostUserMethod=POST:${base_url}/users DeleteUserMethod=DELETE:${base_url}/users/1 PutPostsMethod=PUT:${base_url}/posts/1 PatchPostsMethod=PATCH:${base_url}/posts/1","title":"HTTP method and path"},{"location":"automation/api/#api-test","text":"API test is a general TestNG test, a class should extend APITest, in our case, the test implements IAbstractTest that encapsulates some test data and login method. The test is located in /carina-demo/src/test/java/com/qaprosoft/carina/demo. package com.qaprosoft.carina.demo; import java.lang.invoke.MethodHandles; import com.qaprosoft.carina.core.foundation.IAbstractTest; import org.skyscreamer.jsonassert.JSONCompareMode; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.testng.annotations.Test; import com.qaprosoft.apitools.validation.JsonCompareKeywords; import com.qaprosoft.carina.core.foundation.api.http.HttpResponseStatusType; import com.qaprosoft.carina.core.foundation.utils.ownership.MethodOwner; import com.qaprosoft.carina.core.foundation.utils.tag.Priority; import com.qaprosoft.carina.core.foundation.utils.tag.TestPriority; import com.qaprosoft.carina.demo.api.DeleteUserMethod; import com.qaprosoft.carina.demo.api.GetUserMethods; import com.qaprosoft.carina.demo.api.PostUserMethod; /** * This sample shows how create REST API tests. * * @author qpsdemo */ public class APISampleTest implements IAbstractTest { private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUser() throws Exception { LOGGER.info(\"test\"); setCases(\"4555,54545\"); PostUserMethod api = new PostUserMethod(); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testCreateUserMissingSomeFields() throws Exception { PostUserMethod api = new PostUserMethod(); api.getProperties().remove(\"name\"); api.getProperties().remove(\"username\"); api.expectResponseStatus(HttpResponseStatusType.CREATED_201); api.callAPI(); api.validateResponse(); } @Test() @MethodOwner(owner = \"qpsdemo\") public void testGetUsers() { GetUserMethods getUsersMethods = new GetUserMethods(); getUsersMethods.expectResponseStatus(HttpResponseStatusType.OK_200); getUsersMethods.callAPI(); getUsersMethods.validateResponse(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey()); getUsersMethods.validateResponseAgainstSchema(\"api/users/_get/rs.schema\"); } @Test() @MethodOwner(owner = \"qpsdemo\") @TestPriority(Priority.P1) public void testDeleteUsers() { DeleteUserMethod deleteUserMethod = new DeleteUserMethod(); deleteUserMethod.expectResponseStatus(HttpResponseStatusType.OK_200); deleteUserMethod.callAPI(); deleteUserMethod.validateResponse(); } }","title":"API test"},{"location":"automation/api/#test-steps-once-again","text":"Create REST call object Specify the properties for a request/response placeholder Add headers if required Specify the expected HTTP status Call API Validate the response by a template or parse some data by JSON path Make further calls using the data from the previous call if needed","title":"Test steps once again"},{"location":"automation/api/#useful-features","text":"The framework contains a list of useful features for building requests and validation of responses. It makes the support of such tests easier and at the same time minimizes the amount of test data.","title":"Useful features"},{"location":"automation/api/#wildcards","text":"In some cases, you may need to generate data in the request to make the request data unique. The best way to do this is to use wildcards for data generation: { \"username\": \"generate_word(10)\", // Will generate random alphanumeric string with 10 characters \"zip\": \"generate_number(6)\", // Will generate random number with 6 digits \"birthday\": \"generate_date(yyyy-MM-dd;0)\" // Will generate current date (first arg is date format, second is delta in days from now) } Another option is to specify the placeholder in the request template and then pass some generated value directly from the test method. Wildcards are also useful for response validation. In some cases, you may need to skip some values or validate by regex: { \"id\": \"skip\", // Will skip actual value validation and just verify id key presence \"signup_date\": \"regex:\\\\d{4}-\\\\d{2}-\\\\d{2}\", // Will validate date value by specified regex }","title":"Wildcards"},{"location":"automation/api/#validation-against-json-schema","text":"When you need to validate response structure regardless of the actual values, you may use validation by JSON schema. In this case, you need an actual response from the service, let's say we have the following: { \"email\": \"test@domain.com\", \"firstName\": \"SOME FIRST NAME\", \"id\": 11111 } Now we need to generate a schema (you may use any generator you like, for example, https://jsonschema.net/). IMPORTANT: For now, the schemas of version draft03 and draft04 are supported only. Please, use the appropriate generator (e.g. https://www.liquid-technologies.com/online-json-to-schema-converter) In the tool like this you need to provide the original JSON from the response, then choose some schema options (allow the additional properties in objects, mark the current object properties as required, hard-code some expected values, etc.) and then generate the schema. Copy-paste the generated schema into test resources, and you're ready to use it in the test. Make sure that you change all the required flags to true. After that, create a new file in the resources and place it into an appropriate endpoint package: { \"type\":\"object\", \"$schema\": \"http://json-schema.org/draft-03/schema\", \"id\": \"http://jsonschema.net\", \"required\":true, \"properties\":{ \"email\": { \"type\":\"string\", \"id\": \"http://jsonschema.net/email\", \"required\":true }, \"firstName\": { \"type\":\"string\", \"id\": \"http://jsonschema.net/firstName\", \"required\":true }, \"id\": { \"type\":\"number\", \"id\": \"http://jsonschema.net/id\", \"required\":true } } } And finally, we call JSON validation from Java test as the following: @Test public void testCheckJSONSchema() { PostUserLoginMethod api = new PostUserLoginMethod(); api.expectResponseStatus(HttpResponseStatusType.OK_200); api.callAPI(); api.validateResponseAgainstJSONSchema(\"api/testdata/users/login/_post/rs.schema\"); }","title":"Validation against JSON schema"},{"location":"automation/api/#building-requests-with-an-array","text":"There are a couple of options for building a request with an array of items provided by the framework: 1. The first one uses hardcoded placeholders for changeable variables. { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ { \"name\": \"${task_name_1}\", \"description\": \"${task_description_1}\" } <#if task_name_2?exists || task_description_2?exists>, { \"name\": \"${task_name_2}\", \"description\": \"${task_description_2}\" } </#if> <#if task_name_3?exists || task_description_3?exists>, { \"name\": \"${task_name_3}\", \"description\": \"${task_description_3}\" } </#if> ] } As you see, this structure is quite flexible. If you need 2 taskTypes items, you need to declare at least task_name_2 or task_description_2 property. If you need 3 items in addition to that, you need to declare a task_name_3 or task_description_3 property. Otherwise, the array will contain only 1 item. For instance, you need to build JSON which contains a taskTypes array. Then the template with placeholders will be the following: It's easy to extend such a structure. You just need to add items with similar placeholders increasing their index. Another approach is based on using Freemarker loop. Here is the template example for the same JSON: <#if task_name_1?exists> <#assign task_names = [task_name_1]> <#assign task_descriptions = [task_description_1]> </#if> <#if task_name_2?exists> <#assign task_names = [task_name_1, task_name_2]> <#assign task_descriptions = [task_description_1, task_description_2]> </#if> <#if task_name_3?exists> <#assign task_names = [task_name_1, task_name_2, task_name_3]> <#assign task_descriptions = [task_description_1, task_description_2, task_description_3]> </#if> { \"name\": \"${name}\", \"description\": \"${description}\", \"label\": \"${label}\", \"taskTypes\": [ <#list 0..task_names?size-1 as i> { \"name\": \"${task_names[i]}\", \"description\": \"${task_descriptions[i]}\" } <#if (i + 1) < task_names?size>,</#if> </#list> ] } This approach is useful when the structure of an array item is quite complex. So, it makes sense to specify the item attributes only once, doing it inside #list operation. This approach also allows to choose the amount of array items dynamically. But note that you should specify all properties for every item, so this view cannot be used for negative tests when you need to miss some properties.","title":"Building requests with an array"},{"location":"automation/api/#validation-of-responses-with-an-array","text":"Sometimes you can face a situation when you need to validate the presence of only one item (or a couple of them) in a JSON array ignoring the rest of the items. In such case, you can use a validation option ARRAY_CONTAINS. Here is a code sample: JSONAssert.assertEquals(expectedRs, actualRs, new JsonKeywordsComparator(JSONCompareMode.STRICT, JsonCompareKeywords.ARRAY_CONTAINS.getKey() + \"content\")); The expected array: { \"totalElements\": \"skip\", \"pageNumber\": \"skip\", \"pageSize\": \"skip\", \"content\": [ { \"id\": skip, \"brand\": \"skip\", \"clientName\": \"CLIENT 1\" }, { \"id\": \"skip\", \"brand\": \"skip\", \"clientName\": \"CLIENT 2\" } ] } And the actual response: { \"totalElements\": 1017, \"pageNumber\": 0, \"pageSize\": 100, \"content\": [ { \"id\": 11111, \"brand\": \"test\", \"clientName\": \"CLIENT 1\" }, { \"id\": 22222, \"brand\": \"test\", \"clientName\": \"CLIENT 2\" }, { \"id\": 3333, \"brand\": \"test\", \"clientName\": \"CLIENT 3\" }, { \"id\": 4444, \"brand\": \"test\", \"clientName\": \"CLIENT 4\" } ] }","title":"Validation of responses with an array"},{"location":"automation/api/#deserialization-of-json","text":"Sometimes you may need to transform your JSON response to POJO. It may be useful if you need to validate your response using the data from a database as the expected data. For this purpose, it's better to use Jackson libraries that are already included in Carina framework. For this, you need to prepare the domain class based on your JSON structure. Some online resources provide such opportunities, like https://timboudreau.com/blog/json/read. Let's say we need to deserialize an array of Clients from JSON. An example of the required domain object will be: import org.codehaus.jackson.annotate.JsonCreator; import org.codehaus.jackson.annotate.JsonProperty; public final class Clients { public final Client clients[]; @JsonCreator public Clients(@JsonProperty(\"clients\") Client[] clients) { this.clients = clients; } public static final class Client { public final long id; public final String brand; public final String clientName; ...... @JsonCreator public Client(@JsonProperty(\"id\") long id, @JsonProperty(\"brand\") String brand, @JsonProperty(\"clientName\") String clientName,.....) { this.id = id; this.brand = brand; this.clientName = clientName; ......... } } public Client[] getClients() { return clients; } } Pay attention that POJO field names can differ from JSON properties. In this case, @JsonProperty annotation can be used for mapping. An example of a deserialization code: GetClientsMethod getClientsMethod = new GetClientsMethod(\"11111\"); getClientsMethod.expectResponseStatus(HttpResponseStatusType.OK_200); String rs = getClientsMethod.callAPI().asString(); ObjectMapper mapper = new ObjectMapper(); Clients clients = mapper.readValue(rs, Clients.class); Then you can use POJO object for any kind of validation or for easy retrieving of the required properties.","title":"Deserialization of JSON"},{"location":"automation/api/#security","text":"Carina provides some security features that could be used to hide/protect sensitive data in your API calls.","title":"Security"},{"location":"automation/api/#encryption-of-api-method-properties","text":"It's possible to use default carina crypto logic for automatic decription of sensitive data. In order to encrypt the data you can use carina's CryptoConsole Then you can save your encrypted properties using default pattern: \"{crypt:ENCRYPTED_TXT}\" During properties parsing process carina-api module will automatically decrypt the text and put decrypted value into request body.","title":"Encryption of API method properties"},{"location":"automation/api/#hiding-of-api-request-headers","text":"In order to hide the value of API request header you need to annotate your API method with @HideRequestHeadersInLogs annotation. Usage sample: @HideRequestHeadersInLogs(headers = \"Content-Type\") public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Then in your test logs for mentioned headers you'll get \"[ BLACKLISTED ]\" mask","title":"Hiding of API request headers"},{"location":"automation/api/#hiding-of-api-call-body-parts","text":"If you want not to show some sensitive data in body of your api calls in test logs then you'll need to annotate your API method with @HideRequestBodyPartsInLogs/@HideResponseBodyPartsInLogs annotations. These annotations support both json and xml content type. As the value of annotation you need to pass array of JSON or XML paths you want to hide. Once done in test logs you'll get \"********\" mask instead of actual values. Example for json: @HideRequestBodyPartsInLogs(paths = { \"$.[*].username\", \"$.[*].id\" }) @HideResponseBodyPartsInLogs(paths = { \"$.[*].address.zipcode\", \"$.[*].address.geo.lat\", \"$.[*].id\" }) public class YourAPIMethod extends AbstractApiMethodV2 { public YourAPIMethod() { } } Example for xml: @HideRequestBodyPartsInLogs(paths = { \"//root/city/text()\" }) @HideResponseBodyPartsInLogs(paths = { \"//root/state/text()\" }) @ContentType(type = \"application/xml\") public class XmlPostMethod extends AbstractApiMethodV2 { public XmlPostMethod() { } } Important: for XML content type it's obligatory to pass @ContentType annotation to your API method indicating actual header value. If @ContentType is not specified then data will be automatically considered as JSON.","title":"Hiding of API call body parts"},{"location":"automation/mobile/","text":"Carina framework provides a useful and elegant way of Mobile (Android and iOS) Test Automation. The best practices have a lot in common with web automation, so it's highly recommended to look through Web automation article . Mobile special requirements: To run mobile tests, Appium is used instead of Selenium. There are 2 versions of Appium: desktop and console ones, and both are good for Carina. Appium must be running every time before the test run. Android special requirements: Android SDK (part of Android Studio ) is an important component for work. Pay attention that after installing Android Studio you sometimes (depends on a version) need to additionally install ADB (Mac only). Edit your PATH variable and add ANDROID_HOME (path to \"sdk\" folder) to PATH. Sometimes (mostly on Mac) need to add paths to important folders inside sdk, such as \"platform-tools\" (ADB is located here), \"tools\" and \"build-tools\". apk file - installation file of a program that's being tested is required, the same for both - a real device and an emulator. iOS special requirements: Xcode is a vital component for work so iOS testing is available only on Mac OS. Installation file of a program that's being tested is required. For a real device it's ipa file, and for a simulator it is app file. App file should be provided by developers and has special signatures to work correctly. Mobile config properties We can provide any Appium capability in the _config.properties file using capabilities.name=value format. In the table below we are providing the description of the most popular mobile capabilities: Attribute Meaning Default value Example capabilities.deviceName Device name for report n/a Sumsung_Galaxy_J5 capabilities.deviceType The only custom Carina capability to determine the type of a device n/a phone/tablet/tv... capabilities.platformName Name of the mobile platform n/a Android/iOS/AndroidTV/tvOS capabilities.platformVersion Version of the mobile platform n/a 6.0.1 capabilities.app Path to the application (apk/app/ipa) which is tested, can be provided as a pattern from AWS S3 storage with automatic downloading n/a D:/application.apk, s3://qaprosoft.com/android/myapk.*-release.apk capabilities.newCommandTimeout New implicit timeout in seconds to wait for the element for mobile automation n/a 180 capabilities.udid Unique Device ID n/a 759b543c capabilities.appActivity Activity name for the Android activity you want to launch from your package. n/a com.amazon.mShop.HomeActivity capabilities.appPackage Java package of the Android app you want to run n/a in.amazon.mShop.android.shopping capabilities.noSign Skips checking and signing of the app with debug keys, will work only with UiAutomator and not with selendroid, defaults to false n/a true, false capabilities.autoGrantPermissions Has Appium automatically determine which permissions your app requires and grants them to the app on install. Defaults to false n/a true, false Actual list of Appium capabilities can be found here . Example for Android of _config.properties: selenium_url=http://localhost:4723/wd/hub #============ Android Local Mobile ===================# capabilities.platformName=ANDROID capabilities.deviceName=Nexus_6 capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.noSign=true capabilities.autoGrantPermissions=true #=====================================================# Example for iOS of _config.properties: selenium_url=http://localhost:4723/wd/hub #======== Local Run for iOS Mobile ===============# capabilities.platformName=iOS capabilities.deviceName=iPhone X capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip #=====================================================# Implementation of Page Objects: The main idea is the same as in web-testing . How to find locators for Android application To obtain the locators of elements from an Android app different programs are used such as Appium itself or convenient Android SDK tool: uiautomatorviewer . Example: @FindBy(xpath = \"//*[@resource-id='name_input']\") private ExtendedWebElement input; How to find locators for iOS application To obtain the locators of elements from an iOS app different programs are used such as Appium itself or convenient Macaca App Inspector . To speed up element detection @Predicate annotation can be used used. Complicate \"xpath\" can't be used with predicates. Example: @FindBy(xpath = \"name = 'DONE'\") @Predicate protected ExtendedWebElement doneButton; Another possibility to find the element is to use @ClassChain annotation. Example: @FindBy(xpath = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") @ClassChain protected ExtendedWebElement developerText; Starting from Carina version 6.0.12, it's recommended to use @ExtendedFindBy() annotation. Example: @ExtendedFindBy(iosClassChain = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") protected ExtendedWebElement developerText; or @ExtendedFindBy(iosPredicate = \"name = 'DONE'\") protected ExtendedWebElement developerText; Implementation of tests Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class SampleTest implements IAbstractTest { String name = \"My name\"; String carName = \"Mercedes\"; @Test() public void sendName() { FirstPage firstPage = new FirstPage(getDriver()); GoogleTestPage googleTestPage = new GoogleTestPage(getDriver()); MyWayOfHelloPage myWayOfHelloPage = new MyWayOfHelloPage(getDriver()); firstPage.clickOnGooleButton(); googleTestPage.setName(name); googleTestPage.clickOnSpinner(); googleTestPage.selectCar(carName); googleTestPage.clickOnSendYourNameButton(); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(name), \"Assert message\" ); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(carName.toLowerCase()), \"Assert message\" ); } } Important: * Test class should implement com.qaprosoft.carina.core.foundation.IAbstractTest * Test method should start with org.testng.annotations.Test annotation * Use getDriver() method to get driver instance in test * Locate tests in src/test/java source folder How to use CustomTypePageFactory Carina provides the technique to combine Desktop/iOS/Android tests into the single test class/method. For all platforms you should use Page Object Design Pattern , but in a bit improved way. Every page has an abstract declaration and different implementations if needed (by default, 3 ones should be enough: Desktop, iOS/Android): Common abstract page in a common package with common methods and elements; Desktop page in a desktop package with desktop methods and elements; iOS page in ios package with iOS methods and elements; Android page in android package with Android methods and elements. Children pages should extend BasePage implementing all abstract methods. Annotation @DeviceType will provide the information about the device type and the parent (common) page. Examples: Common (Base) Page public abstract class HomePageBase extends AbstractPage { public HomePageBase(WebDriver driver) { super(driver); } public abstract PhoneFinderPageBase openPhoneFinder(); public abstract ComparePageBase openComparePage(); } Android Page @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='Phone Finder']\") protected ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='compare']\") protected ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } iOS Page @DeviceType(pageType = Type.IOS_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"name = 'Phone Finder'\") @Predicate private ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"name = 'Compare'\") @Predicate private ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } Inside every test, Carina operates with an abstract base page using CustomTypePageFactory and substitutes it by the real implementation based on the desired capabilities in _config.properties etc. Example: @Test public void comparePhonesTest() { HomePageBase homePage = CustomTypePageFactory.initPage(getDriver(), HomePageBase.class); ComparePageBase phoneFinderPage = homePage.openCompare(); ... } If there are differences in application according to OS version, just implement the pages for different versions and include the version parameter in @DeviceType for every page. Example: For Android 8 (either 8.0 or 8.1) @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { Or for a specific version @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8.1\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { How to use Find by Image strategy Find by image strategy is based on appium implementation . Be sure you have OpenCV libraries installed to your system . Find by image logic is covered by @ExtendedFindBy annotation. Example: @ExtendedFindBy(image = \"images/singUp6.png\") private ExtendedWebElement signUpBtn; The list of actions with image elements and related driver settings is available here . Basically, all you need is to create an image template of the element in .png format and place it to your project. We suggest using src/main/resources/ folder to store images. Be sure your image size is less than the real screen size. Real iOS screen sizes are listed here in 'UIKit Size (Points)' column. You can also find the ultimate guide to iPhone resolutions here . How to change context of application In carina-demo there is an example of a tool , that can change context of application. Just add needed context as a field in View enum. // for example NATIVE(\"NATIVE_APP\"), WEB1(\"WEBVIEW_chromeapp\"), WEB2(\"WEBVIEW_opera\"); Then change context in your test/page class where needed. public void testWebView() { WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); LoginPageBase loginPage = welcomePage.clickNextBtn(); loginPage.login(); WebViewPageBase webViewPageBase = initPage(getDriver(), WebViewPageBase.class); MobileContextUtils contextHelper = new MobileContextUtils(); contextHelper.switchMobileContext(View.WEB); ContactUsPageBase contactUsPage = webViewPageBase.goToContactUsPage(); contactUsPage.typeName(\"John Doe\"); contactUsPage.typeEmail(\"some@email.com\"); contactUsPage.typeQuestion(\"This is a message\"); contactUsPage.submit(); Assert.assertTrue(contactUsPage.isErrorMessagePresent() || contactUsPage.isRecaptchaPresent(), \"Error message or captcha was not displayed\"); }","title":"Mobile"},{"location":"automation/mobile/#mobile-special-requirements","text":"To run mobile tests, Appium is used instead of Selenium. There are 2 versions of Appium: desktop and console ones, and both are good for Carina. Appium must be running every time before the test run.","title":"Mobile special requirements:"},{"location":"automation/mobile/#android-special-requirements","text":"Android SDK (part of Android Studio ) is an important component for work. Pay attention that after installing Android Studio you sometimes (depends on a version) need to additionally install ADB (Mac only). Edit your PATH variable and add ANDROID_HOME (path to \"sdk\" folder) to PATH. Sometimes (mostly on Mac) need to add paths to important folders inside sdk, such as \"platform-tools\" (ADB is located here), \"tools\" and \"build-tools\". apk file - installation file of a program that's being tested is required, the same for both - a real device and an emulator.","title":"Android special requirements:"},{"location":"automation/mobile/#ios-special-requirements","text":"Xcode is a vital component for work so iOS testing is available only on Mac OS. Installation file of a program that's being tested is required. For a real device it's ipa file, and for a simulator it is app file. App file should be provided by developers and has special signatures to work correctly.","title":"iOS special requirements:"},{"location":"automation/mobile/#mobile-config-properties","text":"We can provide any Appium capability in the _config.properties file using capabilities.name=value format. In the table below we are providing the description of the most popular mobile capabilities: Attribute Meaning Default value Example capabilities.deviceName Device name for report n/a Sumsung_Galaxy_J5 capabilities.deviceType The only custom Carina capability to determine the type of a device n/a phone/tablet/tv... capabilities.platformName Name of the mobile platform n/a Android/iOS/AndroidTV/tvOS capabilities.platformVersion Version of the mobile platform n/a 6.0.1 capabilities.app Path to the application (apk/app/ipa) which is tested, can be provided as a pattern from AWS S3 storage with automatic downloading n/a D:/application.apk, s3://qaprosoft.com/android/myapk.*-release.apk capabilities.newCommandTimeout New implicit timeout in seconds to wait for the element for mobile automation n/a 180 capabilities.udid Unique Device ID n/a 759b543c capabilities.appActivity Activity name for the Android activity you want to launch from your package. n/a com.amazon.mShop.HomeActivity capabilities.appPackage Java package of the Android app you want to run n/a in.amazon.mShop.android.shopping capabilities.noSign Skips checking and signing of the app with debug keys, will work only with UiAutomator and not with selendroid, defaults to false n/a true, false capabilities.autoGrantPermissions Has Appium automatically determine which permissions your app requires and grants them to the app on install. Defaults to false n/a true, false Actual list of Appium capabilities can be found here .","title":"Mobile config properties"},{"location":"automation/mobile/#example-for-android-of-_configproperties","text":"selenium_url=http://localhost:4723/wd/hub #============ Android Local Mobile ===================# capabilities.platformName=ANDROID capabilities.deviceName=Nexus_6 capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.apk capabilities.noSign=true capabilities.autoGrantPermissions=true #=====================================================#","title":"Example for Android of _config.properties:"},{"location":"automation/mobile/#example-for-ios-of-_configproperties","text":"selenium_url=http://localhost:4723/wd/hub #======== Local Run for iOS Mobile ===============# capabilities.platformName=iOS capabilities.deviceName=iPhone X capabilities.app=https://qaprosoft.s3-us-west-2.amazonaws.com/carinademoexample.zip #=====================================================#","title":"Example for iOS of _config.properties:"},{"location":"automation/mobile/#implementation-of-page-objects","text":"The main idea is the same as in web-testing .","title":"Implementation of Page Objects:"},{"location":"automation/mobile/#how-to-find-locators-for-android-application","text":"To obtain the locators of elements from an Android app different programs are used such as Appium itself or convenient Android SDK tool: uiautomatorviewer . Example: @FindBy(xpath = \"//*[@resource-id='name_input']\") private ExtendedWebElement input;","title":"How to find locators for Android application"},{"location":"automation/mobile/#how-to-find-locators-for-ios-application","text":"To obtain the locators of elements from an iOS app different programs are used such as Appium itself or convenient Macaca App Inspector . To speed up element detection @Predicate annotation can be used used. Complicate \"xpath\" can't be used with predicates. Example: @FindBy(xpath = \"name = 'DONE'\") @Predicate protected ExtendedWebElement doneButton; Another possibility to find the element is to use @ClassChain annotation. Example: @FindBy(xpath = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") @ClassChain protected ExtendedWebElement developerText; Starting from Carina version 6.0.12, it's recommended to use @ExtendedFindBy() annotation. Example: @ExtendedFindBy(iosClassChain = \"**/XCUIElementTypeStaticText[`name=='Developer'`]\") protected ExtendedWebElement developerText; or @ExtendedFindBy(iosPredicate = \"name = 'DONE'\") protected ExtendedWebElement developerText;","title":"How to find locators for iOS application"},{"location":"automation/mobile/#implementation-of-tests","text":"Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class SampleTest implements IAbstractTest { String name = \"My name\"; String carName = \"Mercedes\"; @Test() public void sendName() { FirstPage firstPage = new FirstPage(getDriver()); GoogleTestPage googleTestPage = new GoogleTestPage(getDriver()); MyWayOfHelloPage myWayOfHelloPage = new MyWayOfHelloPage(getDriver()); firstPage.clickOnGooleButton(); googleTestPage.setName(name); googleTestPage.clickOnSpinner(); googleTestPage.selectCar(carName); googleTestPage.clickOnSendYourNameButton(); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(name), \"Assert message\" ); Assert.assertTrue(myWayOfHelloPage.isTextElementPresent(carName.toLowerCase()), \"Assert message\" ); } } Important: * Test class should implement com.qaprosoft.carina.core.foundation.IAbstractTest * Test method should start with org.testng.annotations.Test annotation * Use getDriver() method to get driver instance in test * Locate tests in src/test/java source folder","title":"Implementation of tests"},{"location":"automation/mobile/#how-to-use-customtypepagefactory","text":"Carina provides the technique to combine Desktop/iOS/Android tests into the single test class/method. For all platforms you should use Page Object Design Pattern , but in a bit improved way. Every page has an abstract declaration and different implementations if needed (by default, 3 ones should be enough: Desktop, iOS/Android): Common abstract page in a common package with common methods and elements; Desktop page in a desktop package with desktop methods and elements; iOS page in ios package with iOS methods and elements; Android page in android package with Android methods and elements. Children pages should extend BasePage implementing all abstract methods. Annotation @DeviceType will provide the information about the device type and the parent (common) page. Examples: Common (Base) Page public abstract class HomePageBase extends AbstractPage { public HomePageBase(WebDriver driver) { super(driver); } public abstract PhoneFinderPageBase openPhoneFinder(); public abstract ComparePageBase openComparePage(); } Android Page @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='Phone Finder']\") protected ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"//android.widget.TextView[@resource-id='itemTitle' and @text='compare']\") protected ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } iOS Page @DeviceType(pageType = Type.IOS_PHONE, parentClass = HomePageBase.class) public class HomePage extends HomePageBase { @FindBy(xpath = \"name = 'Phone Finder'\") @Predicate private ExtendedWebElement phoneFinderTextView; @FindBy(xpath = \"name = 'Compare'\") @Predicate private ExtendedWebElement compareTextView; public HomePage(WebDriver driver) { super(driver); } @Override public PhoneFinderPageBase openPhoneFinder() { phoneFinderTextView.click(); return CustomTypePageFactory.initPage(getDriver(), PhoneFinderPageBase.class); } @Override public ComparePageBase openComparePage() { compareTextView.click(); return CustomTypePageFactory.initPage(getDriver(), ComparePageBase.class); } Inside every test, Carina operates with an abstract base page using CustomTypePageFactory and substitutes it by the real implementation based on the desired capabilities in _config.properties etc. Example: @Test public void comparePhonesTest() { HomePageBase homePage = CustomTypePageFactory.initPage(getDriver(), HomePageBase.class); ComparePageBase phoneFinderPage = homePage.openCompare(); ... } If there are differences in application according to OS version, just implement the pages for different versions and include the version parameter in @DeviceType for every page. Example: For Android 8 (either 8.0 or 8.1) @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase { Or for a specific version @DeviceType(pageType = DeviceType.Type.ANDROID_PHONE, version = \"8.1\", parentClass = HomePageBase.class) public class HomePage extends HomePageBase {","title":"How to use CustomTypePageFactory"},{"location":"automation/mobile/#how-to-use-find-by-image-strategy","text":"Find by image strategy is based on appium implementation . Be sure you have OpenCV libraries installed to your system . Find by image logic is covered by @ExtendedFindBy annotation. Example: @ExtendedFindBy(image = \"images/singUp6.png\") private ExtendedWebElement signUpBtn; The list of actions with image elements and related driver settings is available here . Basically, all you need is to create an image template of the element in .png format and place it to your project. We suggest using src/main/resources/ folder to store images. Be sure your image size is less than the real screen size. Real iOS screen sizes are listed here in 'UIKit Size (Points)' column. You can also find the ultimate guide to iPhone resolutions here .","title":"How to use Find by Image strategy"},{"location":"automation/mobile/#how-to-change-context-of-application","text":"In carina-demo there is an example of a tool , that can change context of application. Just add needed context as a field in View enum. // for example NATIVE(\"NATIVE_APP\"), WEB1(\"WEBVIEW_chromeapp\"), WEB2(\"WEBVIEW_opera\"); Then change context in your test/page class where needed. public void testWebView() { WelcomePageBase welcomePage = initPage(getDriver(), WelcomePageBase.class); LoginPageBase loginPage = welcomePage.clickNextBtn(); loginPage.login(); WebViewPageBase webViewPageBase = initPage(getDriver(), WebViewPageBase.class); MobileContextUtils contextHelper = new MobileContextUtils(); contextHelper.switchMobileContext(View.WEB); ContactUsPageBase contactUsPage = webViewPageBase.goToContactUsPage(); contactUsPage.typeName(\"John Doe\"); contactUsPage.typeEmail(\"some@email.com\"); contactUsPage.typeQuestion(\"This is a message\"); contactUsPage.submit(); Assert.assertTrue(contactUsPage.isErrorMessagePresent() || contactUsPage.isRecaptchaPresent(), \"Error message or captcha was not displayed\"); }","title":"How to change context of application"},{"location":"automation/web/","text":"Note: Starting from 7.0.4 consider that instead of extends AbstractTest we have to implements IAbstractTest interface Carina framework follows Selenium best practices for web test automation. If you are familiar with Selenium WebDriver and have already implemented a few tests with the Page Object Pattern, the following guide will be much easier for understanding. We have chosen GSM Arena public web site for demonstration purposes, the whole test source code is located in carina-demo Github repo. Implementation of Page Objects When you are writing functional tests using Selenium, the major part of your code will consist of interactions with the web interface you are testing through the WebDriver API. After fetching elements, you will verify some state of an element through various assertions and move on to fetching the next element. You may find WebElements directly in your tests: List<WebElement> zipCodes = driver.findElements(By.id(\"zipCodes\")); for (WebElement zipCode : zipCodes) { if (zipCode.getText().equals(\"12345\")){ zipCode.click(); break; } } WebElement city = driver.findElement(By.id(\"city\")); assertEquals(\"MyCityName\", city.getText()); Some of the typical problems for this type of Selenium test are: Test cases are difficult to read Changes in the UI break multiple tests, often in several places Duplication of selectors both inside and across tests - no reuse So, instead of having each test fetch elements directly and being fragile towards the UI changes, the Page Object Pattern introduces what is basically a decoupling layer. You create an object that represents the UI you want to test, which can be a whole page or a significant part of it. The responsibility of this object is to wrap HTML elements and encapsulate interactions with the UI, meaning that this is where all calls to WebDriver will go. This is where most WebElements are. And this is the only place you need to modify when the UI changes. In general, Page Object contains locators of the elements situated on the page and some business logic that may be reused by different tests: public class ModelInfoPage extends AbstractPage { @FindBy(css = \".help-display strong\") private ExtendedWebElement displayInfoLabel; @FindBy(css = \".help-camera strong\") private ExtendedWebElement cameraInfoLabel; @FindBy(css = \".help-expansion strong\") private ExtendedWebElement displayRamLabel; @FindBy(css = \".help-battery strong\") private ExtendedWebElement batteryInfoLabel; public ModelInfoPage(WebDriver driver) { super(driver); } public String readDisplay() { assertElementPresent(displayInfoLabel); return displayInfoLabel.getText(); } public String readCamera() { assertElementPresent(cameraInfoLabel); return cameraInfoLabel.getText(); } public String readRam() { assertElementPresent(displayRamLabel); return displayRamLabel.getText(); } public String readBattery() { assertElementPresent(displayInfoLabel); return batteryInfoLabel.getText(); } } Important: Page should extend com.qaprosoft.carina.core.gui.AbstractPage Use com.qaprosoft.carina.core.foundation.webdriver.decorator.ExtendedWebElement instead of Selenium WebElement Locate Page Object classes in src/main/java Implementation of UI Components In some cases, it is useful to implement UI Objects that may be reused between multiple Page Objects. For instance, a top menu or footer may be shared between multiple pages: public class FooterMenu extends AbstractUIObject { @FindBy(linkText = \"Home\") private ExtendedWebElement homeLink; @FindBy(linkText = \"Compare\") private ExtendedWebElement compareLink; public FooterMenu(WebDriver driver, SearchContext searchContext) { super(driver, searchContext); } public HomePage openHomePage() { homeLink.click(); return new HomePage(driver); } public CompareModelsPage openComparePage() { compareLink.click(); return new CompareModelsPage(driver); } } And then you can use this in Page Object: public class HomePage extends AbstractPage { @FindBy(id = \"footmenu\") private FooterMenu footerMenu; @FindBy(xpath = \"//div[contains(@class, 'brandmenu-v2')]//a\") private List<ExtendedWebElement> brandLinks; public HomePage(WebDriver driver) { super(driver); } public FooterMenu getFooterMenu() { return footerMenu; } public BrandModelsPage selectBrand(String brand) { LOGGER.info(\"selecting '\" + brand + \"' brand...\"); for (ExtendedWebElement brandLink : brandLinks) { String currentBrand = brandLink.getText(); LOGGER.info(\"currentBrand: \" + currentBrand); if (brand.equalsIgnoreCase(currentBrand)) { brandLink.click(); return new BrandModelsPage(driver); } } throw new RuntimeException(\"Unable to open brand: \" + brand); } } Important: UI Object should extend com.qaprosoft.carina.core.gui.AbstractUIObject You should call the super constructor super(driver, searchContext) where searchContext is an instance of org.openqa.selenium.SearchContext Locate UI Object classes in src/main/java source folder Implementation of tests Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class WebSampleTest implements IAbstractTest { @Test() @MethodOwner(owner = \"qpsdemo\") public void testCompareModels() { // Open GSM Arena home page and verify page is opened HomePage homePage = new HomePage(getDriver()); homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); CompareModelsPage comparePage = footerMenu.openComparePage(); // Compare 3 models List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); // Verify model announced dates Assert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2015, November\"); Assert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2016, September\"); Assert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); } } It is good practice to implement all elements search logic of Page Object/UI Object side and perform assertions and validations in the test, do not mix this logic. Important: Test class should implement com.qaprosoft.carina.core.foundation.IAbstractTest Test method should start with org.testng.annotations.Test annotation Use getDriver() method to get driver instance in the test Locate tests in src/test/java source folder Test configuration There are a few critical properties in a _config.properties file which are required for web test execution: url=http://www.gsmarena.com capabilities.browserName=chrome The implemented test cases should be placed in a TestNG xml file according to the test group the test belongs to. You can find more details about TestNG configuration in the official documentation . <!DOCTYPE suite SYSTEM \"https://testng.org/testng-1.0.dtd\"> <suite verbose=\"1\" name=\"Carina Demo Tests - Web Sample\" parallel=\"methods\"> <test name=\"GSM arena web tests\"> <classes> <class name=\"com.qaprosoft.carina.demo.WebSampleTest\" /> </classes> </test> </suite> Page opening strategy Determines how carina detects whether expected page is opened: By Url. (by default) By Element presence on the page By URL and Element To check if page was opened is used: page.isPageOpened(); //or page.assertPageOpened(); // equals Assert.assertTrue(page.isPageOpened(),\"PageName not loaded: reason); Page opening strategy configuration can be set in several places: 1) in _config.properties . This determines whole project page open strategy. 2) In page.class. This overrides global page opening strategy for a specific page. ``` public class Page extends AbstractPage { public Page(WebDriver driver){ super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } } ``` 3) In test.class. This also overrides global page opening strategy for a specific page. ``` @Test public void test(){ HomePage homePage=new HomePage(getDriver()); homePage.open(); homePage.setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } ``` Strategy usage examples: By URL ``` //This is a default value. To use it you need to set a real page urls into your page classes. private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); setPageAbsoluteURL(specificPageUrl); //set's full url //or setPageURL(\"/specific/url\"); //add's String to url from _config_properties } ``` By Element ``` //To use this strategy, you need to specify ui load marker. @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_ELEMENT); setUiLoadedMarker(element); } ``` By URL and Element ``` private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL_AND_ELEMENT); setUiLoadedMarker(element); setPageAbsoluteURL(specificPageUrl); } ``` Element loading strategy Determines how carina detects appearing of web elements on page By presence. Carina waits for appearance of web elements in page DOM model. By visibility. Carina waits until web elements would be visible in page. By presence or visibility (default). It is recommended to use element_loading_strategy=BY_VISIBILITY because in some cases condition with presence happens faster but elements are still not accessible due to invisibility at this short period of time. Element loading strategy could be set at the same places as Page opening strategy . To check if element presence: Component component = Page.getComponent(); component.assertUIObjectPresent(); // equals to Assert.assertTrue(component.isUIObjectPresent(),\"UI object componentName does not present!\"); component.assertUIObjectNotPresent(); // equals to Assert.assertTrue(!component.isUIObjectPresent(),\"UI object componentName presents!\"); Dynamic elements loading. waitForJSToLoad() method was introduced in AbstractPage class. It uses JS under the hood and helps to wait till all dynamic web elements on the page are getting loaded.","title":"Web"},{"location":"automation/web/#implementation-of-page-objects","text":"When you are writing functional tests using Selenium, the major part of your code will consist of interactions with the web interface you are testing through the WebDriver API. After fetching elements, you will verify some state of an element through various assertions and move on to fetching the next element. You may find WebElements directly in your tests: List<WebElement> zipCodes = driver.findElements(By.id(\"zipCodes\")); for (WebElement zipCode : zipCodes) { if (zipCode.getText().equals(\"12345\")){ zipCode.click(); break; } } WebElement city = driver.findElement(By.id(\"city\")); assertEquals(\"MyCityName\", city.getText()); Some of the typical problems for this type of Selenium test are: Test cases are difficult to read Changes in the UI break multiple tests, often in several places Duplication of selectors both inside and across tests - no reuse So, instead of having each test fetch elements directly and being fragile towards the UI changes, the Page Object Pattern introduces what is basically a decoupling layer. You create an object that represents the UI you want to test, which can be a whole page or a significant part of it. The responsibility of this object is to wrap HTML elements and encapsulate interactions with the UI, meaning that this is where all calls to WebDriver will go. This is where most WebElements are. And this is the only place you need to modify when the UI changes. In general, Page Object contains locators of the elements situated on the page and some business logic that may be reused by different tests: public class ModelInfoPage extends AbstractPage { @FindBy(css = \".help-display strong\") private ExtendedWebElement displayInfoLabel; @FindBy(css = \".help-camera strong\") private ExtendedWebElement cameraInfoLabel; @FindBy(css = \".help-expansion strong\") private ExtendedWebElement displayRamLabel; @FindBy(css = \".help-battery strong\") private ExtendedWebElement batteryInfoLabel; public ModelInfoPage(WebDriver driver) { super(driver); } public String readDisplay() { assertElementPresent(displayInfoLabel); return displayInfoLabel.getText(); } public String readCamera() { assertElementPresent(cameraInfoLabel); return cameraInfoLabel.getText(); } public String readRam() { assertElementPresent(displayRamLabel); return displayRamLabel.getText(); } public String readBattery() { assertElementPresent(displayInfoLabel); return batteryInfoLabel.getText(); } } Important: Page should extend com.qaprosoft.carina.core.gui.AbstractPage Use com.qaprosoft.carina.core.foundation.webdriver.decorator.ExtendedWebElement instead of Selenium WebElement Locate Page Object classes in src/main/java","title":"Implementation of Page Objects"},{"location":"automation/web/#implementation-of-ui-components","text":"In some cases, it is useful to implement UI Objects that may be reused between multiple Page Objects. For instance, a top menu or footer may be shared between multiple pages: public class FooterMenu extends AbstractUIObject { @FindBy(linkText = \"Home\") private ExtendedWebElement homeLink; @FindBy(linkText = \"Compare\") private ExtendedWebElement compareLink; public FooterMenu(WebDriver driver, SearchContext searchContext) { super(driver, searchContext); } public HomePage openHomePage() { homeLink.click(); return new HomePage(driver); } public CompareModelsPage openComparePage() { compareLink.click(); return new CompareModelsPage(driver); } } And then you can use this in Page Object: public class HomePage extends AbstractPage { @FindBy(id = \"footmenu\") private FooterMenu footerMenu; @FindBy(xpath = \"//div[contains(@class, 'brandmenu-v2')]//a\") private List<ExtendedWebElement> brandLinks; public HomePage(WebDriver driver) { super(driver); } public FooterMenu getFooterMenu() { return footerMenu; } public BrandModelsPage selectBrand(String brand) { LOGGER.info(\"selecting '\" + brand + \"' brand...\"); for (ExtendedWebElement brandLink : brandLinks) { String currentBrand = brandLink.getText(); LOGGER.info(\"currentBrand: \" + currentBrand); if (brand.equalsIgnoreCase(currentBrand)) { brandLink.click(); return new BrandModelsPage(driver); } } throw new RuntimeException(\"Unable to open brand: \" + brand); } } Important: UI Object should extend com.qaprosoft.carina.core.gui.AbstractUIObject You should call the super constructor super(driver, searchContext) where searchContext is an instance of org.openqa.selenium.SearchContext Locate UI Object classes in src/main/java source folder","title":"Implementation of UI Components"},{"location":"automation/web/#implementation-of-tests","text":"Carina framework uses TestNG for test organization. In general, test represents a manipulation with Page Objects and additional validations of UI events. Here is sample test implementation: public class WebSampleTest implements IAbstractTest { @Test() @MethodOwner(owner = \"qpsdemo\") public void testCompareModels() { // Open GSM Arena home page and verify page is opened HomePage homePage = new HomePage(getDriver()); homePage.open(); Assert.assertTrue(homePage.isPageOpened(), \"Home page is not opened\"); // Open model compare page FooterMenu footerMenu = homePage.getFooterMenu(); Assert.assertTrue(footerMenu.isUIObjectPresent(2), \"Footer menu wasn't found!\"); CompareModelsPage comparePage = footerMenu.openComparePage(); // Compare 3 models List<ModelSpecs> specs = comparePage.compareModels(\"Samsung Galaxy J3\", \"Samsung Galaxy J5\", \"Samsung Galaxy J7 Pro\"); // Verify model announced dates Assert.assertEquals(specs.get(0).readSpec(SpecType.ANNOUNCED), \"2015, November\"); Assert.assertEquals(specs.get(1).readSpec(SpecType.ANNOUNCED), \"2016, September\"); Assert.assertEquals(specs.get(2).readSpec(SpecType.ANNOUNCED), \"2017, June\"); } } It is good practice to implement all elements search logic of Page Object/UI Object side and perform assertions and validations in the test, do not mix this logic. Important: Test class should implement com.qaprosoft.carina.core.foundation.IAbstractTest Test method should start with org.testng.annotations.Test annotation Use getDriver() method to get driver instance in the test Locate tests in src/test/java source folder","title":"Implementation of tests"},{"location":"automation/web/#test-configuration","text":"There are a few critical properties in a _config.properties file which are required for web test execution: url=http://www.gsmarena.com capabilities.browserName=chrome The implemented test cases should be placed in a TestNG xml file according to the test group the test belongs to. You can find more details about TestNG configuration in the official documentation . <!DOCTYPE suite SYSTEM \"https://testng.org/testng-1.0.dtd\"> <suite verbose=\"1\" name=\"Carina Demo Tests - Web Sample\" parallel=\"methods\"> <test name=\"GSM arena web tests\"> <classes> <class name=\"com.qaprosoft.carina.demo.WebSampleTest\" /> </classes> </test> </suite>","title":"Test configuration"},{"location":"automation/web/#page-opening-strategy","text":"Determines how carina detects whether expected page is opened: By Url. (by default) By Element presence on the page By URL and Element To check if page was opened is used: page.isPageOpened(); //or page.assertPageOpened(); // equals Assert.assertTrue(page.isPageOpened(),\"PageName not loaded: reason); Page opening strategy configuration can be set in several places: 1) in _config.properties . This determines whole project page open strategy. 2) In page.class. This overrides global page opening strategy for a specific page. ``` public class Page extends AbstractPage { public Page(WebDriver driver){ super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } } ``` 3) In test.class. This also overrides global page opening strategy for a specific page. ``` @Test public void test(){ HomePage homePage=new HomePage(getDriver()); homePage.open(); homePage.setPageOpeningStrategy(PageOpeningStrategy.BY_URL); } ``` Strategy usage examples: By URL ``` //This is a default value. To use it you need to set a real page urls into your page classes. private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL); setPageAbsoluteURL(specificPageUrl); //set's full url //or setPageURL(\"/specific/url\"); //add's String to url from _config_properties } ``` By Element ``` //To use this strategy, you need to specify ui load marker. @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_ELEMENT); setUiLoadedMarker(element); } ``` By URL and Element ``` private final String specificPageUrl = \"https://www.gsmarena.com/specific/url\"; @FindBy(id = \"id\") private ExtendedWebElement element; public Page(WebDriver driver) { super(driver); setPageOpeningStrategy(PageOpeningStrategy.BY_URL_AND_ELEMENT); setUiLoadedMarker(element); setPageAbsoluteURL(specificPageUrl); } ```","title":"Page opening strategy"},{"location":"automation/web/#element-loading-strategy","text":"Determines how carina detects appearing of web elements on page By presence. Carina waits for appearance of web elements in page DOM model. By visibility. Carina waits until web elements would be visible in page. By presence or visibility (default). It is recommended to use element_loading_strategy=BY_VISIBILITY because in some cases condition with presence happens faster but elements are still not accessible due to invisibility at this short period of time. Element loading strategy could be set at the same places as Page opening strategy . To check if element presence: Component component = Page.getComponent(); component.assertUIObjectPresent(); // equals to Assert.assertTrue(component.isUIObjectPresent(),\"UI object componentName does not present!\"); component.assertUIObjectNotPresent(); // equals to Assert.assertTrue(!component.isUIObjectPresent(),\"UI object componentName presents!\"); Dynamic elements loading. waitForJSToLoad() method was introduced in AbstractPage class. It uses JS under the hood and helps to wait till all dynamic web elements on the page are getting loaded.","title":"Element loading strategy"},{"location":"automation/windows/","text":"Windows To do Windows application automation, you need to: Download windows driver Enable developers mode for Windows Start Appium or WinAppDriver Set carina's configuration #path to your Appium/WinAppDriver server selenium_url=http://localhost:4723/wd/hub #Should be set to specify windows automation session capabilities.platformName=Windows capabilities.automationName=Windows #path to application you want to test capabilities.app=C:/Windows/system32/win32calc.exe That's all. To get access to the driver use getDriver(). Write and run tests as usual. If you want to pass specific parameters to WindowsDriver refer to Appium documentation . Code example: //page.class example public class CalculatorHomePage extends AbstractPage { @FindBy(xpath = \"/Window/Pane/Button[10]\") ExtendedWebElement fiveButton; @FindBy(xpath = \"/Window/Pane/Button[5]\") ExtendedWebElement oneButton; @FindBy(xpath = \"/Window/Pane/Button[23]\") ExtendedWebElement plusButton; @FindBy(xpath = \"/Window/Pane/Button[28]\") ExtendedWebElement resultButton; @FindBy(xpath = \"/Window/Pane/Text[3]\") ExtendedWebElement resultField; public CalculatorHomePage(WebDriver driver) { super(driver); } public void sumOneAndFive(){ fiveButton.click(); plusButton.click(); oneButton.click(); resultButton.click(); } public String getResult(){ return resultField.getText(); } } //test.class example public class CalculatorTest implements IAbstractTest { @Test public void calculatorSumTest(){ CalculatorHomePage calculator = new CalculatorHomePage(getDriver()); calculator.sumOneAndFive(); Assert.assertEquals(calculator.getResult().trim(), \"6\"); } }","title":"Windows"},{"location":"automation/windows/#windows","text":"To do Windows application automation, you need to: Download windows driver Enable developers mode for Windows Start Appium or WinAppDriver Set carina's configuration #path to your Appium/WinAppDriver server selenium_url=http://localhost:4723/wd/hub #Should be set to specify windows automation session capabilities.platformName=Windows capabilities.automationName=Windows #path to application you want to test capabilities.app=C:/Windows/system32/win32calc.exe That's all. To get access to the driver use getDriver(). Write and run tests as usual. If you want to pass specific parameters to WindowsDriver refer to Appium documentation . Code example: //page.class example public class CalculatorHomePage extends AbstractPage { @FindBy(xpath = \"/Window/Pane/Button[10]\") ExtendedWebElement fiveButton; @FindBy(xpath = \"/Window/Pane/Button[5]\") ExtendedWebElement oneButton; @FindBy(xpath = \"/Window/Pane/Button[23]\") ExtendedWebElement plusButton; @FindBy(xpath = \"/Window/Pane/Button[28]\") ExtendedWebElement resultButton; @FindBy(xpath = \"/Window/Pane/Text[3]\") ExtendedWebElement resultField; public CalculatorHomePage(WebDriver driver) { super(driver); } public void sumOneAndFive(){ fiveButton.click(); plusButton.click(); oneButton.click(); resultButton.click(); } public String getResult(){ return resultField.getText(); } } //test.class example public class CalculatorTest implements IAbstractTest { @Test public void calculatorSumTest(){ CalculatorHomePage calculator = new CalculatorHomePage(getDriver()); calculator.sumOneAndFive(); Assert.assertEquals(calculator.getResult().trim(), \"6\"); } }","title":"Windows"}]}